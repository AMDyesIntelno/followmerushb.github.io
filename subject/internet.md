# 《计算机网络 自顶向下方法》&《计算机网络》

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP_IP.png)

## 计算机网络和因特网

|术语|name|简称|
|:---:|:---:|:---:|
|主机|host|
|端系统|end system|
|因特网服务提供商|Internet Service Provider|ISP|
|传输控制协议|Transmission Control Protocol|TCP|
|网际协议|Internet Protocol|IP|
|套接字|socket|
|客户端|client|
|服务器|server|
|数字用户线|Digital Subscriber Line|DSL|
|电缆因特网接入|cable Internet access|
|调制解调器|modem|
|光纤入户|Fiber To The Home|FTTH|
|无屏蔽双绞线|Unshielded Twisted Pair|UTP|
|丢包|packet loss|
|电路交换|circuit switching|
|分组交换|packet switching|
|频分复用|Frequency-Division Multiplexing|FDM|
|时分复用|Time-Division Multiplexing|TDM|
|多宿|multi-home|
|互联网交换点|Internet eXchange Point|IXP|

### 单位换算

1 Mbps=1000 **kbps**

1 Mbps=125 **kBps**

数据传输时单位K是表示十进制,数据存储时单位K是表示2进制

### 分组交换

大部分分组交换机在链路的输入端采用**存储转发传输**

>存储转发传输指的是在交换机能够开始向输出链路传输该分组的第一个比特之前必须接收到整个分组

分组交换比电路交换的电路利用率高,比报文交换的传输时延小,交互性好

!>每个分组在互联网中独立地选择传输路径,路径可能不同

- 分组交换的优点

1. 高效:在分组传输的过程中动态分配传输带宽,对通信链路是逐段占用

2. 灵活:为每一个分组独立地选择最合适的转发路由

3. 迅速:以分组作为传送单位,可以不先建立连接就能向其他主机发送分组

4. 可靠:保证可靠性的网络协议,分布式多路由的分组交换网,使网络有很好的生存性

- 分组交换的缺点

1. 排队

2. 延时

3. 首部的开销

4. 丢包

### 电路交换

电路交换例子:传统电话网

电路交换要求必须首先在通信双方之间建立连接通道

在连接建立成功之后,双方的通信活动才能开始

通信双方需要传递的信息都是通过已经建立好的连接来进行传递的,而且这个连接也将一直被维持到双方的通信结束

电路交换可以`频分复用`和`时分复用`

优点:实时性强,时延小,交换设备成本较低

缺点:线路利用率低,电路接续时间长,通信效率低,不同类型终端用户之间不能通信

电路交换比较适用于信息量大,长报文,经常使用的固定用户之间的通信

#### 频分复用

链路中的频谱有跨域链路创建的所有链接共享

在链接期间,链路为每一条链接专用一个频段

频段的宽度称为**带宽**

#### 时分复用

对于TDM链路,时间被划分为固定期间的帧,每一个帧被划分为固定数量的时隙

当网络跨越一条链路创建一条链接时,网络在每一个帧中为该链接指定一个时隙,这些时隙专门由该链接单独使用

>电路交换网络在实时服务的情况下,要比分组网络有优势,因为分组网络的端到端时延是可变和不可预测的
>
>TDM的优势在于在当发生拥塞等网络问题时, TDM 中的数据丢失可能只会是一部分,而FDM 中就可能是大部分或全部

### 带宽

>带宽有以下两种不同的意义

- 某个信号具有的频带宽度

信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围

例如:在传统的通信线路上传送的电话信号的标准带宽是3.1kHz(从300Hz到3.4kHz,即话音的主要成分的频率范围)

这种意义的带宽的单位是赫(或千赫,兆赫,吉赫等),在过去很长的一段时间,通信的主干线路传送的是模拟信号(即连续变化的信号)

因此,表示某信道允许通过的信号频带范围就称为该信道的带宽(或通频带)

- 网络中某通道传送数据的能力

网络带宽表示在单位时间内网络中的某信道所能通过的"最高数据率"

这种意义的带宽的单位就是数据率的单位bit/s,是"比特每秒"

>在"带宽"的上述两种表述中,前者为频域称谓,而后者为时域称谓,其本质是相同的,也就是说,一条通信链路的"带宽"越宽,其所能传输的"最高数据率"也越高

### 节点总时延

节点总时延=节点处理时延+排队时延+传输时延+传播时延

除了排队时延可变之外,其他时延都是固定的

传输时延:

将**所有分组**中的比特推向链路所需的时间

`用L(bit)表示该分组的长度,用R(bps)表示链路传输速度,传输时延=L/R`

传播时延: 

当一个比特被推向链路后,该比特向下一个节点传播

从该链路起点到下一个节点传播所需的时间为传播时延

传播时延可以理解为光在该链路上的传播时间

`用d表示链路起点到下一个节点的距离,传播时延=d/光速`

对于一条链路,如果到达速率超过了链路的带宽(传输速率),并保持一定时间,则会发生拥塞:

- 分组将在路由的缓存中进行排队,等待发送进入链路(排队时延)

- 如果路由的缓存已满,则分组可能会被丢弃,信息可能会丢失(丢包)

### 吞吐量

吞吐量表示在单位时间内通过某个网络(或信道,接口)的数据量,吞吐量受网络的带宽或网络的额定速率的限制

假定从主机A到主机B通过网络传递某个文件,在任何时间瞬间的**瞬时吞吐量**是主机B接收到该文件的速率

如果该文件由F比特组成,主机B接收到所有F比特用去T秒,则文件传送的**平均吞吐量**是`F/T`bps

---

假定服务器与客户端之间通过两条通信链路和一台路由器相连,设`Rs`为服务器与路由器之间的链路速率,`Rc`为路由器与客户端之间的链路速率

显然,服务器到客户端的速率不能超过`min(Rs,Rc)`,服务器到客户端的吞吐量是`min(Rs,Rc)`,这称为**瓶颈链路**的传输速率

---

假定服务器与客户端之间通过`N`条通信链路和`N-1`台路由器相连,传输速率分别为`R1,R2,R3...`

服务器到客户端的文件传输吞吐量为`min(R1,R2,R3...)`

### 带宽时延乘积

在数据通信中,带宽时延乘积(bandwidth-delay product)指的是一个数据链路的能力(每秒比特)与来回通信延迟(单位秒)的乘积

带宽时延乘积=传播时延*带宽

其结果是以比特(或字节)为单位的一个数据总量,等同在任何特定时间该网络线路上的最大数据量(已发送但尚未确认的数据)

### 往返时间RTT

>在双方通信中,发讯方的信号传播到收讯方的时间(传播延迟),加上收讯方回传消息到发讯方的时间(如果没有造成双向传播速率差异的因素,此时间与发讯方将信号传播到收讯方的时间一样久) 

>A向B发送数据,如果数据长度是100MB,发送速率是100Mbit/s

发送时间=数据长度/发送速率=(100\*2^20\*8)/(100*10^6)=8.39s

>如果B正确收完100MB的数据后,就立即向A发送确认,再假定A只有在收到B的确认信息后,才能继续向B发送数据
>
>显然,这需要等待一个往返时间RTT,如果RTT=2s,那么可以算出A向B发送数据的有效数据率

有效数据率=数据长度/(发送时间+RTT)=(100\*2^20*8)/(8.39+2)=80.7Mbit/s

### 利用率

>利用率有信道利用率和网络利用率两种
>
>信道利用率指出某信道有百分之几的时间是被利用的(有数据通过)完全空闲的信道的利用率是零
>
>网络利用率则是全网络的信道利用率的加权平均值
>
>信道利用率并非越高越好,当某信道的利用率增大时,该信道引起的时延也就迅速增加
>
>当网络的通信量很少时,网络产生的时延并不大,但在网络通信量不断增大的情况下,由于分组在进行处理时需要排队等候,因此网络引起的时延就会增大
>
>如果令D0表示网络空闲时的时延,D表示网络当前的时延,那么在适当的假定条件下,可以用公式来表示D,D0和利用率U之间的关系

D=D0/(1-U)

>U是网络的利用率,数值在0到1之间
>
>当网络的利用率达到其容量的1/2时,时延就要加倍,当网络的利用率接近最大值1时,网络的时延就趋于无穷大
>
>因此信道或网络的利用率过高会产生非常大的时延

### 协议栈

|5层因特网协议栈|7层OSI模型|
|:---:|:---:|
|应用层(报文)|应用层|
|传输层(报文段)|~~表示层~~|
|网络层(数据报)|~~会话层~~|
|链路层(帧)|传输层|
|物理层|网络层|
||链路层|
||物理层|

#### 应用层(application layer)

>应用层是体系结构中的最高层
>
>应用层的任务是通过应用进程间的交互来完成特定网络应用
>
>应用层协议定义的是应用进程间通信和交互的规则
>
>应用层交互的数据单元称为报文(message)

#### 传输层(transport layer)

>传输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务
>
>应用进程利用该服务传送应用层报文,由于一台主机可同时运行多个进程,因此传输层有复用和分用的功能
>
>复用就是多个应用层进程可同时使用下面传输层的服务,分用和复用相反,是传输层把收到的信息分别交付上面应用层中的相应进程

传输层主要使用以下两种协议:

- **传输控制协议** `TCP(Transmission Control Protocol)`--提供面向连接的,可靠的数据传输服务,其数据传输的单位是报文段(segment)

- **用户数据报协议** `UDP(User Datagram Protocol)`--提供无连接的数据传输服务(不保证数据传输的可靠性),其数据传输的单位是用户数据报

#### 网络层(network layer)

>网络层负责为分组交换网上的不同主机提供通信服务
>
>在发送数据时,网络层把传输层产生的报文段或用户数据报封装成分组或包进行传送
>
>在TCP/IP体系中,由于网络层使用IP协议,因此分组也叫做IP数据报,或简称为数据报

#### 数据链路层(data link layer)

>数据链路层常简称为链路层
>
>两台主机之间的数据传输,总是在一段一段的链路上传送的,这就需要使用专门的链路层的协议
>
>在两个相邻结点之间传送数据时,数据链路层将网络层交下来的IP数据报组装成帧(framing),在两个相邻结点间的链路上传送帧(frame)
>
>每一帧包括数据和必要的控制信息(如同步信息,地址信息,差错控制等)

#### 物理层(physical layer)

>在物理层上所传数据的单位是比特
>
>物理层为数据端设备提供传送数据通路并传输数据

#### 封装

在发送主机端,一个**应用层报文**被(应用要发送并传递到传输层的数据)传送到传输层,传输层收到报文并附上*传输层首部信息*,一并构成了**传输层报文段**

>**传输层报文段**封装了**应用层报文**

传输层向网络层传递该报文段,网络层收到报文段并附上*网络层首部信息*,生成了**网络层数据报**

>**网络层数据报**封装了**传输层报文段**

网络层向链路层传递该数据报,链路层收到数据报并附上*链路层首部信息*,生成了**链路层帧**

>**链路层帧**封装了**网络层数据报**

在每一层,一个分组具有两个类型的字段:**首部字段**和**有效载荷字段**

### 习题

1. 试在下列条件下比较电路交换和分组交换

要传送的报文共x(bit),从源点到终点共经过k段链路,每段链路的传播时延为d(s),数据率为b(bit/s)

在电路交换时电路的建立时间为s(s),在分组交换时分组长度为p(bit),且各结点的排队等待时间可忽略不计

问在怎样的条件下,分组交换的时延比电路交换的要小?

---

电路交换总时延=`k*d(总的传播时延)+x/b(传输时延)+s(电路建立时间)`

分组交换总时延=`k*d(总的传播时延)+x/b(传输时延)+(p/b)*(k-1)(最后一个分组离开源点,经过k-1个路由器的转发处理,最终到达终点所需的时间)`

当`s>(p/b)*(k-1)`时,分组交换的时延比电路交换的要小

---

2. 在上题的分组交换网中,设报文长度和分组长度分别为x和(p+h)(bit),其中p为分组的数据部分的长度,而h为每个分组所带的控制信息固定长度,与p的大小无关

通信的两端共经过k段链路,链路的数据率为b(bit/s),但传播时延和结点的排队时间均可忽略不计

若打算使总的时延为最小,问分组的数据部分长度p应取为多大?

---

分组交换总时延=`(x/p)*((p+h)/b)+(p+h)/b*(k-1)`

求导,得`(-x/p*p)*((p+h)/b)+(x/p+k-1)/b=0`,当`p=(x*h/(k-1))^0.5`时,总的时延为最小

---

3. 假定网络的利用率达到了90%,试估算一下现在的网络时延是它的最小值的多少倍

---

`D=D0/(1-U)`,此时`U=0,D=D0`

`D=D0/(1-0.9)`,此时`U=0.9,D=0.1*D0`

时延是最小值的10倍

---

4. 假定有x名用户共享一条链路,每个用户在某时刻正在传输的概率为p(0<p<1),求出在任何给定时刻,实际有n个用户在同时传输的概率

---

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/prac1-4.png)

## 物理层

### 基础知识

一个数据通信系统可划分为三大部分,即**源系统**(或发送端,发送方),**传输系统**(或传输网络)和**目的系统**(或接收端,接收方)

---

源系统一般包括以下两个部分:

- 源点(source):源点设备产生要传输的数据,例如:从计算机的键盘输入汉字,计算机产生输出的数字比特流,源点又称为源站或信源

- 发送器:通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输,典型的发送器就是**调制器**

目的系统一般也包括以下两个部分:

- 接收器:接收传输系统传送过来的信号,并把它转换为能够被目的设备处理的信息,典型的接收器就是**解调器**,它把来自传输线路上的模拟信号进行解调,提取出在发送端置入的消息,还原出发送端产生的数字比特流

- 终点(destination):终点设备从接收器获取传送来的数字比特流,然后把信息输出,终点又称为目的站,或信宿

---

通信的目的是传送**消息**(message),**数据**(data)是运送消息的实体,**信号**(signal)则是数据的电气或电磁的表现

根据信号中代表消息的参数的取值方式不同,信号可分为以下两大类:

- 模拟信号(连续信号):代表消息的参数的取值是连续的,调制解调器到电话端局之间的用户线上传送的就是模拟信号

- 数字信号(离散信号):代表消息的参数的取值是离散的,计算机到调制解调器之间,或在电话网中继线上传送的就是数字信号

在使用时间域(时域)的波形表示数字信号时,代表不同离散数值的基本波形就称为**码元**(一个码元所携带的信息量是不固定的,而是由调制方式和编码方式决定的)

在使用二进制编码时,只有两种不同的码元,一种代表0状态而另一种代表1状态

---

**信道**一般都是用来表示向某一个方向传送信息的媒体,因此,一条通信电路往往包含一条发送信道和一条接收信道

- 单向通信(单工通信)即只能有一个方向的通信而没有反方向的交互,无线电广播或有线电广播以及电视广播属于这种类型

- 双向交替通信(半双工通信)即通信的双方都可以发送信息,但不能双方同时发送(当然也就不能同时接收)这种通信方式是一方发送另一方接收,过一段时间后可以再反过来

- 双向同时通信(全双工通信)即通信的双方可以同时发送和接收信息

单向通信只需要一条信道,而双向交替通信或双向同时通信则都需要两条信道(每个方向各一条),双向同时通信的传输效率最高

---

来自信源的信号常称为**基带信号**(基本频带信号)(计算机输出的代表各种文字或图像文件的数据信号都属于基带信号)

基带信号往往包含有较多的低频成分,甚至有直流成分,而许多信道并不能传输这种低频分量或直流分量,为了解决这一问题,就必须对基带信号进行**调制**(modulation)

调制可分为两大类

一类是仅仅对基带信号的波形进行变换,使它能够与信道特性相适应,变换后的信号仍然是基带信号,这类调制称为**基带调制**

由于这种基带调制是把数字信号转换为另一种形式的数字信号,这种过程也被称为**编码**(coding)

另一类调制则需要使用**载波**(carrier)进行调制,把基带信号的频率范围搬移到较高的频段,并转换为模拟信号,这样就能够更好地在模拟信道中传输

经过载波调制后的信号称为**带通信号**(即仅在一段频率范围内能够通过信道),而使用载波的调制称为**带通调制**

- 基带调制方式

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/modulation1.jpg)

1. 不归零制:正电平代表1,负电平代表0

2. 归零制:正脉冲代表1,负脉冲代表0

3. 曼彻斯特编码:位周期中心的**向上跳变**代表0,位周期中心的**向下跳变**代表1,也可反过来定义

4. 差分曼彻斯特编码:在每一位的中心处始终都有跳变,**位开始边界**有跳变代表0,而**位开始边界**没有跳变代表1

---

- 带通调制方式

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/modulation2.jpg)

1. 调幅(AM)即载波的振幅随基带数字信号而变化,例如,0或1分别对应于无载波或有载波输出

2. 调频(FM)即载波的频率随基带数字信号而变化,例如,0或1分别对应于频率f1或f2

3. 调相(PM)即载波的初始相位随基带数字信号而变化,例如,0或1分别对应于相位0度或180度

---

**码间串扰**

如果信号中的高频分量在传输时受到衰减,那么在接收端收到的波形前沿和后沿就变得不那么陡峭了,每一个码元所占的时间界限也不再是很明确的

这样,在接收端收到的信号波形就失去了码元之间的清晰界限,将其称为**码间串扰**

**奈氏准则**

奈奎斯特给出了在假定的理想条件下,为了避免码间串扰,码元的传输速率的上限值

?>在任何信道中,码元传输的速率是有上限的,传输速率超过此上限,就会出现严重的码间串扰的问题,使接收端对码元的识别成为不可能

---

**信噪比**

信噪比就是信号的平均功率和噪声的平均功率之比,常记为S/N,并用分贝(dB)作为度量单位

`信噪比(dB)=10*log(10)(S/N)`

>当`S/N=10`时,信噪比为`10dB`,而当`S/N=1000`时,信噪比为`30dB`


**香农公式**

`信道的极限信息传输速率(bit/s)=W*log(2)(1+S/N)`

>`W`为信道的带宽(以Hz为单位),`S`为信道内所传信号的平均功率,`N`为信道内部的高斯噪声功率

!>信道的带宽或信道中的信噪比越大,信息的极限传输速率就越高

对于频带宽度已确定的信道,如果信噪比也不能再提高了,并且码元传输速率也达到了上限值,可以通过让每一个码元携带更多比特的信息来提高信息的传输速率

>栗子
>
>假定基带信号是:
>
>101011000110111010···
>
>如果直接传送,则每一个码元所携带的信息量是1bit,现将信号中的每3个比特编为一个组,即101,011,000,110,111,010...3个比特共有8种不同的排列
>
>可以用不同的调制方法来表示这样的信号,例如,用8种不同的振幅,或8种不同的频率,或8种不同的相位进行调制
>
>假定采用相位调制,用相位ϕ0表示000,ϕ1表示001,ϕ2表示010,…,ϕ7表示111,原来的18个码元的信号就转换为由6个新的码元(即由原来的每三个bit构成一个新的码元)组成的信号:101011000110111010···=ϕ5ϕ3ϕ0ϕ6ϕ7ϕ2···
>
>也就是说,若以同样的速率发送码元,则同样时间所传送的信息量就提高到了3倍

### 传输媒体

传输媒体也称为传输介质或传输媒介,是数据传输系统中在发送器和接收器之间的物理通路

传输媒体可分为两大类,即**导引型**传输媒体和**非导引型**传输媒体

>在导引型传输媒体中,电磁波被导引沿着固体媒体(铜线或光纤)传播
>
>非导引型传输媒体就是指自由空间,在非导引型传输媒体中电磁波的传输常称为无线传输

#### 导引型传输媒体

1. 双绞线

把两根互相绝缘的铜导线并排放在一起,然后用规则的方法绞合起来就构成了双绞线,绞合可减少对相邻导线的电磁干扰

- 无屏蔽双绞线`UTP(Unshielded Twisted Pair)`

- 屏蔽双绞线`STP(Shielded Twisted Pair)`

>屏蔽双绞线:为了提高双绞线抗电磁干扰的能力,在双绞线的外面再加上一层用金属丝编织成的屏蔽层

X类线主要指的是绞合程度的不同,最常用的无屏蔽双绞线为5类线,又称CAT-5

|绞合线类别|带宽|应用|
|:---:|:---:|:---:|
|CAT-3|16MHz|曾用于10 Mbit/s以太网络|
|CAT-4|20MHz|曾用于6 Mbit/s的令牌环网络|
|CAT-5|100MHz|常用在快速以太网(100 Mbit/s)中|
|CAT-5E|125MHz|常用在快速以太网及千兆以太网(1000 Mbit/s)中|
|CAT-6|250MHz|常用在千兆以太网(1000M bit/s)中|
|CAT-6A|500MHz|使用在万兆以太网(10 Gbit/s)中|
|CAT-7|600MHz|传输速率高于10Gbit/s的应用|

2. 同轴电缆

同轴电缆由内导体铜质芯线(单股实心线或多股绞合线),绝缘层,网状编织的外导体屏蔽层(也可以是单股的)以及保护塑料外层所组成

由于外导体屏蔽层的作用,同轴电缆具有很好的抗干扰特性,被广泛用于传输较高速率的数据

3. 光缆

光纤通信就是利用光导纤维传递光脉冲来进行通信,光纤是光纤通信的传输媒体

在发送端有光源,可以采用发光二极管或半导体激光器,在电脉冲的作用下能产生出光脉冲

在接收端利用光电二极管做成光检测器,在检测到光脉冲时可还原出电脉冲

**多模光纤**:存在多条不同角度入射的光线在一条光纤中传输

**单模光纤**:光纤的直径减小到只有一个光的波长,则可使光线一直向前传播,而不会产生多次反射

#### 非导引型传输媒体

1. 短波通信

短波通信主要是靠电离层的反射,但电离层的不稳定所产生的衰落现象和电离层反射所产生的多径效应,使得短波信道的通信质量较差

短波通信是唯一不受网络枢钮和有源中继体制约的远程通信手段

优点:

- 短波通信不需要建立中继站即可实现远距离通信,因而建设和维护费用低,建设周期短

- 设备简单,可以根据使用要求固定设置,进行定点固定通信,也可以背负或装入车辆,舰船,飞行器中进行移动通信

- 电路调度容易,临时组网方便,迅速,具有很大的使用灵活性

- 对自然灾害或战争的抗毁能力强

缺点:

- 可供使用的频段窄,通信容量小

- 短波的天波信道是变参信道,信号传输稳定性差

- 大气和工业无线电噪声干扰严重

---

2. 微波通信

微波通信(Microwave Communication),是使用波长在0.1毫米至1米之间的电磁波进行的通信

传统的微波通信主要有两种方式:地面微波接力通信和卫星通信

> 地面微波接力通信

微波在空间是直线传播的,而地球表面是个曲面,因此其传播距离受到限制,为实现远距离通信必须在一条微波通信信道的两个终端之间建立若干个中继站

中继站把前一站送来的信号经过放大后再发送到下一站,称为"接力"

优点:

- 微波波段频率很高,其频段范围也很宽,因此其通信信道的容量很大

- 干扰较少,传输质量较高

- 建设投资少,见效快,易于跨越山区,江河

缺点:

- 相邻站之间必须直视,不能有障碍物

- 微波通信会受到恶劣气候的影响

- 微波通信的隐蔽性和保密性较差

- 对大量中继站的使用和维护要耗费较多的人力物力

---

> 卫星通信

在太空与地面站之间利用同步卫星作为中继器的一种微波接力通信

卫星通信的最大特点是通信距离远,且通信费用与通信距离无关

卫星通信的另一特点就是具有较大的**传播**时延

---

3. 无线移动通信

> Wi-Fi

Wi-Fi,又称"无线热点"或"无线网络",是Wi-Fi联盟的商标,一个基于`IEEE 802.11`标准的无线局域网技术

- 第一代,基于IEEE 802.11原始标准,`2.4GHz`工作频段,最高速率2 Mbit/s

- 第二代,基于IEEE 802.11b,`2.4GHz`工作频段,最高速率11 Mbit/s

- 第三代,基于IEEE 802.11a,`5GHz`工作频段,最高速率54 Mbit/s,也基于IEEE 802.11g,`2.4GHz`工作频段,最高速率54 Mbit/s

- 第四代,基于IEEE 802.11n(Wi-Fi 4),信道宽度20MHz,40MHz;`2.4GHz`和`5GHz`工作频段,最高速率600 Mbit/s

- 第五代,基于IEEE 802.11ac(Wi-Fi 5)信道宽度20MHz,40MHz,80MHz,80+80MHz,160MHz;`5GHz`工作频段,最高速率6.9 Gbit/s

- 第六代,基于IEEE 802.11ax(Wi-Fi 6)信道宽度20MHz,40MHz,80MHz,80+80MHz,160MHz;`2.4GHz`和`5GHz`工作频段,最高速率9.6 Gbit/s

!>与`IEEE 802.11`区别

>`Wi-Fi`与`IEEE 802.11`常常被混淆,两者的区别可以概述为`IEEE 802.11`是一种无线局域网标准,而`Wi-Fi`是`IEEE 802.11`标准的一种实现

---

> 移动通讯标准

- 第一代移动通信技术(1G),1G使用模拟调制,为模拟式移动电话系统

- 第二代移动通信技术(2G),2G使用数字调制,对语音信息以数字化方式传输

- 第三代移动通信技术(3G),支持高速数据传输的蜂窝网络移动电话技术,3G服务能够同时发送声音(通话)及信息(电子邮件,即时通信等)

- 第四代移动通信技术(4G),4G系统不支持传统的电路交换的电话业务,而是全互联网协议(IP协议)的通信,如VoIP

- 第五代移动通信技术(5G),5G网络的主要优势在于,数据传输速率远远高于以前的蜂窝网络,最高可达10 Gbit/s,另一个优点是更快的响应时间

### 信道复用技术

最基本的复用是`频分复用FDM`(Frequency Division Multiplexing)和`时分复用TDM`(Time Division Multiplexing)

频分复用:用户在分配到一定的频带后,在通信过程中自始至终都占用这个频带,频分复用的所有用户**在同样的时间占用不同的带宽资源**("带宽"指的是频率带宽而不是数据的发送速率)

>**在同样的时间占用不同的带宽资源**:要传送的信号带宽是有限的,而线路可使用的带宽则远远大于要传送的信号带宽,通过对多路信号采用不同频率进行调制的方法,使调制后的各路信号在频率位置上错开,以达到多路信号同时在一个信道内传输的目的,因此,频分复用的各路信号是在时间上重叠而在频谱上不重叠的信号

时分复用:将时间划分为一段段等长的时分复用帧(TDM帧),每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙,每一个用户所占用的时隙周期性地出现(其周期就是TDM帧的长度),时分复用的所有用户是**在不同的时间占用同样的频带宽度**

时分复用则更有利于数字信号的传输

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TDM&FDM.jpg)

在进行通信时,复用器(multiplexer)总是和分用器(demultiplexer)成对地使用,在复用器和分用器之间是用户共享的高速信道,分用器的作用正好和复用器相反,它把高速信道传送过来的数据进行分用,分别送交到相应的用户

---

统计时分复用STDM(Statistic TDM):一种改进的时分复用,能明显地提高信道的利用率

集中器(concentrator)常使用统计时分复用,一个使用统计时分复用的集中器连接4个低速用户,然后将它们的数据集中起来通过高速线路发送到一个远程计算机

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TDM_lose.jpg)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/STDM.jpg)

---

波分复用WDM(Wavelength Division Multiplexing):光的频分复用

将一系列载有信息,但波长不同的光信号合成一束,沿着单根光纤传输,在发送端经复用器(亦称合波器,Multiplexer)汇合在一起,并耦合到光线路的同一根光纤中进行传输的技术,在接收端,经解复用器(亦称分波器或称去复用器,Demultiplexer)将各种不同波长的光信号分开,然后由光接收机作进一步处理以恢复原信号

---

码分复用CDM(Code Division Multiplexing)或码分多址CDMA(Code Division Multiple Access):是另一种共享信道的方法,每一个用户可以在同样的时间使用同样的频带进行通信,由于各用户使用经过特殊挑选的不同码型,因此各用户之间不会造成干扰

### 宽带接入技术

#### ADSL技术

非对称数字用户线ADSL(Asymmetric Digital Subscriber Line)技术是用数字技术对现有的模拟电话用户线进行改造,使其能够承载宽带数字业务

非对称:上行(从用户到电信服务提供商方向,如上传动作)和下行(从电信服务提供商到用户的方向,如下载动作)带宽不对称(即上行和下行的速率不相同)

#### 光纤同轴混合网

光纤同轴混合网HFC(Hybrid Fiber Coax)是在有线电视网CATV的基础上开发的一种居民宽带接入网

为了提高传输的可靠性和电视信号的质量,HFC网把原有线电视网中的同轴电缆主干部分改换为光纤,光纤从头端连接到光纤结点,在光纤结点光信号被转换为电信号,通过同轴电缆传送到每个用户

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HFC.jpg)

#### FTTx技术

在光纤干线和用户之间,需要铺设一段中间的转换装置即光配线网ODN(Optical Distribution Network),使数十个用户能够共享一根光纤干线,现在广泛使用的是无源光配线网

"无源"表明在光配线网中无须配备电源,无源的光配线网常称为无源光网络PON(Passive Optical Network)

光线路终端OLT(Optical Line Terminal)是连接到光纤干线的终端设备,OLT把收到的下行数据发往无源的1:N光分路器(splitter),然后用广播方式向所有用户端的光网络单元ONU(Optical Network Unit)发送

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/PON.jpg)

- 光纤到户 FTTH (Fiber To The Home):光纤一直铺设到用户家庭

- 光纤到大楼 FTTB (Fiber To The Building):光纤进入大楼后就转换为电信号,然后用电缆或双绞线分配到各用户

- 光纤到路边 FTTC (Fiber To The Curb):从路边到各用户使用双绞线作为传输媒体

### 习题

1. 假定某信道受奈氏准则限制的最高码元速率为20000码元/秒,如果采用振幅调制,把码元的振幅划分为16个不同等级来传送,那么可以获得多高的数据率(b/s)  

---

`比特率=码元速率×log(2)(L)`,在公式中L是指表示数据的信号电平的数量,本题中为16,因此数据率为`20000×log(2)(16)=80000(b/s)`   

---

2. 假定要用3kHz带宽的电话信道传送64kbit/s的数据(无差错传输),试问这个信道应具有多高的信噪比

---

`信噪比(dB)=10*log(10)(S/N)`

`信道的极限信息传输速率(bit/s)=W*log(2)(1+S/N)`

已知,信息传输速率为`64kbit/s`,信道的带宽为`3kHZ`,由此可知`S/N=2^(64/3)-1=2642244`(由`log(2)`反推),由此可知`信噪比=10*lg(S/N)=10*6.42=64.2(dB)`

---

3. 用香农公式计算一下,假定信道带宽为3100Hz,最大信息传输速率为35kbit/s,那么若想使最大信息传输速率增加60%,问信噪比S/N应增大到多少倍?如果在刚才计算出的基础上将信噪比S/N再增大到10倍,问最大信息速率能否再增加20%?

---

`信道的极限信息传输速率(bit/s)=W*log(2)(1+S/N)`

当前信噪比`S/N`为`2^(35/3.1)-1=2503`

目标信噪比`S/N`为`2^(35*1.6/3.1)-1=274131`

`S/N`应增大`100`倍

目标信噪比`S/N`为`2741310`,传输速率为`W*log(2)(1+S/N)=3100*21.38=66278`

只能增加约`18%`

## 链路层

### 基础知识

数据链路层使用的信道主要有以下两种类型:

- **点对点信道**:这种信道使用一对一的点对点通信方式

- **广播信道**:这种信道使用一对多的广播通信方式

!>注意区分`链路`和`数据链路`

`链路(link)或物理链路`就是从一个结点到相邻结点的一段物理线路(有线或无线),而中间没有任何其他的交换结点

在进行数据通信时,两台计算机之间的通信路径往往要经过许多段这样的链路,链路只是一条路径的组成部分
    
`数据链路(data link)或逻辑链路`则是另一个概念,这是因为当需要在一条线路上传送数据时,除了必须有一条物理线路外,还必须有一些必要的通信协议来控制这些数据的传输

若把实现这些协议的硬件和软件加到链路上,就构成了数据链路,最常用的方法是使用网络适配器(既有硬件,也包括软件)来实现这些协议,一般的适配器都包括了数据链路层和物理层这两层的功能

`帧`:链路层的协议数据单元

链路层把网络层传递的数据报封装成帧发送到链路上,以及从接收到的帧提取出数据包传递给网络层

---

?>点对点信道的链路层简化,每个结点只有下三层--网络层,数据链路层和物理层

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/step_of_link.jpg)

点对点信道的数据链路层在进行通信时的主要步骤如下:

- 结点A的数据链路层把网络层传递的数据报添加首部和尾部封装成链路层帧

- 结点A把封装好的帧发送给结点B的数据链路层

- 若结点B的数据链路层收到的帧无差错,则从收到的帧中提取出数据报传递给网络层,否则丢弃这个帧

---

?>链路层协议有许多种,但有三个基本问题:**封装成帧**,**透明传输**和**差错检测**

### 封装成帧

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/framing.jpg)

>**封装成帧**就是在一段数据的前后分别添加**首部**和**尾部**,接收端在收到物理层传输的比特流后,根据首部和尾部的标记,从收到的比特流中识别帧的开始和结束
>
>网络层的**数据报**传送到链路层就成为帧的**数据部分**,在帧的数据部分的前面和后面分别添加上首部和尾部,构成了一个完整的帧,这就是链路层的数据传送单元
>
>**一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度**,首部和尾部的一个重要作用就是进行帧定界(即确定帧的界限),此外,首部和尾部还包括许多必要的控制信息
>
>在发送帧时,是从帧首部开始发送的,为了提高帧的传输效率,应当使帧的数据部分长度尽可能地大于首部和尾部的长度
>
>但是,每一种链路层协议都规定了所能传送的帧的数据部分长度上限--`最大传送单元MTU(Maximum Transfer Unit)`

#### 帧定界符

当数据是由**可打印**的`ASCII`码组成的文本文件时,可以使用帧定界符

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SOH&EOT.jpg)

>帧定界可以使用特殊的帧定界符,控制字符`SOH(Start Of Header)`放在一帧的最前面,表示帧的首部开始,另一个控制字符`EOT(End Of Transmission)`表示帧的结束

!>SOH和EOT都是控制字符的名称,它们的十六进制编码分别是01(二进制是00000001)和04(二进制是00000100),SOH(或EOT)并不是S,O,H(或E,O,T)三个字符

>假定发送端在尚未发送完一个帧时突然出故障,中断了发送,但随后很快又恢复正常,于是重新从头开始发送刚才未发送完的帧
>
>由于使用了帧定界符,接收端就知道前面收到的数据是个不完整的帧(只有首部开始符SOH而没有传输结束符EOT),必须丢弃,而后面收到的数据有明确的帧定界符(SOH和EOT),因此这是一个完整的帧,应当收下

### 透明传输

?>允许传输系统或通道在其输入处接受未经修改的用户信息,并在其输出处传递形式或信息内容不变的相应用户信息,用户信息可以在传输系统内部进行更改,但是在输出之前,无需用户的参与即可恢复为原始形式

>讲人话:就是无论网络层数据报中的内容是什么都能放到链路层帧中进行传输

文本文件可以直接添加`帧定界符`

而非文本文件的数据中可能存在`SOH`或者`EOT`的二进制,所以要对非文本文件中的控制字符(`SOH`或`EOT`)进行转义

发送端的数据链路层在数据中出现控制字符`SOH`或`EOT`的前面插入一个转义字符`ESC`(其十六进制编码是`1B`),接收端的数据链路层在将数据送往网络层之前删除插入的转义字符,如果转义字符也出现数据当中,那么应在转义字符前面插入一个转义字符,当接收端收到连续的两个转义字符时,就删除其中前面的一个

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/byte_stuffing.jpg)

### 差错检测

比特差错:比特在传输过程中可能会产生差错(1可能会变成0,而0也可能变成1)

在一段时间内,传输错误的比特占所传输比特总数的比率称为`误码率BER(Bit Error Rate)`

#### 奇偶校验

1. 单比特奇偶校验

奇偶校验位有两种类型:偶校验位与奇校验位

以偶校验位来说,如果一组给定数据位中1的个数是奇数,补一个bit为1,使得总的1的个数是偶数,例:`0000001`,补一个bit为1,`00000011`

以奇校验位来说,如果一组数给定据位中1的个数是奇数,补一个bit为0,使得总的1的个数是奇数,例:`0000001`,补一个bit为0,`00000010`

!>注意奇校验无法产生全0代码,偶校验相对来说比较常用

2. 二维奇偶校验

|无差错|0|0|1|0|1|
|:---:|:---:|:---:|:---:|:---:|:---:|
|**1**|1|0|1|0|1|
|**0**|1|1|1|1|0|
|**1**|0|1|1|1|0|

|可纠正的单比特差错|0|`0`|1|0|1|
|:---:|:---:|:---:|:---:|:---:|:---:|
|**1**|1|0|1|0|1|
|**`0`**|1|`0`|1|1|0|
|**1**|0|1|1|1|0|

!>当二维奇偶校验遇到矩形错误时将无法检测和纠正

|无差错|0|0|1|0|
|:---:|:---:|:---:|:---:|:---:|
|**1**|1|1|0|1|
|**1**|1|0|1|1|
|**1**|1|1|1|0|
|**0**|1|0|1|0|

|不可纠正|0|0|1|0|
|:---:|:---:|:---:|:---:|:---:|
|**1**|1|1|0|1|
|**1**|1|`1`|`0`|1|
|**1**|1|`0`|`0`|0|
|**0**|1|0|1|0|

#### 循环冗余检测CRC

在发送端,先把数据划分为组,假定每组d个比特,设待传送的数据`D=101110(d=6)`

CRC运算就是在数据M的后面添加供差错检测用的n位冗余码,然后构成一个帧发送出去,一共发送(d+n)位

长度为`n+1`位的除数,长度为`n`位的余数

设除数`G=1001`,余数长度为`3`,则一共发送`9`位

>严格意义上来说并不是除,而是进行异或运算

|除数\商||||1|0|1|0|1|1||
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1001|`1`|`0`|`1`|`1`|`1`|`0`|0|0|0|`在D后面加n个0`|
||1|0|0|1|
|||0|1|0|1|
|||0|0|0|0|
||||1|0|1|0|
||||1|0|0|1|
|||||0|1|1|0|
|||||0|0|0|0|
||||||1|1|0|0|
||||||1|0|0|1|
|||||||1|0|1|0|
|||||||1|0|0|1|
|余数|||||||0|1|1|

得到的发送数据为`101110011`

在接收端,利用接收数据进行CRC校验,判断数据的正确性,当余数为0时,以**非常接近于1**的概率认为这些数据在传输过程中没有产生差错

|除数\商||||1|0|1|0|1|1|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1001|`1`|`0`|`1`|`1`|`1`|`0`|`0`|`1`|`1`|
||1|0|0|1|
|||0|1|0|1|
|||0|0|0|0|
||||1|0|1|0|
||||1|0|0|1|
|||||0|1|1|0|
|||||0|0|0|0|
||||||1|1|0|1|
||||||1|0|0|1|
|||||||1|0|0|1|
|||||||1|0|0|1|
|余数|||||||||0|

为了进行检错而添加的冗余码常称为`帧检验序列FCS(Frame Check Sequence)`

### 多路访问

传统意义上,广播是单向的(即一个固定的节点向许多接收节点传输),而计算机网络广播信道上的节点既能够接收也能够发送,因此存在**多路访问问题**

需要使用**多路访问协议**对多路访问行为进行规范

因为所有节点都能够传输帧,因此存在多个节点同时传输帧的情况,由此会产生**碰撞**

?>三类多接入协议:**信道划分协议**,**随机接入协议**,**轮流协议**

#### 信道划分协议

1. 时分多路复用TDM

一个支持`N`个节点的信道且信道的传输速率为`R`,TDM将时间划分为**时间帧**,并将时间帧划分为`N`个**时隙**

TDM消除了碰撞,使得每个节点在每个时间帧内得到的传输速率为`R/N`

但是,节点的速率被限制,即使其余时隙空闲,同时,节点必须等待其在传输序列中的轮次(即需要等待)

2. 频分多路复用FDM

FDM将速率为`R`的信道划分为不同的频段(每个频段具有`R/N`带宽),并把每个频率分配给`N`个节点

FDM具有和TDM一样的缺陷

3. 码分多址CDMA

CDMA对每个节点分配一种不同的编码,每个节点用其唯一编码来对其发送的数据进行编码

CDMA可以使不同的节点可以进行同时传输,且具有抗干扰特性

#### 随机接入协议

在随机接入协议中,一个传输节点总是以信道的全部速率`R`进行发送,当有碰撞时,涉及碰撞的每个节点反复重发它的帧,直到该帧无碰撞通过

但当一个节点经历一次碰撞时,不必立刻重发,而是**在重发之前等待一个随机时延**

1. 时隙ALOHA

基本假设:

- 所有的帧大小一致

- 时间轴划分为等长的时隙(slots),通常是传输一帧的时间

- 节点均只在时隙开始的时候传输

- 节点的行为是同步的

- 如果超过两个节点在一个时隙同时传输,则所有节点能侦测到碰撞

令`p`是一个概率,在每个节点中,时隙ALOHA的操作:

- 当节点有一个新帧要发送时,等到下一个时隙开始并在该时隙的传输整个帧

- 如果没有碰撞,该节点成功地传输帧,则无需考虑如何重传

- 如果有碰撞,该节点在时隙结束之前检测到该次碰撞,该节点以概率`p`在后续的每个时隙重传该帧,直到该帧被无碰撞地传输出去

>C=碰撞时隙,E=空闲时隙,S=成功时隙

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Slotted_ALOHA.png)

时隙多路访问协议的**效率**定义为:

?>当有大量的活跃节点且每个节点总有大量的帧要发送时,长期运行中成功时隙的份额

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Slotted_ALOHA_efficiency.png)

2. 载波侦听多路访问CSMA

发送数据前先监听广播信道,如果信道空闲,则发送整个帧;如果信道正忙,则延迟发送

**载波侦听**:一个节点在传输前先听信道,如果来自另一个节点的帧正向信道上发送,节点则等待直到检测到一小段时间没有传输,然后开始传输

**碰撞检测**:如果一个传输节点在传输时检测到另一个节点正在传输干扰帧,就停止传输,重复"侦听-当空闲时传输"这一循环

#### 轮流协议

1. 轮询协议

主节点以循环的方式轮询每个节点

存在的问题:

- 轮询的开销

- 延迟

- 主节点故障

2. 令牌传递协议

在这种协议中没有主节点,一个称为**令牌**的特殊帧在节点之间以某种固定的次序进行交换

存在的问题:

- 传递令牌的开销

- 延迟

- 单点故障(令牌本身)

### 链路层寻址

#### MAC地址

MAC地址(Media Access Control Address),称为媒体访问控制地址或物理地址

MAC地址长度为`6字节`共`48位`,共有`2^48`个MAC地址

前24位称为`组织唯一标志符(Organizationally Unique Identifier,即OUI)`,是由IEEE的注册管理机构给不同厂家分配的代码,用于区分不同的厂家

后24位是由厂家自己分配的,称为`扩展标识符`,同一个厂家生产的网卡中MAC地址后24位是不同的

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/MAC_address.png)

!>显然以上是理想情况,例如在华强北制作的网卡,显然不存在OUI,那么必然是伪造MAC地址甚至多个网卡同时使用一个MAC地址

>当某适配器要向目的适配器发送一个帧时,发送适配器将**目的适配器的MAC地址**插入到该帧中,并将该帧发送到局域网中
>
>有时,交换机会将一个入帧广播到其所有接口上,因此适配器会接收到并非向其发出的帧(泛洪)
>
>当适配器收到一个帧时会先检查该帧中的目的MAC地址是否与自身MAC地址匹配,如果匹配,则提取出封装的数据报将其传递给网络层,如果不匹配,则丢弃该帧
>
>有时,某发送适配器要让局域网上所有其他适配器来接收并处理其发送的帧,此时帧的目标适配器MAC地址应为`FF-FF-FF-FF-FF-FF`(广播地址)

MAC地址共分为3种,分别为**单播MAC地址**,**组播MAC地址**,**广播MAC地址**

- 单播MAC地址是指第一个字节的最低位是0的MAC地址

- 组播MAC地址是指第一个字节的最低位是1的MAC地址

- 广播MAC地址是指每个比特都是1的MAC地址(FF-FF-FF-FF-FF-FF),广播MAC地址是组播MAC地址的一个特例

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/mac_broadcast.png)

!>以**混杂方式**(promiscuous mode)工作的以太网适配器能够接收所有经过它的数据流,而不论其目的地址是否是它

#### 地址解析协议ARP

地址解析协议(Address Resolution Protocol)是一个通过**解析IP地址**来**寻找MAC地址**的网络传输协议

!>ARP是解决**同一个局域网**上的主机或路由器的IP地址和硬件地址的映射问题

每台主机或路由器中都包含一个ARP表,这张表包含IP地址到MAC地址的映射关系,同时包含该映射的有效期(TTL)

>假设A需要发送数据报给B
>
>若A的ARP表中已经有B的IP地址,则可以直接通过ARP表得知B的MAC地址并封装进链路层帧中
>
>若A的ARP表中没有B的IP地址,则需要通过ARP协议来解析这个地址
>
>首先,A构造一个`ARP分组(ARP packet)`,其中包含了发送方和接收方的IP地址以及MAC地址,ARP查询分组和相应分组具有相同的格式
>
>A使用MAC广播地址(FF-FF-FF-FF-FF-FF)发送ARP查询分组
>
>其余主机在接收到该ARP查询分组后,将检查自身的IP地址是否与ARP查询分组中的IP地址匹配,若不匹配,则不响应该ARP查询
>
>B接收到该分组后,更新自身的ARP表,向A作出回应并发送,此回应以单播的形式发出,A接收后更新ARP表

!>跨子网发送数据报

>先通过ARP获取当前子网的路由器MAC地址,并在要发送的帧中包含其他子网的主机的IP地址
>
>当该帧到达路由器后,读取该帧中包含的IP地址,通过查询路由器的转发表得到该IP地址对应的MAC地址,用该MAC地址重新封装帧并发送

### 以太网

#### 以太网的物理拓扑

- 总线拓扑(直至90年代中期)
    
    所有节点处于同一碰撞域(可能互相发生碰撞)

- 星形拓扑(现今)

    采用交换机

    每个"辐条"运行各自的以太网协议,各自组成碰撞域

在逻辑上采用总线型,在物理上采用星型

#### 以太网帧结构

|前导码|帧开始符|MAC目标地址|MAC源地址|802.1Q 标签(可选)|以太类型|数据|CRC|帧间距|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|`10101010`7个字节|`10101011`1个字节|6个字节|6个字节|(4个字节)|2个字节|46–1500个字节|4个字节|12个字节|

- 前同步码(前导码+帧开始符)

    前导码的7个字节均为`10101010`,帧开始符为`10101011`,前导码用于同步接收器的时钟,帧开始符标志着作为以太网数据包第一个字段的前同步码的结尾,并指示以太网帧的开始

- MAC目标地址&MAC源地址

    各自为6个字节的MAC地址

    如果适配器收到一个帧,其目的地址匹配自己的MAC地址,或是收到广播地址,则传输该帧的数据报至网络层,否则丢弃该帧

- 以太类型

    收到该帧之后,应传送给网络层的何种协议,多数情况下是IP协议,也有可能有其他的IP层协议

- 数据字段

    这个字段承载了数据报,以太网的最大传输单元(MTU)是1500字节,如果数据报超过1500字节,需要将该数据报分片

    最小长度为46字节,如果数据报小于46字节,则需要进行填充,当采用填充时,传递给网络层的数据包括数据报和填充部分,网络层使用数据报首部的长度来对填充部分进行去除

- CRC

    检测帧在传输过程中是否出现差错,如果有错,则丢弃该帧

- 帧间距

    当一个帧发送出去之后,发送方在下次发送帧之前,需要**再发送**至少12个字节的空闲线路状态码

!>无效的帧(对于检查出的无效MAC帧就简单地丢弃,以太网不负责重传丢弃的帧)

1. 帧长度不是整数字节

2. CRC校验失败

3. 数据字段的长度不在46~1500字节之间

4. **MAC帧**(数据字段+两个MAC地址+以太类型+CRC)长度不在64~1518字节之间

### 交换机

交换机具有**过滤**和**转发**的功能

过滤是决定一个帧应该转发到某个接口还是应当将其丢弃

转发是决定一个帧应该被导向哪个接口,并将该帧移动到该接口

交换机的过滤和转发借助于**交换机表**

交换机表中包含一个MAC地址,一个通向该MAC的的接口,以及该表项出现在表中的时间

>假定目的地址为DD-DD-DD-DD-DD-DD的帧从交换机的接口X到达,交换机用DD-DD-DD-DD-DD-DD索引自身的交换表
>
>若表中没有该MAC地址,则交换机向除了接口x外的所有接口转发该帧(泛洪)
>
>若表中该MAC地址与x接口相关联,则无需进行转发,交换机将该帧过滤并丢弃
>
>若表中该MAC地址与其他非x接口相关联,则向该接口转发该帧

交换机是**自学习**的

1. 交换机表初始为空

2. 对于在每个接口接收到的每个**入帧**,该交换机在表中存储:源MAC地址,该帧到达的接口,到达时间

3. 如果在一段时间后,没有接收到以某个地址作为**源地址**的帧,则从表中删除该地址

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(2).PNG)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(3).PNG)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(4).PNG)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(5).PNG)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(6).PNG)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(7).PNG)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(8).PNG)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(1).PNG)

### 虚拟局域网(VLAN/Virtual LAN)

虚拟局域网(VLAN)技术具有以下主要优点:

- 改善了性能
- 简化了管理
- 降低了成本
- 改善了安全性

划分虚拟局域网的方法

- 基于交换机端口
- 基于计算机网卡的MAC地址
- 基于协议类型
- 基于IP子网地址
- 基于高层应用或服务

>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符(802.1Q 标签),称为VLAN标记(tag),用来指明该帧属于哪一个虚拟局域网
>
>插入VLAN标记得出的帧称为802.1Q帧或带标记的以太网帧

## 网络层-数据平面

### 虚电路与数据报的对比

?>网络层应该向传输层提供怎样的服务?("面向连接"or"无连接")

关键在于:在计算机通信中,可靠交付应当由谁来负责?是网络还是端系统?

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VCorData.jpg)

|对比的方面|虚电路服务|数据报服务|
|:---:|:---:|:---:|   
|思路|可靠通信应当由网络来保证|可靠通信应当由用户主机来保证|
|连接的建立|必须有|不需要|
|终点地址|仅在连接建立阶段使用,每个分组使用短的虚电路号|每个分组都有终点的完整地址|
|分组的转发|属于同一条虚电路的分组均按照同一路由进行转发|每个分组独立选择路由进行转发|
|当结点出故障时|所有通过出故障的结点的虚电路均不能工作|出故障的结点可能会丢失分组,一些路由可能会发生变化|
|分组的顺序|总是按发送顺序到达终点|到达终点的时间不一定按发送顺序|
|端到端的差错处理和流量控制|可以由网络负责,也可以由用户主机负责|由用户主机负责|

!>网络层向上只提供简单灵活的,无连接的,尽最大努力交付的数据报服务

### 网络层的功能

网络层的作用在于将分组从一台发送主机传输到一台接受主机,因此网络层需要有**转发**和**路由选择**功能

- 转发

当一个分组到达某个路由器的一条输入链路时,该路由器要将该分组移动到恰当的输出链路(转发是在数据平面中实现的唯一功能)

- 路由选择

当分组从发送方流向接收方是,网络层决定这些分组所采用的路径,计算这些路径的算法称为**路由选择算法**(路由选择在控制平面实现)

### 路由器

#### 路由器架构

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/router.png)

- 输入端口

    1. 在路由器中执行终结入物理链路的物理层功能

    2. 与位于入链路的数据链路层交互,执行数据链路层功能

    3. 执行查询功能,通过查询转发表决定路由器的输出端口,到达的分组通过路由器的交换结构转发到输出端口

    ![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/input_port.png)

    ***输入端口队列***

    ![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/input_port_queue.png)

    左图:输出端口拥塞,只能发送一个红色的分组,所以下面的那个红色分组被阻塞了
    右图:过了一个分组时间后,绿色的分组就遇到了HOL阻塞

- 交换结构

    交换结构将路由器的输入端口连接到输出端口

    ![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/switch_fabric.png)

- 输出端口

    输出端口存储从交换结构接收的分组,并通过执行链路层和物理层的功能在输出链路上传输分组

- 路由选择处理器

    路由选择处理器执行控制平面功能

#### 分组调度策略

1. 先进先出(FIFO)

先进先出调度规则按照分组到达输出链路队列的相同次序(即,进入顺序为123,离开顺序也为123)来选择分组在链路上的传输

2. 优先权排队(priority queuing)

在优先权排队规则下,到达输出链路的分组被分类放入输出队列中的优先权类,基于优先级的调度,高优先级的排队分组最先发送

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/priority_queuing.png)

>如图所示,分组1,3,4的优先级较高,当1到达时,链路空闲,直接传输,当2,3到达时,虽然2先到达,但3的优先级较高,所以3先传输

3. 循环排队规则(round robin queuing discipline)

在循环排队规则下,分组向使用优先权排队那样被分类,但在类之间并不存在严格的服务优先权,循环调度器在这些类之间轮流提供服务

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/round_robin.png)

>如图所示,分组1,2,4属于第一类,分组3,5属于第二类,当1到达时,链路空闲,直接传输,当2,3到达时,虽然2先到达,但2属于第一类,链路调度器对第二类的分组进行查找,3属于第二类,对3进行传输,链路调度器对第一类的分组进行查找,2属于第一类,对2进行传输

### 网际协议(IP)

#### IPv4数据报格式

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ipv4_packet.png)

- 版本号(version)

    这4个比特规定了数据报的IP协议版本,通过版本号,路由器能够确定如何解释IP数据报的剩余部分

- 首部长度(IHL)

    一个IPv4数据报可包含可变数量的选项(Options),选项包括在IPv4数据报首部中,故需要用这4比特来确定IP数据报中有效载荷(Data)实际开始的地方,首部长度说明首部有多少32位字(4字节),这个字段的最小值是5(二进制0101),相当于5\*4=20字节,最大十进制值是15,相当于15*4=60字节,大多数IP数据报不包含此项,因此一般的首部长度为**20字节**

- 服务类型(TOS)

    服务类型包含在IPv4首部中,用于区分不同类型的IP数据报(例如,对实时数据报和非实时流量进行区分)

- 数据报长度(Total length)

    IP数据报的总长度,该字段长度为16比特,IP数据报的理论最大长度为65535字节,但IP数据报的长度受到以太网帧承载能力的限制(不超过1500字节)

- 标识(Identification),标志(Flags),片位移(Frgment offset)

    与IP分片有关

    **标识**:一个计数器,用来产生IP数据报的标识

    **标志**:占3位,目前只有前两位有意义,标志字段的最低位是MF(More Fragment),`MF=1`表示后面还有分片,`MF=0`表示最后一个分片,标志字段中间的一位是DF(Don't Fragment),只有当`DF=0`时才允许分片

    **片偏移**:占13位,标识较长的分组在分片后某片在原分组中的相对位置,片偏移以**8个字节**为偏移单位

    ![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP_data_divide1.png)

    ![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP_data_divide2.png)

    ![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP_data_divide3.png)

- 存活时间(TTL)

    TTL字段用来确保数据报不会永远在网络中循环,每当一台路由器处理数据报时,该字段的值减少1,若TTL为0,则丢弃该数据报

- 协议(Protocol)

    该字段值指示了IP数据报的数据部分应交给哪个特定的传输层协议(6为交给TCP,17为交给UDP)

- 首部校验和(Header checksum)

    用于帮助路由器检测收到的IP数据报中的比特错误,只对首部查错,不包括数据部分

    假设某个IPv4数据包报头为:`E3 4F 23 96 44 27 99 F3 [00 00]`,用中括号括起来的就是checksum

    checksum的初始值自动被设置为0

    然后,以16bit为单位,两两相加,对于该例子,即为:`E34F + 2396 + 4427 + 99F3 = 1E4FF`
    
    若计算结果大于`0xFFFF`,则将高16位加到低16位上,对于该例子,即为`0xE4FF + 0x0001 = E500`
    
    然后,将该值取反,即为`~(E500)=1AFF`

    此时,发送包已经计算完毕,下面,我们再来计算接收方的信息

    若数据包正常,那么,它的报头应该是这样:`E3 4F 23 96 44 27 99 F3 1A FF`

    此时,前18bytes的内容不变,等于E500,然后,将`E500`与刚刚计算的校验和`1AFF`相加

    若计算结果为`FFFF`,那么,该数据包正常,没有错误

- 源IP(Source address)和目的IP(Destination address)

    字面意思

- 选项(Options)

    选项字段允许IP首部被拓展

- 数据(Data)(即有效载荷)

    IP数据报的数据字段包含要交付给目的地的原属曾报文段,该数据字段也可以承载其他类型的数据

#### IPv4编址

IPv4地址就是给互联网上的每一台主机(或路由器)的每一个**接口**分配一个在全世界范围内是唯一的32位的标识符

每个IPv4地址的长度为**32比特**,因此共有**2^32**个IPv4地址

IPv4地址的书写常采用**点分十进制记法**

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/dotted_decimal_notation.jpg)

IP地址的编址方法共经过了三个历史阶段

- 分类IP地址

- 划分子网

- 构成超网

##### 分类IP地址

>将IP地址划分为若干个固定类,每一类地址都由两个固定长度的字段组成,其中第一个字段是网络号(net-id),它标志主机(或路由器)所连接到的网络,一个网络号在整个互联网范围内必须是唯一的
>
>第二个字段是主机号(host-id),它标志该主机(或路由器),一台主机号在它前面的网络号所指明的网络范围内必须是唯一的,因此,一个IP地址在整个互联网范围内是唯一的

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/net&host_ip.jpg)

>A类地址的网络号字段占1个字节,只有7位可供使用(该字段的第一位已固定为0),可指派的网络号是126个,减2的原因是:第一,IP地址中的全0代表当前设备的IP,可以代表本机的所有IP地址;第二,网络号为127(即01111111)保留作为本地软件环回测试,用于本机中各个应用之间的网络交互
>
>A类地址的主机号占3个字节,因此每一个A类网络中的最大主机数是2^24–2,即16777214,减2的原因是:全0的主机号字段表示该IP地址是本机所连接到的单个网络地址(一主机的IP地址为5.6.7.8,则该主机所在的网络地址就是5.0.0.0),而全1的主机号字段表示该网络上的所有主机(A类地址1.1.255.255表示在网络1.1.0.0上的所有主机,而地址0.0.0.35则表示在这个网络上主机号为35的主机),整个A类地址空间共有2^31个地址
>
>B类地址的网络号字段占2个字节,但前面两位(10)已经固定了,只剩下14位可以进行分配,但B类地址128.0.0.0不进行指派,可以指派的B类最小网络地址是128.1.0.0,因此B类地址可指派的网络数为2^14−1,即16383,B类地址的每一个网络上的最大主机数是2^16–2,即65534
>
>C类地址有3个字节的网络号字段,最前面的3位是(110),还有21位可以进行分配,但C类网络地址192.0.0.0不进行指派,可以指派的C类最小网络地址是192.0.1.0,因此C类地址可指派的网络总数是2^21−1,即2097151,每一个C类地址的最大主机数是2^8–2,即254

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/range_ip.jpg)

!>一般不使用的特殊的IP地址

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/special_ip.png)

!>IP地址与MAC地址

1. IP地址与MAC地址是不同的地址

2. MAC地址是数据链路层和物理层使用的地址

3. IP地址是网络层和以上各层使用的地址,是一种逻辑地址(IP地址通过软件实现)

##### 划分子网

在IP地址中增加了一个**子网号字段**,使两级的IP地址变成为三级的IP地址,从主机号借用若干个位作为子网号,而主机号也相应减少了若干个位

1. 根据IP数据报的目的网络号,先找到连接在该网络上的路由器

2. 此路由器在收到IP数据报后,再按目的网络号和子网号找到目的子网

3. 最后将IP数据报交付目的主机

##### 子网掩码

从一个IP数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分,使用子网掩码可以找出IP地址中的子网部分

子网掩码长度为32位,左边部分为**一连串1**,对应于网络号和子网号,右边部分的**一连串0**,对应于主机号

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/subnetmask.jpg)

把IP地址的子网掩码和收到的数据报的目的IP地址进行逐位与(and),得到子网的网络地址

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ABC_subnetmask.jpg)

!>B类地址的子网划分选择(使用固定长度子网)

|子网号的位数|子网掩码|子网数(2^位数-2,因为要剔除全0和全1)|每个子网的主机数(2^剩余位数-2,因为要剔除网络地址和广播地址)|
|:---:|:---:|:---:|:---:|
|2|255.255.192.0|2|16382|
|3|255.255.224.0|6|8190|
|4|255.255.240.0|14|4094|
|5|255.255.248.0|30|2046|
|6|255.255.252.0|62|1022|
|7|255.255.254.0|126|510|
|8|255.255.255.0|254|254|
|9|255.255.255.128|510|126|
|10|255.255.255.192|1022|62|
|11|255.255.255.224|2046|30|
|12|255.255.255.240|4094|14|
|13|255.255.255.248|8190|6|
|14|255.255.255.252|16382|2|

!>子网号的位数中没有0,1,15和16这四种情况

>当子网号的位数为0,则说明不进行子网划分
>
>当子网号的位数为1,当子网号为0时,会产生子网的网络地址与父网络的网络地址相同的情况(例如,IP地址为`172.16.1.1`,子网掩码为`255.255.128.0`,子网地址为`172.16.0.0`,网络地址为`172.16.0.0`,因此造成冲突)
>
>当子网号的位数为1,当子网号为1时,会产生子网的广播地址与父网络的广播地址相同的情况(例如,IP地址为`172.16.128.1`,子网掩码为`255.255.128.0`,子网的广播地址为`172.16.255.255`,父网络的广播地址也为`172.16.255.255`,因此造成冲突)
>
>当子网号的位数为15,相当于主机号剩余一位,当取值为0时,实际为该子网的网络地址,取值为1时实际为该子网的广播地址
>
>当子网号的位数为16,则说明没有主机号

##### VLSM(可变长子网掩码)

VLSM是可变长子网掩码,通过向主机位借位的方式,实现地址的精确编址以及提高网络的灵活性与可用性,随着掩码的变长,一大块IP被不断分割成越来越小的地址块

>假设某公司财务部需要100台主机,市场部需要60台主机,项目部需求10台主机,有一个`192.168.1.0/24`的网段,对其进行划分
>
>对于财务部,100<=2^x-2,x_min=7,因此将网段划分为`192.168.1.0/25`和`192.168.1.128/25`,财务部使用`192.168.1.0/25`
>
>对于市场部,60<=2^x-2,x_min=6,因此将`192.168.1.128/25`划分为`192.168.1.128/26`和`192.168.1.192/26`,市场部使用`192.168.1.128/26`
>
>对于项目部,10<=2^x-2,x_min=4,因此将`192.168.1.192/26`划分为`192.168.1.192/28`,`192.168.1.208/28`,`192.168.1.224/28`和`192.168.1.240/28`,项目部使用`192.168.1.192/28`

##### CIDR(无类别域间路由)

CIDR是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法

CIDR消除了传统的A类,B类和C类地址以及划分子网的概念,使用各种长度的网络前缀来代替分类地址中的网络号和子网号,IP地址从三级编址又回到了两级编址

CIDR使用斜线记法,在IP地址后面加上斜线`/`,然后写上网络前缀所占的位数

CIDR把网络前缀都相同的连续的IP地址组成一个**CIDR地址块**,只要知道CIDR地址块中的任何一个地址,就可以知道这个地址块的起始地址和最大地址,以及地址块中的地址数

>已知IP地址`128.14.35.7/20`是某CIDR地址块中的一个地址
>
>`128.14.35.7/20`=**10000000 00001110 0010**0011 00000111
>
>最小地址:`128.14.32.0`即`10000000 00001110 0010 0000 00000000`
>
>最大地址:`128.14.47.255`即`10000000 00001110 0010 1111 11111111`

!>前缀路由聚合

四个网段:`192.168.0.0/24`,`192.168.1.0/24`,`192.168.3.0/24`,`192.168.4.0/24`

>11000000.10101000.00000000.0 - 192.168.0.0
>
>11000000.10101000.00000001.0 - 192.168.1.0
>
>11000000.10101000.00000010.0 - 192.168.2.0
>
>11000000.10101000.00000011.0 - 192.168.3.0

四个网段的前22位二进制相同,进行前缀聚合后,这四个网段对外显示为`192.168.0.0/22`

!>最长前缀匹配

假设在路由器上有两个网段`192.168.1.0/24`和`192.168.0.0/22`,若收到一个数据报,目的IP为`192.168.1.128`,在查找路由表时得到两个匹配结果,此时应当从匹配结果中选择具有最长网络前缀的路由

`192.168.1.128`与`11111111 11111111 11111111 00000000`逐位与,得到`192.168.1.0/24`

`192.168.1.128`与`11111111 11111111 11111100 00000000`逐位与,得到`192.168.0.0/22`

根据最长前缀匹配的原理,应当选择`192.168.1.0/24`,把收到的数据报转发到此网络中

##### 专用IP

- 10.0.0.0/8 : 10.0.0.0 - 10.255.255.255

- 172.16.0.0/12 : 172.16.0.0 - 172.31.255.255

- 192.168.0.0/16 : 192.168.0.0 - 192.168.255.255

#### NAT(网络地址转换)

用于在本地网络中使用私有地址,在连接互联网时转而使用全局IP地址的技术

##### 基本网络地址转换(Basic NAT)

!>仅支持地址转换,不支持端口映射

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/nat.jpg)

NAT路由器收到从专用网内部的主机A发往互联网上主机B的IP数据报:源IP地址是`192.168.0.3`,而目的IP地址是`213.18.2.4`

NAT路由器把IP数据报的源IP地址`192.168.0.3`,转换为新的源IP地址(即NAT路由器的全球IP地址)`172.38.1.5`,然后转发出去

因此,主机B收到这个IP数据报时,以为A的IP地址是172.38.1.5

当B给A发送应答时,IP数据报的目的IP地址是NAT路由器的IP地址`172.38.1.5`

B并不知道A的专用地址`192.168.0.3`,实际上,即使知道了,也不能使用,因为互联网上的路由器都不转发目的地址是专用网本地IP地址的IP数据报

当NAT路由器收到互联网上的主机B发来的IP数据报时,还要进行一次IP地址的转换

通过NAT地址转换表,就可把IP数据报上的旧的目的IP地址`172.38.1.5`,转换为新的目的IP地址`192.168.0.3`(主机A真正的本地IP地址)

!>由于改变了IP源地址,在重新封装数据包时候必须重新计算校验和,网络层以上的只要涉及到IP地址的头部校验和都要重新计算

无端口号NAT地址转换表

|方向|字段|旧的IP地址|新的IP地址|
|:---:|:---:|:---:|:---:|
|出|源IP地址|192.168.0.3|172.38.1.5|
|入|目的IP地址|172.38.1.5|192.168.0.3|
|出|源IP地址|192.168.0.7|172.38.1.6|
|入|目的IP地址|172.38.1.6|192.168.0.7|

##### 网络地址端口转换(NAPT)

!>支持端口的映射,并允许多台主机共享一个公网IP地址

NAPT维护一个带有IP以及端口号的NAT表

|内网IP|外网IP|
|:---:|:---:|
|192.168.1.55:5566|219.152.168.222:9200|
|192.168.1.59:80|219.152.168.222:9201|
|192.168.1.59:4465|219.152.168.222:9202|

#### IPv6数据报格式

IPv6所引进的主要变化如下:

- 更大的地址空间:IPv6把地址从IPv4的32位增大到4倍,即增大到128位
  
- 扩展的地址层次结构:IPv6由于地址空间很大,因此可以划分为更多的层次

- 灵活的首部格式:IPv6数据报的首部和IPv4的并不兼容,IPv6定义了许多可选的扩展首部,不仅可提供比IPv4更多的功能,而且还可提高路由器的处理效率

- 改进的选项:IPv6允许数据报包含有选项的控制信息,因而可以包含一些新的选项,但IPv6的首部长度是固定的,其选项放在有效载荷中

- 允许协议继续扩充

- 支持即插即用(即自动配置),因此IPv6不需要使用DHCP

- 支持资源的预分配:IPv6支持实时视像等要求保证一定的带宽和时延的应用

- IPv6首部改为8字节对齐(即首部长度必须是8字节的整数倍),原来的IPv4首部是4字节对齐

IPv6数据报由两大部分组成,即基本首部(base header)和后面的有效载荷(payload)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ipv6.jpg)

- 版本(version):占4位,它指明了协议的版本,对IPv6该字段是6

- 通信量类(traffic class):占8位,这是为了区分不同的IPv6数据报的类别或优先级,目前正在进行不同的通信量类性能的实验,

- 流标号(flow label):占20位,用于QoS服务质量控制

- 有效载荷长度(payload length):占16位,指明IPv6数据报除基本首部以外的字节数(所有扩展首部都算在有效载荷之内),这个字段的最大值是64KB(65535字节)

- 下一个首部(next header):占8位,相当于IPv4的协议字段或可选字段
	- 当没有扩展首部时,下一个首部字段的作用和IPv4的协议字段一样,它的值指出了基本首部后面的数据应交付IP层上面的哪一个高层协议(例如:6或17分别表示应交付传输层TCP或UDP)
	- 当出现扩展首部时,下一个首部字段的值就标识后面第一个扩展首部的类型

- 跳数限制(hop limit):占8位,用来防止数据报在网络中无限期地存在,源点在每个数据报发出时即设定某个跳数限制(最大为255跳),每个路由器在转发数据报时,要先把跳数限制字段中的值减1,当跳数限制的值为零时,就要把这个数据报丢弃(相当于IPv4中的TTL)

#### IPv6编址

IPv6二进位制下为`128`位长度,以`16`位为一组,每组以冒号`:`隔开,可以分为8组,每组以4位十六进制方式表示,例如`2001:0db8:86a3:08d3:1319:8a2e:0370:7344`是一个合法的IPv6地址

类似于IPv4的点分十进制,同样也存在点分十六进制的写法,将8组4位十六进制地址的冒号去除后,每位以点号`.`分组,例如`2001:0db8:85a3:08d3:1319:8a2e:0370:7344`则记为`2.0.0.1.0.d.b.8.8.5.a.3.0.8.d.3.1.3.1.9.8.a.2.e.0.3.7.0.7.3.4.4`

同时IPv6在某些条件下可以省略:

- 每项数字前导的0可以省略,省略后前导数字仍是0则继续,例如下组IPv6是等价的

`2001:0DB8:02de:0000:0000:0000:0000:0e13`

`2001:DB8:2de:0000:0000:0000:0000:e13`

`2001:DB8:2de:000:000:000:000:e13`

`2001:DB8:2de:00:00:00:00:e13`

`2001:DB8:2de:0:0:0:0:e13`

- 可以用双冒号`::`表示一组0或多组连续的0,但只能出现一次:
    - 如果四组数字都是零,可以被省略,遵照以上省略规则,下面这两组IPv6都是相等的

    1. `2001:DB8:2de:0:0:0:0:e13`

        `2001:DB8:2de::e13`

    2. `2001:0DB8:0000:0000:0000:0000:1428:57ab`

        `2001:0DB8:0000:0000:0000::1428:57ab`

        `2001:0DB8:0:0:0:0:1428:57ab`

        `2001:0DB8:0::0:1428:57ab`

        `2001:0DB8::1428:57ab`

`2001::25de::cade`是非法的,因为双冒号出现了两次,它有可能是下种情形之一,造成无法推断

`2001:0000:0000:0000:0000:25de:0000:cade`

`2001:0000:0000:0000:25de:0000:0000:cade`

`2001:0000:0000:25de:0000:0000:0000:cade`

`2001:0000:25de:0000:0000:0000:0000:cade`

如果这个地址实际上是IPv4的地址,后32位可以用10进制数表示,因此`::ffff:192.168.89.9`等于`::ffff:c0a8:5909`

另外,`::ffff:1.2.3.4`格式叫做IPv4映射地址

IPv4位址可以很容易的转化为IPv6格式,如果IPv4的一个地址为`135.75.43.52`(十六进制为`0x874B2B34`),它可以被转化为`0000:0000:0000:0000:0000:FFFF:874B:2B34`或者`::FFFF:874B:2B34`

同时,还可以使用混合符号(IPv4-compatible address),则地址可以为`::ffff:135.75.43.52`

##### IPv6地址的分类

IPv6地址可分为三种:

- 单播(unicast)地址

    单播地址标示一个网络接口,协议会把送往地址的数据包送往给其接口,IPv6的单播地址可以有一个代表特殊地址名字的范畴,如链路本地地址(link local address)和唯一区域地址(ULA,unique local address),单播地址包括可聚类的全球单播地址,链路本地地址等

- 任播(anycast)地址

    Anycast会有一组接收节点的地址列表,但指定为Anycast的数据包,只会发送给距离最近或发送成本最低(根据路由表来判断)的其中一个接收地址,当该接收地址收到数据包并进行回应,且加入后续的传输,该接收列表的其他节点,会知道某个节点地址已经回应了,它们就不再加入后续的传输作业

- 多播(multicast)地址

    多播地址也称组播地址,多播地址也被指定到一群不同的接口,送到多播地址的数据包会被发送到所有的地址,多播地址由皆为一的字节起始,即它们的前置为`FF00::/8`,其第二个字节的最后四个比特用以标明"范畴"

## 网络层-控制平面

### 路由选择算法

通过`图`来描述路由选择问题,`G=(N,E)`,表示一个具有`N`个节点(顶点数量)和`E`条边(弧数量)的集合,其中每一条边取自N的一对节点

一条边具有一个用于表示其开销的值(权重),对于`E`中的任一条边,使用`c(x,y)`表示节点`x`和节点`y`间边的开销,如果节点对`(x,y)`不属于`E`,则`c(x,y)=∞`

显然,当图为无向图时,边`(x,y)`与边`(y,x)`相同且`c(x,y)=c(y,x)`,当图为有向图时,边在不同的方向可能具有不同的开销

路由选择算法的目标是找出从源到目的地间的最低开销路径

#### 链路状态路由选择算法

?>Dijkstar算法

记号定义:

- `D(v)`:到本次迭代时,从源节点到目的节点`v`的最短路径开销

- `p(v)`:从源节点到v节点沿着当前最短路径的前一节点

- `N'`:节点子集,记录已经确定最短路径的节点

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/route_graph.png)

使用上图中的网络,从`u`开始计算到各个目的节点的最短路径开销

|步骤|`N'`|`D(v)`,`p(v)`|`D(w)`,`p(w)`|`D(x)`,`p(x)`|`D(y)`,`p(y)`|`D(z)`,`p(z)`|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|u|2,u|5,u|1,u|∞|∞|
|1|ux|2,u|4,x||2,x|∞|
|2|uxy|2,u|3,y|||4,y|
|3|uxyv||3,y|||4,y|
|4|uxyvw|||||4,y|
|5|uxyvwz||||||

#### 距离向量路由选择算法

每个路由器只知道和自己相邻的路由器的存在,以及和相邻路由器间的链路的成本信息

Bellman-Ford等式(动态规划的思想)

用`d_𝑥 (𝑦)`表示"从x到y的最佳路径的成本",则有`d_𝑥 (𝑦)=min┬𝑣⁡{𝑐(𝑥,𝑣)+d_𝑣 (𝑦)}`("x到v的成本"+"从v到y的最佳路径的成本")

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Bellman_Ford_Sample.png)

`d_v(z)=5`,`d_x(z)=3`,`d_w(z)=3`

`c(u,v)=2`,`c(u,x)=1`,`c(u,w)=5`

根据BF方程得到`d_u(z)={2+5,3+1,3+5}=4`,与Dijkstra算法得出的结果相同

使用DV算法时,每个节点`x`维护下列路由选择信息

- 对于每个邻居`v`,从`x`到直接相连邻居`v`的开销为`c(x,v)`

- 节点`x`的路由向量,包含`x`到所有目的地的开销估计值

- 每个邻居的距离向量

每个节点不时地向每个邻居发送其距离向量副本,当节点`x`从它的任意一个邻居`w`接收到一个新的距离向量时,将该向量保存,并利用BF方程对距离向量进行更新

如果距离向量发生了变化,则节点`x`向它的每个邻居发送新的距离向量,继而让邻居更新它们自己的距离向量

只要所有节点继续交换距离向量,每个开销估计`Dx(y)`收敛到`dx(y)`(`x`到`y`的实际最低开销路径的开销)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Bellman_Ford_Table.png)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/good_news_travels_fast.png)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/bad_news_travels_slow.png)

利用`毒性逆转`来避免路由环路:如果`z→y→x`,则z向y通告`𝐷_𝑧 (𝑥)=∞`(即使z知道𝐷_𝑧 (𝑥)是某个数值),这样可以防止y重新经过z到达x,但是有一些路由环路的产生是无法通过毒性逆转来避免的

### 路由选择协议

#### 内部网关协议

##### 路由信息协议

`RIP (Routing Information Protocol)`

RIP是一种分布式的**基于距离向量**的路由选择协议

RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录(这是一组距离,即"距离向量",这里的"距离"实际上指的是"最短距离")

RIP协议将"距离"定义如下:

从一路由器到**直接连接**的网络的距离定义为`1`

从一路由器到**非直接连接**的网络的距离定义为所经过的路由器数加`1`

RIP协议中的"距离"也称为"跳数",因为每经过一个路由器,跳数加`1`

RIP认为好的路由就是它通过的路由器的数目少,RIP允许**一条路径**最多只能包含`15`个路由器,因此距离等于16时即相当于不可达,因此RIP只适用于小型互联网

RIP协议的特点是:

- 仅和相邻路由器交换信息,如果两个路由器之间的通信不需要经过另一个路由器,那么这两个路由器就是相邻的,RIP协议规定,不相邻的路由器不交换信息
- 路由器交换的信息是当前本路由器所知道的全部信息,即自己现在的路由表
- 按固定的时间间隔交换路由信息

RIP协议使用的距离向量算法

对每一个相邻路由器发送过来的RIP报文,进行以下步骤:

- 对地址为`X`的相邻路由器发来的RIP报文,先修改此报文中的所有项目:把"下一跳"字段中的地址都改为`X`,并把所有的"距离"字段的值加`1`(这样做是为了便于进行本路由表的更新,假设从位于地址X的相邻路由器发来的RIP报文的某一个项目是:`Net2,3,Y`,意思是"我经过路由器Y到网络Net2的距离是3",那么本路由器就可推断出:"我经过X到网络Net2的距离应为`3+1=4`"于是,本路由器就把收到的RIP报文的这一个项目修改为`Net2,4,X`,作为下一步和路由表中原有项目进行比较时使用(只有比较后才能知道是否需要更新)收到的项目中的Y对本路由器是没有用的,因为Y不是本路由器的下一跳路由器地址),每一个项目都有三个关键数据,即:到目的网络`N`,距离`d`,下一跳路由器`X`

- 对修改后的RIP报文中的每一个项目,进行以下步骤:

    if原来的路由表中没有目的网络`N`,则把该项目添加到路由表中(表明这是新的目的网络,应当加入到路由表中,假设本路由表中没有到目的网络`Net2`的路由,那么在路由表中就要加入新的项目`Net2,4,X`)
    
    else(即在路由表中有目的网络`N`,这时就再查看下一跳路由器地址)
        
    if下一跳路由器地址是`X`,则把收到的项目替换原路由表中的项目(以最新的消息为准,到目的网络的距离有可能增大或减小,但也可能没有改变,不管原来路由表中的项目是`Net2,3,X`还是`Net2,5,X`,都要更新为现在的`Net2,4,X`)
    
    else(即这个项目是:到目的网络`N`,但下一跳路由器不是`X`)
            
    if收到的项目中的距离`d`小于路由表中的距离,则进行更新(若路由表中已有项目`Net2,5,P`,就要更新为`Net2,4,X`缩短距离)
    
    else什么也不做

- 若一定的时间间隔后还没有收到相邻路由器的更新路由表,则把此相邻路由器记为不可达的路由器,即把距离置为`16`

- 返回

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RIP1.png)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RIP2.png)

RIP2报文由首部和路由部分组成

RIP2报文中的路由部分由若干个路由信息组成,每个路由信息需要用`20`个字节,地址族标识符(又称为地址类别)字段用来标志所使用的地址协议

一个RIP报文最多可包括`25`个路由,因而RIP报文的最大长度是`4+20x25=504`字节,如超过则必须再用一个RIP报文来传送

RIP协议的优缺点

- 优点:

    实现简单,开销较小

- 缺点:

    RIP限制了网络的规模,它能使用的最大距离为15(16表示不可达)

    路由器之间交换的路由信息是路由器中的完整路由表,因而随着网络规模的扩大,开销也就增加

    "坏消息传播得慢",使更新过程的收敛时间过长

##### 开放最短路径优先

`OSPF (Open Shortest Path First)`

采用分布式的链路状态协议

OSPF协议的特点是:

- 向本自治系统中所有路由器发送信息,这里使用的方法是洪泛法(路由器通过所有输出端口向所有相邻的路由器发送信息,而每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器))
- 发送的信息就是与本路由器相邻的所有路由器的链路状态,但这只是路由器所知道的部分信息,"链路状态"说明本路由器都和哪些路由器相邻,以及该链路的"度量"("度量"可用来表示费用,距离,时延,带宽等)
- 只有当链路状态发生变化时,路由器才用洪泛法向所有路由器发送此信息 

由于各路由器之间频繁地交换链路状态信息,因此所有的路由器最终都能建立一个**链路状态数据库**(link-state database),这个数据库实际上就是全网的拓扑结构图,这个拓扑结构图在全网范围内是一致的

为了使OSPF能够用于规模很大的网络,OSPF将一个自治系统再划分为若干个更小的范围,叫做**区域**

每一个区域都有一个`32`位的区域标识符

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF_Sample.png)

OSPF使用层次结构的区域划分,在上层的区域叫做主干区域,主干区域的标识符规定为`0.0.0.0`,主干区域的作用是用来连通其他在下层的区域

OSPF**不用UDP**而是直接用**IP数据报**传送

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF_Head.png)

OSPF分组使用`24`字节的**固定长度首部**

- 类型1,问候(Hello)分组
- 类型2,数据库描述(Database Description)分组
- 类型3,链路状态请求(Link State Request)分组
- 类型4,链路状态更新(Link State Update)分组,用洪泛法对全网更新链路状态
- 类型5,链路状态确认(Link State Acknowledgment)分组

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RIPvsOSPF.png)

#### 外部网关协议

边界网关协议`BGP`是不同自治系统的路由器之间交换路由信息的协议

BGP只能是力求寻找一条能够到达目的网络且比较好的路由(不能兜圈子),而并非要寻找一条最佳路由,BGP采用了路径向量路由选择协议

在配置BGP时,每一个自治系统的管理员要选择至少一个路由器作为该自治系统的"BGP发言人"

一个BGP发言人与其他AS的BGP发言人要交换路由信息,就要先建立TCP连接(端口号为179),然后在此连接上交换BGP报文以建立BGP会话(session),利用BGP会话交换路由信息,如增加了新的路由,或撤销过时的路由,以及报告出差错的情况等等,使用TCP连接交换路由信息的两个BGP发言人,彼此成为对方的邻站(neighbor)或对等站(peer)

一个BGP发言人除了必须运行BGP协议外,还必须运行该自治系统所使用的内部网关协议

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BGP_speaker.png)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BGPswap1.png)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BGPswap2.png)

### ICMP协议

网际控制报文协议ICMP(Internet Control Message Protocol)

ICMP不是高层协议(ICMP报文是装在IP数据报中,作为其中的数据部分),而是IP层的协议,ICMP报文作为IP层数据报的数据,加上数据报的首部,组成IP数据报发送出去

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMPform.png)

ICMP报文的种类有两种,即ICMP**差错报告**报文和ICMP**询问**报文

|ICMP报文种类|类型的值|ICMP报文的类型|
|:---:|:---:|:---:|
|差错报告报文|3|终点不可达|
||11|时间超过|
||12|参数问题|
||5|改变路由|
|询问报文|8或0|回送请求或回答|
||13或14|时间戳请求或回答|

- 终点不可达:当路由器或主机不能交付数据报时就向源点发送终点不可达报文
- 时间超过:当路由器收到生存时间为零的数据报时,除丢弃该数据报外,还要向源点发送时间超过报文,当终点在预先规定的时间内不能收到一个数据报的全部数据报片时,就把已收到的数据报片都丢弃,并向源点发送时间超过报文
- 参数问题:当路由器或目的主机收到的数据报的首部中有的字段的值不正确时,就丢弃该数据报,并向源点发送参数问题报文
- 改变路由(重定向):路由器把改变路由报文发送给主机,让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMPerror.png)

- 对ICMP差错报告报文不再发送ICMP差错报告报文
- 对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文
- 对具有多播地址的数据报都不发送ICMP差错报告报文
- 对具有特殊地址(如`127.0.0.0`或`0.0.0.0`)的数据报不发送ICMP差错报告报文

## 传输层

传输层协议为运行在不同主机上的应用进程之间提供了**逻辑通信**功能

传输层协议在端系统中实现,而非在路由器中,传输分组称为传输层报文段

网络层为主机之间提供逻辑通信,而传输层为应用进程之间提供端到端的逻辑通信

传输层还要对收到的报文进行**差错检测**,在网络层,IP数据报首部中的检验和字段,只检验首部是否出现差错而不检查数据部分

传输层的两个主要协议**用户数据报协议UDP**(User Datagram Protocol)和**传输控制协议TCP**(Transmission Control Protocol)

传输层有一个很重要的功能:复用和分用

复用是指在发送方不同的应用进程都可以使用同一个传输层协议传送数据

分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付目的应用进程

分用和复用的前提是给应用层的每个应用进程赋予一个非常明确的标志,因此在运输层使用**协议端口号**,简称为**端口**

虽然通信的终点是应用进程,但只要把所传送的报文交到目的主机的某个合适的目的端口,剩下的工作(即最后交付目的进程)就由TCP或UDP来完成

在协议栈层间的抽象的协议端口是**软件端口**,在路由器或交换机上的端口为**硬件端口**,硬件端口是不同硬件设备进行交互的接口,而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址

### 端口

运输层用一个`16`位端口号来标志一个端口,端口号只具有本地意义,只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口,16位的端口号可允许有`65535`个不同的端口号

运输层的端口号分为两大类

- 服务器端使用的端口号

    - 熟知端口号 (0~1023)
    |应用程序|端口|
    |:---:|:---:|
    |FTP|21|
    |TELNET|23|
    |SMTP|25|
    |DNS|53|
    |TFTP|69|
    |HTTP|80|
    |SNMP|161|
    |HTTPS|443|

    - 登记端口号 (1024~49151)

- 客户端使用的端口号

    - 短暂端口号 (49152~65535)

    这类端口号仅在客户进程运行时才动态选择

### 用户数据报协议UDP

#### 特点

- UDP是**无连接**的,即发送数据之前不需要建立连接,因此减少了开销和发送数据之前的时延
- UDP使用**尽最大努力**交付,即不保证可靠交付,因此主机不需要维持复杂的连接状态表
- UDP是**面向报文**的,发送方的UDP对应用程序交下来的报文,在添加首部后就向下交付IP层,UDP对应用层交下来的报文,既不合并,也不拆分,而是保留这些报文的边界,也就是说,应用层交给UDP多长的报文,UDP就照样发送,即一次发送一个报文
- UDP**没有拥塞控制**,因此网络出现的拥塞不会使源主机的发送速率降低(适合对实时性有要求的应用)
- UDP支持**一对一,一对多,多对一和多对多**的交互通信
- UDP的**首部开销小**,只有8个字节

#### UDP报文段结构

<table style="margin: 0 auto; text-align: center;">
<caption>UDP首部</caption>
<tbody>
<tr>
<th style="border-bottom:none; border-right:none;"><span style="font-family:sans-serif;font-size:100%;color:grey;background-color:transparent;;">偏移</span></th>
<th style="border-left:none;">字节</th>
<th colspan="8">0</th>
<th colspan="8">1</th>
<th colspan="8">2</th>
<th colspan="8">3</th>
</tr>
<tr>
<th style="border-top: none">字节</th>
<th>位</th>
<th>&#160;0</th>
<th>&#160;1</th>
<th>&#160;2</th>
<th>&#160;3</th>
<th>&#160;4</th>
<th>&#160;5</th>
<th>&#160;6</th>
<th>&#160;7</th>
<th>&#160;8</th>
<th>&#160;9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
<th>21</th>
<th>22</th>
<th>23</th>
<th>24</th>
<th>25</th>
<th>26</th>
<th>27</th>
<th>28</th>
<th>29</th>
<th>30</th>
<th>31</th></tr>
<tr>
<th>0</th>
<th>0</th>
<td colspan="16">源端口号</td>
<td colspan="16">目的端口号</td>
</tr>
<tr>
<th>4</th>
<th>32</th>
<td colspan="16">报文长度</td>
<td colspan="16">校验和</td>
</tr>
</tbody>
</table>

UDP首部共有4个字段,每个字段由两个字节组成

- 报文长度
    
    该字段指定UDP报头和数据总共占用的长度

    可能的最小长度是8字节,因为UDP报头已经占用了8字节,由于这个字段的存在,UDP报文总长不可能超过65535字节(包括8字节的报头,和65527字节的数据),实际上通过IPv4协议传输时,由于IPv4的头部信息要占用20字节,因此数据长度不可能超过`65507`字节(65535−8字节UDP首部−20字节IP头部)

- 校验和
    
    校验和字段可以用于发现头部信息和数据中的传输错误

#### UDP校验和计算

当UDP运行在IPv4之上时,为了能够计算校验和,需要在UDP数据包前添加一个"伪首部",伪首部包括了IPv4头部中的一些信息,但它并不是发送IP数据包时使用的IP数据包的头部,而只是一个用来计算校验和而已

<table style="margin: 0 auto; text-align: center;">
<tbody><tr style="text-align:center;">
<th><span style="font-family:sans-serif;font-size:100%;color:grey;background-color:transparent;;">位</span>
</th>
<th colspan="8" style="width:75px;">0 – 7
</th>
<th colspan="8" style="width:75px;">8 – 15
</th>
<th colspan="8" style="width:75px;">16 – 23
</th>
<th colspan="8" style="width:75px;">24 – 31
</th></tr>
<tr style="text-align:center;">
<th>0
</th>
<td colspan="32" style="background:#fdd;">源地址
</td></tr>
<tr style="text-align:center;">
<th>32
</th>
<td colspan="32" style="background:#fdd;">目的地址
</td></tr>
<tr style="text-align:center;">
<th>64
</th>
<td colspan="8" style="background:#fdd;">全零
</td>
<td colspan="8" style="background:#fdd;">协议类型(UDP(17)->0x11)
</td>
<td colspan="16" style="background:#fdd;">UDP报文长度
</td></tr>
<tr style="text-align:center;">
<th>96
</th>
<td colspan="16">来源连接端口
</td>
<td colspan="16">目的连接端口
</td></tr>
<tr style="text-align:center;">
<th>128
</th>
<td colspan="16">报文长度
</td>
<td colspan="16">检验和
</td></tr>
<tr style="text-align:center;">
<th>160+
</th>
<td colspan="32">&#160;<br />数据<br />&#160;
</td></tr></tbody></table>

UDP的检验和是把首部和数据部分一起都检验

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP_checksum.png)

### 传输控制协议TCP

- TCP是**面向连接**的运输层协议,应用程序在使用TCP协议之前,必须先建立TCP连接
- 每一条TCP连接只能有两个端点,每一条TCP连接只能是点对点的(**一对一**)
- TCP提供**可靠交付**的服务,通过TCP连接传送的数据,无差错,不丢失,不重复,并且按序到达
- TCP提供**全双工**通信,TCP允许通信双方的应用进程在任何时候都能发送数据
- **面向字节流**,TCP中的"流"指的是流入到进程或从进程流出的字节序列,"面向字节流"的含义是:虽然应用程序和TCP的交互是一次一个数据块(大小不等),但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流,TCP并不知道所传送的字节流的含义,TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系(例如,发送方应用程序交给发送方的TCP共10个数据块,但接收方的TCP可能只用了4个数据块就把收到的字节流交付上层的应用程序),但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样
- TCP连接是一条**虚连接**而不是一条真正的物理连接

!>TCP把连接作为最基本的抽象

每一条TCP连接有两个端点,TCP连接的端点叫做套接字或插口,端口号拼接到IP地址即构成了套接字,因此,套接字的表示方法是在点分十进制的IP地址后面写上端口号,中间用冒号或逗号隔开

例如,若IP地址是`192.3.4.5`而端口号是`80`,那么得到的套接字就是`192.3.4.5:80`

#### TCP首部

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCPheader.jpg)

!>默认长度为20字节

1. **源端口和目的端口**:各占2个字节,分别写入源端口号和目的端口号

2. **序号**:占4字节,序号范围是[0,$2^{32}$–1],共$2^{32}$个序号,序号增加到$2^{32}$–1后,下一个序号就又回到0
    
   TCP连接中传送的字节流中的每一个字节都按顺序编号,整个要传送的字节流的起始序号必须在连接建立时设置
   
   首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号
   
   例如,一报文段的序号字段值是`301`,而携带的数据共有`100`字节,这就表明:本报文段的数据的第一个字节的序号是`301`,最后一个字节的序号是`400`,显然,下一个报文段(如果还有的话)的数据序号应当从`401`开始,即下一个报文段的序号字段值应为`401`,这个字段的名称也叫做**报文段序号**

3. **确认号**:占4字节,是期望收到对方下一个报文段的第一个数据字节的序号

   例如,B正确收到了A发送过来的一个报文段,其序号字段值是`501`,而数据长度是`200`字节(序号501~700),这表明B正确收到了A发送的到序号`700`为止的数据
   
   因此,B期望收到A的下一个数据序号是`701`,于是B在发送给A的确认报文段中把确认号置为701
   
   !>请注意,现在的确认号不是`501`,也不是`700`,而是`701`

   若确认号=`N`,则表明:到序号`N–1`为止的所有数据都已正确收到

4. **数据偏移**:占`4bit`,它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远,以**4字节**为单位计算出的数据段开始地址的偏移值

   这个字段实际上是指出TCP报文段的首部长度,由于首部中还有长度不确定的选项字段,因此数据偏移字段是必要的

   由于4位二进制数能够表示的最大十进制数字是15,因此数据偏移的最大值是60字节,这也是TCP首部的最大长度(即选项长度不能超过40字节)

5. **保留**:占6位,保留为今后使用,但目前应置为0

6. **紧急**`URG`:当URG=1时,表明紧急指针字段有效

   它告诉系统此报文段中有紧急数据,应尽快传送,而不要按原来的排队顺序来传送,发送方TCP将紧急数据插入到本报文段数据的最前面,而在紧急数据后面的数据仍是普通数据

   这时要与首部中紧急指针字段配合使用

7. **确认**`ACK`:仅当ACK=1时确认号字段才有效,当ACK=0时,确认号无效,TCP规定,在连接建立后所有传送的报文段都必须把ACK置1

8. **推送**`PSH`:当PSH=1时表示是带有PUSH标志的数据,指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满

9. **复位**`RST`:当RST=1时,表明TCP连接中出现严重差错,必须释放连接,然后再重新建立运输连接,RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接

10. **同步**`SYN`:在连接建立时用来同步序号

    当SYN=1而ACK=0时,表明这是一个连接请求报文段,对方若同意建立连接,则应在响应的报文段中使SYN=1和ACK=1
    
    因此,SYN置为1就表示这是一个连接请求或连接接受报文

11. **终止**`FIN`:为1表示发送方没有数据要传输了,要求释放连接

12. **窗口**:占2字节(窗口值是[0,$2^16 -1$]之间的整数),表示从确认号开始,本报文的发送方可以接收的字节数,即接收窗口大小,用于流量控制

    例如,发送了一个报文段,其确认号是701,窗口字段是1000,说明,从701号算起,接收方的接收缓存空间还可接收1000个字节数据

13. **校验和**:占2字节,检验和字段检验的范围包括首部和数据这两部分,和UDP用户数据报一样,在计算检验和时,要在TCP报文段的前面加上12字节的伪首部,伪首部的格式与UDP用户数据报的伪首部一样,但应把伪首部第4个字段中的17改为6(TCP的协议号是6),把第5字段中的UDP长度改为TCP长度

14. **紧急指针**:占2字节,紧急指针仅在`URG=1`时才有意义,它指出本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据),即使窗口为零时也可发送紧急数据

#### 停止等待协议

>理想的传输条件有以下两个特点
>
>传输信道不产生差错
>
>不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据

**停止等待**就是每发送完一个分组就停止发送,等待对方的确认,在收到确认后再发送下一个分组

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP_停止等待协议1.jpg)

1. 无差错情况

A发送分组M1,发完就暂停发送,等待B的确认

B收到了M1就向A发送确认

A在收到了对M1的确认后,就再发送下一个分组M2

同样,在收到B对M2的确认后,再发送M3

2. 出现差错

B接收M1时检测出了差错,就丢弃M1,其他什么也不做(不通知A收到有差错的分组)或者M1在传输过程中丢失,B不会发送任何信息

?>可靠传输协议的设计思想

A只要超过了一段时间仍然没有收到确认,就认为刚才发送的分组丢失了,因而重传前面发送过的分组,称为**超时重传**,要实现超时重传,就要在每发送完一个分组时设置一个超时计时器,如果在超时计时器到期之前收到了对方的确认,就撤销已设置的超时计时器

!>注意事项

- A在发送完一个分组后,必须暂时保留已发送的分组的副本(在发生超时重传时使用)只有在收到相应的确认后才能清除暂时保留的分组副本

- 分组和确认分组都必须进行编号(这样才能明确是哪一个发送出去的分组收到了确认,而哪一个分组还没有收到确认)

- 超时计时器设置的重传时间**应当比数据在分组传输的平均往返时间更长一些**(如果重传时间设定得很长,那么通信的效率就会很低,但如果重传时间设定得太短,以致产生不必要的重传,就浪费了网络资源)

3. 确认丢失与确认迟到

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/确认丢失与确认迟到.jpg)

若B所发送的对M1的确认丢失了,A在设定的超时重传时间内没有收到确认,并无法知道是自己发送的分组出错或丢失,或者是B发送的确认丢失了

因此A在超时计时器到期后就要重传M1

假定B又收到了重传的分组M1,B应有以下两个动作

- **丢弃这个重复的分组M1**,不向上层交付

- **向A发送确认**,不能认为已经发送过确认就不再发送,因为A之所以重传M1就表示A没有收到对M1的确认

---

若传输过程中没有出现差错,但B对分组M1的确认迟到了,A会收到重复的确认

对重复的确认的处理很简单:**收下后就丢弃**,B仍然会收到重复的M1,并且同样要丢弃重复的M1,并重传确认分组

A最终总是可以收到对所有发出的分组的确认

---

使用上述的确认和重传机制(称为**自动重传请求**`ARQ`),我们就可以在**不可靠的传输网络**上实现**可靠的通信**

##### 信道利用率

停止等待协议的优点是简单,,但缺点是信道利用率太低

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/信道利用率.jpg)

假定A发送分组需要的时间是$T_D$,显然,$T_D$等于分组长度除以数据率

再假定分组正确到达B后,B处理分组的时间可以忽略不计,同时立即发回确认

假定B发送确认分组需要时间$T_A$,如果A处理确认分组的时间也可以忽略不计,那么A在经过时间$T_D+RTT+T_A$后就可以再发送下一个分组

信道的利用率$U=T_D/(T_D+RTT+T_A)$

!>当往返时间RTT远大于分组发送时间$T_D$时,信道的利用率就会非常低

---

为了提高传输效率,发送方可以不使用低效率的停止等待协议,而是采用**流水线传输**

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/流水线传输.jpg)

流水线传输就是发送方可连续发送多个分组,不必每发完一个分组就停顿下来等待对方的确认,这样可使信道上一直有数据不间断地在传送从而获得很高的信道利用率

使用流水线传输时,要使用**连续ARQ协议**和**滑动窗口协议**

#### 连续ARQ协议

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/连续ARQ.jpg)

`a`表示发送方维持的发送窗口,它的意义是:位于发送窗口内的5个分组都可连续发送出去,而不需要等待对方的确认,信道利用率就提高了

连续ARQ协议规定,发送方每收到一个确认,就把发送窗口向前滑动一个分组的位置

`b`表示发送方收到了对第1个分组的确认,于是把发送窗口向前移动一个分组的位置,如果原来已经发送了前5个分组,那么现在就可以发送窗口内的第6个分组了

接收方一般都是采用**累积确认**的方式:接收方不必对收到的分组逐个发送确认,而是在收到几个分组后,对按序到达的最后一个分组发送确认,这就表示:**到这个分组为止的所有分组都已正确收到了**

如果发送方发送了前5个分组,而中间的第3个分组丢失了,这时接收方只能对前两个分组发出确认,发送方无法知道后面三个分组的下落,而只好把后面的三个分组都再重传一次

这就叫做`Go-back-N`(回退N),表示需要再退回来重传已发送过的N个分组

#### 滑动窗口协议

TCP的滑动窗口以字节为单位,发送方和接收方分别维持发送窗口(在没有收到确认的情况下,可以连续把窗口内的数据全部发送出去)和接收窗口(只允许接收落入窗口内的数据)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/滑动窗口1.jpg)

发送窗口里面的序号表示允许发送的序号,窗口越大,传输效率越高

发送窗口的位置由窗口前沿和后沿的位置共同确定,发送窗口后沿的变化情况有两种可能,即不动(没有收到新的确认)和前移(收到了新的确认)

发送窗口后沿不可能向后移动,因为不能撤销掉已收到的确认,发送窗口前沿通常是不断向前移动,但也有可能不动(没有收到新的确认,对方通知的窗口大小也不变或者收到了新的确认但对方通知的窗口缩小了,使得发送窗口前沿正好不动)

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/滑动窗口2.jpg)

要描述一个发送窗口的状态需要三个指针:P1,P2和P3

小于P1的是已发送并已收到确认的部分,而大于P3的是不允许发送的部分

`P3-P1`为A的发送窗口,`P2-P1`为已发送但尚未收到确认的字节数,`P3-P2`为允许发送但当前尚未发送的字节数(可用窗口)

B的接收窗口大小是20,B收到了序号为32和33的数据,这些数据没有按序到达,因为序号为31的数据没有收到

B只能对**按序收到**的数据中的最高序号给出确认,因此B发送的确认报文段中的确认号仍然是31

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/滑动窗口3.jpg)

B解收到31号数据后,B的接收窗口向前滑动3个序号,并向A发送确认,确认号更新为34

A接收到确认后,A的发送窗口向前滑动3个序号,但指针`P2`不动

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/滑动窗口4.jpg)

A在发送完发送窗口中的数据后,指针`P2`与`P3`重合,A的可用窗口为零,如果B的确认没有及时抵达,则A在**超时计时器**的控制下对数据进行重传,直到B的确认抵达

##### 超时重传时间的选择

TCP采用了一种自适应算法,它记录一个报文段发出的时间,以及收到相应的确认的时间,这两个时间之差就是报文段的往返时间`RTT`

TCP保留了RTT的一个加权平均往返时间$RTT_S$,每当第一次测量到RTT样本时,$RTT_S$值就取为所测量到的RTT样本值,但以后每测量到一个新的RTT样本,就重新计算一次$RTT_S$

$new RTT_S=(1-a)*(old RTT_S)+a*(new RTT)$

$0<=a<1$,a建议为`0.125`

当$a$接近于0,表明$RTT_S$变化不大,$RTT$更新较慢,当$a$接近于1,表明$RTT_S$变化较大,$RTT$更新较快

超时重传时间`RTO`应略大于$RTT_S$

$RTO=RTT_S+4*RTT_D$

$RTT_D$为$RTT$的偏差的加权平均值

$new RTT_D=(1-b)*(old RTT_D)+b*|RTT_s -new RTT|$

$b<1$,b建议为`0.25`

#### 流量控制

##### 使用滑动窗口进行流量控制

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/流量控制.jpg)

设A向B发送数据,在连接建立时,B告知A其接收窗口`rwnd=400`,设每一个报文段为100字节长,而数据报文段序号的初始值设为1

接收方的主机B进行了三次流量控制,第一次把窗口减小到rwnd=300,第二次又减到rwnd=100,最后减到rwnd=0,即不允许发送方再发送数据了,这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止

B向A发送的三个报文段都设置了`ACK=1`,只有在ACK=1时确认号字段才有意义

假设B向A发送了零窗口的报文段后不久,B的接收缓存又有了一些存储空间,于是B向A发送了rwnd=400的报文段,然而这个报文段在传送过程中丢失了,A一直等待收到B发送的非零窗口的通知,而B也一直等待A发送的数据,因此造成死锁

TCP为每一个连接设有一个**持续计时器**,只要TCP连接的一方收到对方的零窗口通知,就启动持续计时器

若持续计时器设置的时间到期,就发送一个零窗口探测报文段(仅携带1字节的数据),而对方就在确认这个探测报文段时给出了现在的窗口值

如果窗口仍然是零,那么收到这个报文段的一方就重新设置持续计时器,如果窗口不是零,那么死锁的僵局就可以打破了

#### 拥塞控制

!>拥塞控制与流量控制的区别

- 拥塞控制:防止过多的数据注入到网络中,使网络中的路由器或链路不致过载

- 流量控制:抑制发送端发送数据的速率,以使接收端来得及接收

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/拥塞控制1.jpg)

TCP采用基于窗口的方法进行拥塞控制,TCP发送方维持一个拥塞窗口`cwnd`,发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量,真正的发送窗口值=Min(接收方窗口值,拥塞窗口值)

TCP进行拥塞控制的算法有四种,即慢开始,拥塞避免,快重传,快恢复

##### 慢开始

目的:用来确定网络的负载能力或拥塞程度

算法的思路:由小到大逐渐增大拥塞窗口数值

拥塞窗口`cwnd`控制方法:在每收到一个对新的报文段的确认后,可以把拥塞窗口增加最多一个`SMSS`(发送方的最大报文段)的数值

cwnd每次增加量=min(N,SMSS)

N是原先未被确认的,但现在被刚收到的确认报文段所确认的字节数,当N<SMSS时,拥塞窗口每次的增加量要小于SMSS

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/拥塞控制2.jpg)

在一开始发送方先设置`cwnd=1`,发送第一个报文段M1,接收方收到后确认M1,发送方收到对M1的确认后,把cwnd从1增大到2,于是发送方接着发送M2和M3两个报文段,接收方收到后发回对M2和M3的确认

发送方每收到一个对新报文段的确认(重传的不算在内)就使发送方的拥塞窗口加1,因此发送方在收到两个确认后,cwnd就从2增大到4,并可发送M4~M7共4个报文段

因此使用慢开始算法后,**每经过一个传输轮次,拥塞窗口cwnd就加倍**

!>设置慢开始门限状态变量`ssthresh`

1. 当cwnd<ssthresh时,使用慢开始算法

2. 当cwnd>ssthresh时,停止使用慢开始算法而改用拥塞避免算法

3. 当cwnd=ssthresh时,既可使用慢开始算法,也可使用拥塞避免算法

##### 拥塞避免算法

!>让拥塞窗口cwnd缓慢地增大,避免出现拥塞

每经过一个传输轮次,拥塞窗口`cwnd=cwnd+1`,使拥塞窗口cwnd按线性规律缓慢增长,在拥塞避免阶段,具有加法增大的特点

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/拥塞控制3.jpg)

当TCP连接进行初始化时,把拥塞窗口cwnd置为1,慢开始门限的初始值设置为16个报文段,即ssthresh=16,在执行慢开始算法时,发送方每收到一个对新报文段的确认ACK,就把拥塞窗口值加1,然后开始下一轮的传输,因此拥塞窗口cwnd随着传输轮次按指数规律增长

当拥塞窗口cwnd增长到慢开始门限值ssthresh时(点➊,此时拥塞窗口cwnd=16),就改为执行拥塞避免算法,拥塞窗口按线性规律增长

当拥塞窗口cwnd=24时,网络出现了超时(点➋),发送方判断为网络拥塞,于是调整门限值`ssthresh=cwnd/2=12`,同时设置拥塞窗口cwnd=1,进入慢开始阶段

按照慢开始算法,发送方每收到一个对新报文段的确认ACK,就把拥塞窗口值加1,当拥塞窗口`cwnd=ssthresh=12`时(点➌),改为执行拥塞避免算法,拥塞窗口按线性规律增大,当拥塞窗口`cwnd=16`时(点➍),出现发送方一连收到3个对同一个报文段的重复确认的情况

>有时,个别报文段会在网络中丢失,但实际上网络并未发生拥塞,如果发送方迟迟收不到确认,就会产生超时,就会误认为网络发生了拥塞,这就导致发送方错误地启动慢开始,把拥塞窗口cwnd又设置为1,因而降低了传输效率

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/快重传.jpg)

!>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失

快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认,而是要立即发送确认,即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认

接收方收到了M1和M2后都分别及时发出了确认,假定接收方没有收到M3但却收到了M4,按照快重传算法,接收方必须立即发送对M2的重复确认,以便让发送方及早知道接收方没有收到报文段M3,发送方接着发送M5和M6,接收方收到后也仍要再次分别发出对M2的重复确认,发送方共收到了接收方的4个对M2的确认,其中后3个都是重复确认

快重传算法规定,发送方只要一连收到3个重复确认,就知道接收方确实没有收到报文段M3,因而应当立即进行重传

因此,在点➍,发送方知道现在只是丢失了个别的报文段,于是执行快恢复算法,发送方调整门限值`ssthresh=cwnd/2=8`,同时设置拥塞窗口`cwnd=ssthresh=8`(点➎),并开始执行拥塞避免算法

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP拥塞控制流程.jpg)

#### TCP连接建立

>TCP建立连接的过程叫做握手,握手需要在客户和服务器之间交换三个TCP报文段

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP连接建立.jpg)

两端的TCP进程都处于CLOSED状态,A主动打开连接,B被动打开连接

B的TCP服务器进程先创建传输控制块TCB,准备接受客户进程的连接请求,服务器进程处于LISTEN状态,等待客户的连接请求

A的TCP客户进程首先创建传输控制模块TCB,在建立TCP连接时,向B发出连接请求报文段,这时首部中的同步位`SYN=1`,同时选择一个初始序号`seq=x`

!>TCP规定,SYN报文段(即`SYN=1`的报文段)不能携带数据,但要消耗掉一个序号

这时,TCP**客户进程**进入`SYN-SENT`(同步已发送)状态

---

B收到连接请求报文段后,如同意建立连接,则向A发送确认

在确认报文段中应把SYN位和ACK位都置1,确认号是`ack=x+1`,同时也为自己选择一个初始序号`seq=y`

!>这个报文段也不能携带数据,但同样要消耗掉一个序号

这时TCP**服务器进程**进入`SYN-RCVD`(同步收到)状态

---

TCP客户进程收到B的确认后,还要向B给出确认(为了防止已失效的连接请求报文段突然又传送到了B,因而产生错误)

确认报文段的ACK置1,确认号`ack=y+1`,而自己的序号`seq=x+1`

!>ACK报文段可以携带数据,但如果不携带数据则不消耗序号,在这种情况下,下一个数据报文段的序号仍是`seq=x+1`

这时,TCP连接已经建立,A进入`ESTABLISHED`(已建立连接)状态,当B收到A的确认后,也进入ESTABLISHED状态

#### TCP连接释放

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP连接释放.jpg)

A的应用进程先向其TCP发出连接释放报文段,并停止再发送数据,主动关闭TCP连接

A把连接释放报文段首部的终止控制位FIN置1,其序号`seq=u`,它等于前面已传送过的数据的最后一个字节的序号加1,这时A进入`FIN-WAIT-1`(终止等待1)状态,等待B的确认

!>TCP规定,FIN报文段即使不携带数据,它也消耗掉一个序号

---

B收到连接释放报文段后即发出确认,确认号是`ack=u+1`,而这个报文段自己的序号是v,等于B前面已传送过的数据的最后一个字节的序号加1

B进入`CLOSE-WAIT`(关闭等待)状态,这时的TCP连接处于半关闭(half-close)状态,即从B到A这个方向的连接并未关闭

---

A收到来自B的确认后,就进入`FIN-WAIT-2`(终止等待2)状态,等待B发出的连接释放报文段
 
若B已经没有要向A发送的数据,其应用进程就通知TCP释放连接,这时B发出的连接释放报文段必须使`FIN=1`

假定B的序号为w(在半关闭状态B可能又发送了一些数据),B还必须重复上次已发送过的确认号`ack=u+1`,这时B就进入`LAST-ACK`(最后确认)状态,等待A的确认

---

A在收到B的连接释放报文段后,必须对此发出确认

在确认报文段中把ACK置1,确认号`ack=w+1`,而自己的序号是`seq=u+1`

!>根据TCP标准,前面发送过的FIN报文段要消耗一个序号

进入到`TIME-WAIT`(时间等待)状态,现在TCP连接还没有释放掉,必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后,A才进入到`CLOSED`状态,时间MSL叫做最长报文段寿命

>为了保证A发送的最后一个ACK报文段能够到达B,这个ACK报文段有可能丢失,因而使处在`LAST-ACK`状态的B收不到对已发送的`FIN+ACK`报文段的确认
>
>B会超时重传这个`FIN+ACK`报文段,而A就能在2MSL时间内收到这个重传的FIN+ACK报文段,接着A重传一次确认,重新启动2MSL计时器
>
>最后,A和B都正常进入到CLOSED状态,如果A在TIME-WAIT状态不等待一段时间,而是在发送完ACK报文段后立即释放连接,那么就无法收到B重传的FIN+ACK报文段,因而也不会再发送一次确认报文段
>
>这样,B就无法按照正常步骤进入CLOSED状态

B只要收到了A发出的确认,就进入CLOSED状态,B结束TCP连接的时间要比A早一些

## 应用层

### 域名系统DNS

域名系统(英语:`Domain Name System`,缩写:`DNS`)是互联网的一项服务,它作为将域名和IP地址相互映射的一个分布式数据库,能够使人更方便地访问互联网,DNS使用TCP和UDP端口`53`

当前,对于每一级域名长度的限制是`63`个字符,域名总长度则不能超过`253`个字符(不区分大小写)

域名的结构由标号序列组成,各标号之间用点隔开

`xxx.三级域名.二级域名.顶级域名`

DNS系统中,常见的资源记录类型有:

1. 主机记录(A记录):RFC 1035定义,A记录是用于名称解析的重要记录,它将特定的主机名映射到对应主机的IP地址上
2. 别名记录(CNAME记录):RFC 1035定义,CNAME记录用于将某个别名指向到某个A记录上,这样就不需要再为某个新名字另外创建一条新的A记录
3. IPv6主机记录(AAAA记录):RFC 3596定义,与A记录对应,用于将特定的主机名映射到一个主机的IPv6地址
4. 域名服务器记录(NS记录) :用来指定该域名由哪个DNS服务器来进行解析,如`ns1.domain.com`,`ns2.domain.com`,NS记录是指定由哪个DNS服务器解析你的域名

在未缓存的DNS查询期间,每当用户在浏览器中输入网址,该操作都会触发DNS查找,并且所有DNS查找都从**根区域**开始,查找到达根区域后,将沿DNS系统的层次结构向下移动,首先到达TLD服务器(顶级域名服务器
),然后到达特定域的服务器,直到最终到达权威性名服务器,以查到正确的域名,其中包含要搜索的网站的IP地址,该IP地址被返回给客户端

有`13`个不同的IP地址为DNS根区域提供服务,并且全球有数百个冗余根服务器来处理对根区域的请求

#### 递归查询与迭代查询

- 主机向本地域名服务器的查询一般都是采用递归查询

所谓递归查询就是:如果主机所询问的本地域名服务器不知道被查询的域名的IP地址,那么本地域名服务器就以DNS客户的身份,向其它根域名服务器继续发出查询请求报文(即替主机继续查询),而不是让主机自己进行下一步查询

因此,递归查询返回的查询结果或者是所要查询的IP地址,或者是报错,表示无法查询到所需的IP地址

- 本地域名服务器向根域名服务器的查询是迭代查询

迭代查询的特点:当根域名服务器收到本地域名服务器发出的迭代查询请求报文时,要么给出所要查询的IP地址,要么告诉本地服务器:"你下一步应当向哪一个域名服务器进行查询"

然后让本地服务器进行后续的查询,根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器,让本地域名服务器再向顶级域名服务器查询

顶级域名服务器在收到本地域名服务器的查询请求后,要么给出所要查询的IP地址,要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询

最后,知道了所要解析的IP地址或报错,然后把这个结果返回给发起查询的主机

#### DNS查找的8个步骤

1. 用户在Web浏览器中键入`example.com`,查询传输到Internet中,并被DNS递归解析器接收
2. 接着,解析器查询DNS根域名服务器`.`
3. 然后,根服务器使用存储其域信息的顶级域(TLD)DNS服务器(例如`.com`或`.net`)的地址响应该解析器在搜索`example.com`时,我们的请求指向`.com`TLD
4. 然后,解析器向`.com`TLD发出请求
5. TLD服务器随后使用该域的域名服务器`example.com`的IP地址进行响应
6. 最后,递归解析器将查询发送到域的域名服务器
7. `example.com`的IP地址而后从域名服务器返回解析器
8. 然后DNS解析器使用最初请求的域的IP地址响应Web浏览器

DNS查找的这8个步骤返回`example.com`的IP地址后,浏览器便能发出对该网页的请求:

9. 浏览器向该IP地址发出HTTP请求
10. 位于该IP的服务器返回将在浏览器中呈现的网页

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/dns-lookup-diagram.webp)

### 文件传输协议FTP

FTP服务一般运行在`20`和`21`两个端口,端口`20`用于在客户端和服务器之间传输数据流,而端口`21`用于传输控制流,并且是命令通向ftp服务器的进口

### 统一资源定位符URL

统一资源定位符(英语:`Uniform Resource Locator`,缩写:`URL`,俗称网页地址或简称网址)是因特网上标准的资源的地址,如同在网络上的门牌

统一资源定位符的标准格式如下:

`[协议类型]://[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID]`

超文本传输协议的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中:

1. 传送协议
2. 层级URL标记符号(为`//`,固定不变)
3. 访问资源需要的凭证信息(可省略)
4. 服务器(通常为域名,有时为IP地址)
5. 端口号(以数字方式表示,若为默认值可省略)
6. 路径(以`/`字符区别路径中的每一个目录名称)
7. 查询(GET模式的窗体参数,以`?`字符为起点,每个参数以`&`隔开,再以`=`分开参数名称与资料,通常以UTF8的URL编码,避开字符冲突的问题)
8. 片段以`#`字符为起点

以`https://zh.wikipedia.org:443/w/index.php?title=Special:随机页面`为例,其中:

1. `https`,是协议
2. `zh.wikipedia.org`,是服务器
3. `443`,是服务器上的网络端口号
4. `/w/index.php`,是路径
5. `?title=Special:随机页面`,是询问

### 超文本传送协议HTTP

#### 主要特点

HTTP使用了面向连接的TCP作为运输层协议,保证了数据的可靠传输

HTTP协议本身也是无连接的,虽然它使用了面向连接的TCP向上提供的服务

HTTP是面向事务的客户服务器协议

HTTP 1.0协议是无状态的

#### 状态码

- 1xx消息:请求已被服务器接收,继续处理

- 2xx成功:请求已成功被服务器接收,理解,并接受

- 3xx重定向:需要后续操作才能完成这一请求

- 4xx请求错误:请求含有词法错误或者无法被执行

- 5xx服务器错误:服务器在处理某个正确请求时发生错误

#### 请求信息

发出的请求信息(message request)包括以下几个:

- 请求行(例如`GET /images/logo.gif HTTP/1.1`,表示从`/images`目录下请求`logo.gif`这个文件)
- 请求头(例如`Accept-Language: en`)
- 空行
- 其他消息体

请求行和标题必须以`<CR><LF>`作为结尾,空行内必须只有`<CR><LF>`而无其他空格

在HTTP/1.1协议中,所有的请求头,除Host外,都是可选的

##### 客户端请求

```
GET / HTTP/1.1
Host: www.google.com

```

(末尾有一个空行,第一行指定方法,资源路径,协议版本,第二行是在1.1版里必带的一个header作用于指定主机)

##### 服务器应答

```
HTTP/1.1 200 OK
Content-Length: 3059
Server: GWS/2.0
Date: Sat, 11 Jan 2003 02:44:04 GMT
Content-Type: text/html
Cache-control: private
Set-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqy
X9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com
Connection: keep-alive

```

### 简单邮件传输协议SMTP

简单邮件传输协议(英语:`Simple Mail Transfer Protocol`,缩写:`SMTP`)是一个在互联网上传输电子邮件的标准

!>SMTP使用`TCP`端口`25`,要为一个给定的域名决定一个SMTP服务器,需要使用DNS的MX记录

### 动态主机配置协议DHCP

DHCP基于`UDP`工作,DHCP服务器运行在`67`号端口,DHCP客户运行在`68`号端口

## 无线网络和移动网络

### IEEE 802.11

802.11就是无线以太网的标准,它使用星形拓扑,其中心叫做接入点AP,在MAC层使用`CSMA/CA`协议

802.11标准规定无线局域网的最小构件是**基本服务集BSS**,一个基本服务集BSS包括一个基站和若干个移动站,所有的站在本BSS以内都可以直接通信,但在和本BSS以外的站通信时都必须通过本BSS的基站

当网络管理员安装AP时,必须为该AP分配一个不超过`32`字节的服务集标识符`SSID`和一个通信信道,SSID其实就是指使用该AP的无线局域网的名字,一个基本服务集BSS所覆盖的地理范围叫做一个**基本服务区BSA**

---

一个移动站若要加入到一个基本服务集BSS,就必须先选择一个接入点AP,并与此接入点建立关联

建立关联就表示这个移动站加入了选定的AP所属的子网,并和这个AP之间创建了一个虚拟线路

只有关联的AP才能向这个移动站发送数据帧,而这个移动站也只有通过关联的AP才能向其他站点发送数据帧

若移动站使用重建关联服务,就可把这种关联转移到另一个接入点

当使用分离服务时,就可终止这种关联

---

移动站与AP建立关联的方法

- 被动扫描:移动站等待接收接入站周期性发出的**信标帧**,信标帧中包含有若干系统参数(如SSID)

- 主动扫描:移动站主动发出**探测请求帧**,然后等待从AP发回的**探测响应帧**

---

热点就是公众无线入网点,由许多热点和 AP 连接起来的区域叫做热区

用户可以通过无线信道接入到无线互联网服务提供者,然后再经过无线信道接入到互联网

---

初期的接入加密方案称为`WEP`,意思是有线等效的保密

现在的接入加密方案为`WPA`或`WPA2`

### 802.11 物理层

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/802.11物理层.jpg)

>OFDM代表正交频分复用,MIMO代表多入多出,使用多空间通道,对不同数据进行不同的调制/解调,因而提高了数据的传输速率

### 802.11 链路层

1. 隐蔽站问题

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/隐蔽站问题.jpg)

站点A和C都想和B通信,但A和C相距较远,彼此都听不见对方,当A和C检测到信道空闲时,就都向B发送数据,结果发生了碰撞

2. 暴露站问题

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/暴露站问题.jpg)

站点B向A发送数据,而C又想和D通信,但C检测到信道忙,于是就不敢向D发送数据,其实B向A发送数据并不影响C向D发送数据

因此`CSMA/CA`协议需要具有碰撞避免的功能

802.11的MAC层具有协调功能,用于确认在BSS中的移动站,什么时候能够发送或接收数据

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/802.11MAC层.jpg)

1. 分布协调功能DCF,DCF不采用任何中心控制,而是在每一个结点使用CSMA机制的分布式接入算法,让各个站通过争用信道来获取发送权

2. 点协调功能PCF,PCF是选项,是用接入点AP集中控制整个BSS内的活动,因此自组网络就没有PCF子层,PCF使用集中控制的接入算法,用类似于探询的方法把发送数据权轮流交给各个站,从而避免了碰撞的产生

为了尽量避免碰撞,802.11规定,所有的站在完成发送后,必须等待一段很短的时间(继续监听)才能发送下一帧,这段时间通称为**帧间间隔**`IFS`

>帧间间隔的长短取决于该站要发送的帧的类型,高优先级帧需要等待的时间较短,因此可优先获得发送权,但低优先级帧就必须等待较长的时间,若低优先级帧还没来得及发送而其他站的高优先级帧已发送到媒体,则媒体变为忙态,低优先级帧只能再推迟发送,这样就减少了发生碰撞的机会

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CSMACA工作原理.jpg)

SIFS,即短帧间间隔,长度为28µs,SIFS是最短的帧间间隔,用来分隔开属于一次对话的各帧,在这段时间内,一个站应当能够从发送方式切换到接收方式

DIFS,即分布协调功能帧间间隔,长度为128µs,在DCF方式中,DIFS用来发送数据帧和管理帧

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/退避机制.jpg)

>若站点最初有数据要发送(而不是发送不成功再进行重传),且检测到信道空闲,在等待时间DIFS后,就发送整个数据帧
>
>否则,站点执行CSMA/CA协议的退避算法,一旦检测到信道忙,就冻结退避计时器,只要信道空闲,退避计时器就进行倒计时
>
>当退避计时器时间减少到零时(这时信道只可能是空闲的),站点就发送整个的帧并等待确认
>
>发送站若收到确认,就知道已发送的帧被目的站正确收到了,这时如果要发送第二帧,就要从上面的步骤(2)开始,执行CSMA/CA协议的退避算法,随机选定一段退避时间

当一个站要发送数据帧时,仅在下面的情况下才不使用退避算法:检测到信道是空闲的,并且这个数据帧是它想发送的第一个数据帧

以下几种情况必须使用退避算法:

- 在发送第一个帧之前检测到信道处于忙态

- 每一次的重传

- 每一次的成功发送后再要发送下一帧

![](https://img.misaka.gq/Notes/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/802.11帧格式.jpg)

- MAC首部,共`30`字节

- 帧主体,也就是帧的数据部分,不超过2312字节

- 帧检验序列FCS是MAC尾部,共4字节