### 公钥密码体制的基本原理

公钥密码体制是一种陷门单向函数

?>单向函数:定义域到值域的一个映射,同时满足计算函数值是容易的,而从函数值计算原象是不可行的

?>陷门单向函数:单向函数,存在一个附加信息,当不知道附加信息时,从函数值求原象是困难的,当知道附加信息时,过程变得简单,即未知时为单向函数,已知时不再是单向函数,将附加信息称为陷门信息

公钥密码体制将陷门单向函数作为公开密钥,将陷门信息作为秘密密钥,安全强度取决于陷门函数的计算复杂度

### 数论基础

1. 设$a$,$b$是整数,$a!=b$,如果有一个整数$x$,使得$b=ax$,则$b$叫做$a$的倍数,$a$叫做$b$的因数,或者说$a$能整除$b$,或$b$能被$a$整除,记为$a|b$

- 若$a|b$,那么对任何整数$c$,都有$a|bc$
- 若$a|b$,$b|c$,那么有$a|c$
- 若$a|b$,$a|c$,那么对任何整数$x$和$y$,都有$a|(bx+cy)$
- 若$a|b$,$b|a$,那么$a=+-b$
- 若$a|b$,$a>0$,$b>0$,那么$a<=b$

2. 给定任意整数$a$和$b$,且$a>0$,必存在唯一的整数$q$和$r$,满足$b=qa+r$,其中$0<=r<a$,$q$称为商,$r$称为余

3. 若$a$,$b$,$c$都是整数,且$a|b$,$a|c$,那么称$a$是$b$和$c$的公因数,在所有公因数中最大的一个,称为最大公因数,计为$gcd(b,c)$或$(b,c)$

4. 设$a$,$b$,$c$都是整数,$a$,$b$都不为零,如果$a|c$,$b|c$,则称$c$是$a$和$b$的公倍数,如果$a$和$b$的公倍数$c$除尽$a$和$b$的任一个公倍数,则称$c$是$a$和$b$的最下公倍数,记为$c=lcm(a,b)$或$c=[a,b]$

5. 若一个**大于1**的正整数$p$,只能被1和它本身整除,不能被其他正整数整除,则称这样的正整数$p$为素数或质数

6. 一个正整数可以写成几个素数的乘积,且结果唯一

7. 如果$a$和$b$的最大公因数是1,即$gcd(a,b)=1$,则称$a$和$b$互素

8. 欧几里得除法:给定整数$b$和$c$,且$c>0$,重复使用带余除法,直至余数为0,可得以下方程

$$
b=cq_1 + r_1 , 0<r_1<c
$$
$$
c=r_1q_2 + r_2 , 0<r_2<r1
$$
$$
r_1=r_2q_3 + r_3 , 0<r_3<r2
$$
$$
...
$$
$$
r_{j+1}=r_jq_{j+1}
$$

最后一个不为零的余数$r_j$就是$b$和$c$的最大公因数$gcd(b,c)$

9. 费马小定理:假如$a$是一个整数,$p$是一个质数,那么$a^p−a$是$p$的倍数,可以表示为
$$
a^p≡a (mod p)
$$
如果$a$不是$p$的倍数,这个定理也可以写成
$$
a^{p−1}≡1 (mod p)
$$

10. 欧拉定理:如果$gcd(a,m)=1$,则恒有
$$
a^{φ(m)}≡1 (mod m)
$$
其中$φ(m)$是欧拉函数,$φ(m)$的值等于小于$m$且与$m$互素的正整数的个数

11. 欧拉函数的性质:令$m$和$n$表示任意两个互素的正整数,即$gcd(m,n)=1$,则$φ(nm)=φ(m)φ(n)$

12. 中国剩余定理:设$m_1$,$m_2$,...,$m_k$是两两互素的正整数,令
$$
M=m_1m_2...m_k=m_1M_1=m_2M_2=...=m_kM_k
$$

其中$M_i=M/m_i$,$i=1,2,...,k$,则下面的同余方程组
$$
x≡b_i (mod m_i),i=1,2,...,k
$$

的正整数解$x_0$存在,且在模$M$的意义下是唯一的
$$
x_0=b_1M_1^{'}M_1+b_2M_2^{'}M_2+...b_kM_k^{'}M_k (mod M)
$$

$M^{'}$满足
$$
M_i^{'}M_i≡1 (mod m_i),i=1,2,...,k
$$

的正整数,即$M_i^{'}$是$M_i$以$m_i$为模的乘法逆元

### 群

群$(G,·)$是由集合$G$和二元运算$·$构成的,符合以下四个性质的数学结构

其中,二元运算结合任何两个元素$a$和$b$而形成另一个元素,记为$a·b$,符号$·$是具体的运算,比如整数加法

群公理所述的四个性质为:

1. **封闭性**: 对于所有$G$中$a$,$b$,运算$a·b$的结果也在$G$中

2. **结合律**: 对于所有$G$中的$a$,$b$和$c$,等式$(a·b)·c=a·(b·c)$成立

3. **单位元**: 存在$G$中的一个元素$e$,使得对于所有$G$中的元素$a$,总有等式$e·a=a·e=a$成立

4. **逆元**: 对于每个$G$中的$a$,存在$G$中的一个元素$b$使得总有$a·b=b·a=e$,此处$e$为单位元

例如:全体整数对加法构成群,而对乘法不构成群(零是加法的单位元)

### 平方剩余问题

设$a$和$n$互素,若方程$x^2≡a (mod n)$有解,则称$a$是模$n$的平方剩余,否则称为非平方剩余

若$p$是奇素数,$p$不能整除$a$,则$x^2≡a (mod n)$无解或有两个模$p$不同余的解

若$p$是奇素数,则整数$1,2,...,p-1$中正好有$(p-1)/2$个是模$p$的平方剩余,其余的$(p-1)/2$个是非平方剩余

当$n$是合数时,若$n$的分解未知,则求方程$x^2≡a (mod n)$的解时困难的

**Blum整数**: 如果$p$和$q$是两个素数,且$p≡3 (mod 4)$,$q≡3 (mod 4)$,那么$n=p*q$称为Blum整数,如果$n$是一个Blum整数,那么它的每一个二次剩余恰好有`4`个平方根,其中一个也是平方,这就是主平方根

**本原元**:如果$p$是一个素数,且$g$小于$p$,若对于从$0$到$p-1$的每一个$y$,都存在某个$x$,使得$g^x≡y (mod p)$成立,那么$g$是$Z_p$的乘法群$Z_p^*$的生成元,称$g$是模$p$的本原元

### RSA

[https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_theory/](https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_theory/)

#### 基本原理

- 公钥与私钥的产生

1. 随机选择两个不同大质数$p$和$q$,计算$N = p \times q$
2. 根据欧拉函数,求得$\varphi (N)=\varphi (p)\varphi (q)=(p-1)(q-1)$
3. 选择一个小于$\varphi (N)$的整数$e$,使$e$和$\varphi (N)$互质,并求得$e$关于$\varphi (N)$的模反元素,命名为 $d$,有$ed\equiv 1 \pmod {\varphi (N)}$
4. 将$p$和$q$的记录销毁

此时,$(N,e)$是公钥,$(N,d)$是私钥

- 消息加密

首先需要将消息以一个双方约定好的格式转化为一个小于$N$,且与$N$互质的整数$m$

如果消息太长,可以将消息分为几段,这也就是我们所说的块加密,后对于每一部分利用如下公式加密:

$$
m^{e}\equiv c\pmod N
$$

- 消息解密

利用密钥$d$进行解密

$$
c^{d}\equiv m\pmod N
$$

#### 正确性证明

即我们要证$m^{ed} \equiv m \bmod N$,已知$ed \equiv 1 \bmod \phi(N)$,那么$ed=k\phi(N)+1$,即需要证明

$$
m^{k\phi(N)+1}  \equiv m \bmod N
$$

这里我们分两种情况证明

第一种情况$gcd(m,N)=1$,那么$m^{\phi(N)} \equiv 1 \bmod N$,因此原式成立

第二种情况$gcd(m,N)\neq 1$,那么$m$ 必然是$p$或者$q$的倍数,并且$n=m$小于$N$,我们假设

$$
m=xp
$$

那么$x$必然小于$q$,又由于$q$是素数,那么

$$
m^{\phi(q)} \equiv 1 \bmod q
$$

进而

$$
m^{k\phi(N)}=m^{k(p-1)(q-1)}=(m^{\phi(q)})^{k(p-1)} \equiv 1 \bmod q
$$

那么

$$
m^{k\phi(N)+1}=m+uqm
$$

进而

$$
m^{k\phi(N)+1}=m+uqxp=m+uxN
$$

所以原式成立

#### 例子

- 密钥生成

首先取$p=11$,$q=13$,计算$n=p*q=143$,$\phi(n)=(p-1)*(q-1)=120$

然后选取$e=17$,满足$gcd(e,\varphi(n))=gcd(17,120)=1$

计算私钥$d=e^{-1} (mod 120)=113$

最后公布公钥$(e,n)=(17,143)$,保留私钥$d=113$

- 加密

对明文信息$m=24$进行加密,则密文为$c≡m^e=24^{17} (mod 143)=7$

- 解密

接收到密文$c=7$后,利用私钥$d=113$对密文解密$m≡c^d=7^{113} (mod 143)=24$

#### 安全性

1. $p$和$q$的长度应该相差不大

2. $(p-1)$和$(q-1)$都应该包含大的素因子

3. $gcd(p-1,q-1)$应该尽可能小

### ElGamal

[ElGamal加密算法](https://zh.wikipedia.org/wiki/ElGamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95)

- 密钥生成

密钥生成的步骤如下:

Alice利用生成元$g$产生一个$q$阶循环群$G$的有效描述,该循环群需要满足一定的安全性质

Alice从${ 1 , … , q − 1 }$中随机选择一个$x$

Alice计算$h := g$

Alice公开$h$以及$G$,$q$,$g$的描述作为其公钥,并保留$x$作为其私钥,私钥必须保密

- 加密

使用Alice的公钥$( G , q , g , h )$向她加密一条消息$m$的加密算法工作方式如下:

Bob从${ 1 , … , q − 1 }$随机选择一个$y$,然后计算$c_1 := g^y$

Bob计算共享秘密$s := h^y$

Bob把他要发送的秘密消息$m$映射为$G$上的一个元素$m'$

Bob计算$c_{2}:=m'\cdot s$

Bob将密文$(c_{1},c_{2})=(g^{y},m'\cdot h^{y})=(g^{y},m'\cdot (g^{x})^{y})$发送给Alice

值得注意的是,如果一个人知道了$m'$,那么它很容易就能知道$h^{y}$的值,因此对每一条信息都产生一个新的$y$可以提高安全性,所以$y$也被称作临时密钥

- 解密

利用私钥$x$对密文$(c_{1},c_{2})$进行解密的算法工作方式如下:

Alice计算共享秘密$s:=c_{1}{}^{x}$

然后计算$m':=c_{2}\cdot s^{-1}$,并将其映射回明文$m$,其中$s^{-1}$是$s$在群$G$上的逆元(例如:如果$G$是整数模n乘法群的一个子群,那么逆元就是模逆元)

解密算法是能够正确解密出明文的,因为

$c_{2}\cdot s^{-1}=m'\cdot h^{y}\cdot (g^{xy})^{-1}=m'\cdot g^{xy}\cdot g^{-xy}=m'.$

### Cramer-Shoup

- 公钥与私钥的产生

1. 从一个$q$阶循环群$G$中得到两个生成元$g_1,g_2$
2. 从${0,..,q-1}$中选择5个随机值$(x_1,x_2,y_1,y_2,z)$
3. $c=g_1^{x_1}*g_2^{x_2},d=g_1^{y_1}*g_2^{y_2},h=g_1^{z}$
4. 公开$PK=(c,d,h,G,q,g_1,g_2)$,保留$SK=(x_1,x_2,y_1,y_2,z)$

- 消息加密

从${0,..,q-1}$中选择一个随机值$k$

$u_1=g_1^{k},u_2=g_2^{k}$

$e=h^{k}*m$

$\alpha=H(u_1,u_2,e)$,$H$为hash函数

$v=c^{k}*d^{ka}$

$C=(u_1,u_2,e,v)$

返回$C$

- 消息解密

$\alpha=H(u_1,u_2,e)$,若$u_1^{x_1}*u_2^{x_2}*(u_1^{y_1}*u_2^{y_2})^{\alpha}=v$,则$m=e/(u_1^{z})$

### 安全模型IND-CPA

[https://en.wikipedia.org/wiki/Ciphertext_indistinguishability](https://en.wikipedia.org/wiki/Ciphertext_indistinguishability)

>选择明文攻击

1. 挑战者基于一些安全性参数k(例如,以位为单位的密钥大小)生成密钥对PK,SK,并将PK发布给对手

2. 对手提交两个等长的明文$m_{0},m_{1}$,挑战者选择$b\scriptstyle \in(0, 1)$,计算$C*=Enc(PK,M_{b})$,然后将$C*$交给对手

3. 对手输出猜测,即确定是对$m_{0}$还是对$m_{1}$的加密

假设正确率等于$0.5+\varepsilon$,如果$\varepsilon$的值可以被忽略,则说明该算法是安全的,反之,则是不安全的

RSA无法通过IND-CPA

ElGamal可以通过IND-CPA

Cramer-Shoup可以通过IND-CPA

### 安全模型IND-CCA(2)

[https://en.m.wikipedia.org/wiki/Adaptive_chosen-ciphertext_attack](https://en.m.wikipedia.org/wiki/Adaptive_chosen-ciphertext_attack)

>(自适应)选择密文攻击

1. 挑战者基于一些安全性参数k(例如,以位为单位的密钥大小)生成密钥对PK,SK,并将PK发布给对手

2. 对手可以执行任意数量的解密查询,当对手提交一个密文$C$进行查询时,挑战者将$Dec(SK,C)$的结果返回给对手

3. 对手提交两个等长的明文$m_{0},m_{1}$,挑战者选择$b\scriptstyle \in(0, 1)$,计算$C*=Enc(PK,M_{b})$,然后将$C*$交给对手

4. 在(IND-CCA)中,跳转到5,否则对手可以继续执行任意数量的解密查询,但不能解密$C*$

5. 对手输出猜测,即确定是对$m_{0}$还是对$m_{1}$的加密

如果没有对手在赢得上述比赛中具有不可忽略的优势,则该方案是IND-CCA1/IND-CCA2安全的

RSA(不可以通过IND-CCA?),不能通过IND-CCA2

ElGamal可以通过IND-CCA,不能通过IND-CCA2

Cramer-Shoup可以通过IND-CCA2