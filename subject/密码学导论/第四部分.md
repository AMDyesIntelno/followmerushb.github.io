>数字签名就是将公钥密码反过来使用,签名者将讯息用私钥加密(这是一种反用,因为通常公钥密码中私钥用于解密),然后公布公钥,验证者使用公钥将加密讯息解密并比对消息

数字签名具有以下特征:

- 收方能够确认或证实发方的签名,但不能伪造
- 发方发出签名的消息给收方后,就不能再否认他所签发的消息
- 收方对已收到的签名消息不能否认
- 第三者可以确认收发双方之间的消息传送,但不能伪造这一过程 

一个数字签名由如下算法组成:

- **密钥生成算法**$KeyGen(k)$:输入安全参数$k$,输出用户的公/私钥对$(pk,sk)$
- **签名算法**$Sign(sk,m)$:输入私钥$sk$和消息$m$,该算法输出签名$σ$
- **验证算法**$Verify(pk,σ,m)$:输入公钥$pk$和签名$σ$,若$σ$是针对$pk$和$m$的一个有效签名,该算法输出`1`,否则输出`0`

算法的正确性要求:对于任意$m$,均有$Verify(pk,Sign(sk,m))=1$成立

### RSA签名方案

- **密钥生成算法**$KeyGen(k)$:

1. 首先选取两个大素数$p$和$q$,计算$n=p*q$,其欧拉函数值为$\phi(n)=(p-1)*(q-1)$

2. 随机选取整数$e$,满足$gcd(e,\phi(n))=1$,并计算$d=e^{-1}(mod \phi(n))$

3. 公钥为$pk=(e,n)$,私钥为$sk=d$,可以对$p,q$进行销毁

- **签名算法**$Sign(sk=d,m)$:对于信息$m\scriptstyle \in Z_n$,其签名为$σ=H(m)^{d}(mod n)$

- **验证算法**$Verify(pk=e,σ,m)$:当接收者收到签名$σ$时,检验$m=σ^{e}(mod n)$是否成立,若成立则输出`1`,否则输出`0`

### ElGamal签名方案

- **密钥生成算法**$KeyGen(k)$:

设$p$是一个大素数,选取生成元$g\scriptstyle \in Z_p^{*}$,选取一个防碰撞的hash函数$H:{0,1}^*->Z_p^{*}$,随机选取$x\scriptstyle \in Z_p^{*}$,令$y=g^x(mod p)$,公钥为$pk=(G,p,g,y,H)$,私钥为$sk=x$

- **签名算法**$Sign(sk,m)$:选取随机数$0<k<p-1$且$gcd(k,p-1)=1$,计算$r≡g^
k(mod p)$和$s≡(H(m)-x*r)*k^{-1}(mod (p-1))$,输出签名$σ=(r,s)$

- **验证算法**$Verify(pk=e,σ,m)$:检查$g^{H(m)}≡y^{r}*r^{s}(mod p)$是否成立,若成立则输出`1`,否则输出`0`

### Schnorr签名方案

- **密钥生成算法**$KeyGen(k)$:选取一个阶为大素数$p$的群$G$,选取生成元$g\scriptstyle \in G$,选取一个防碰撞的hash函数$H:{0,1}^*->Z_p^{*}$,随机选取$x\scriptstyle \in Z_p^{*}$,将公钥设为$y=g^x$,私钥设为$sk=x$

- **签名算法**$Sign(sk,m)$:选取随机数$r\scriptstyle \in Z_p^{*}$计算$R=g^{r},e=H(m,R),s=(r-x*e)(mod p)$,输出签名$σ=(r,s)$

- **验证算法**$Verify(pk=σ,m)$:计算$R^{'}=g^{s}*y^{e}$,检查$H(m,R^{'})=e$是否成立,若成立则输出`1`,否则输出`0`

### 数字签名标准

- **密钥生成算法**$KeyGen(k)$:选取一个512至1024位的大素数$p$,且$p-1$有一个160比特的素因子$q$,选取一个模$p$的阶为$q$的数$g$,然后随机选取$x$满足$0<x<q$,将公钥设为$y=g^x$,私钥设为$sk=x$

- **签名算法**$Sign(sk,m)$:选取随机数$k$满足$0<k<q$,计算$r=(g^{k}(mod p))(mod q),s=(k^{-1}*(H(m)+x*r))(mod q)$,输出签名$σ=(r,s)$

- **验证算法**$Verify(pk=σ,m)$:计算$w=s^{-1}(mod q),u_1=H(m)*w(mod q),u_2=r*w(mod q)$,检查$(g^{u_1}*y^{u_2}(mod p))(mod q)=r$是否成立,若成立则输出`1`,否则输出`0`

### 安全模型EUF-CMA

1. 挑战者运行$KeyGen$算法生成公/私钥对$(pk,sk)$,将公钥$pk$交给对手

2. 对手进行一系列查询,对手提交一个消息$m_i$,挑战者进行$Sign(sk,m_i)$,将产生的签名$σ_i$交给对手

3. 对手输出$(m^{*},σ^{*})$,若$Verify(pk,σ^{*},m^{*})=1$,且对手未对$m^{*}$进行询问,则对手赢得该游戏

假设正确率等于$0.5+\varepsilon$,如果$\varepsilon$的值可以被忽略,则说明该签名方案是安全的,反之,则是不安全的