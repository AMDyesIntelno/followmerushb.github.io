### 基础知识

数据链路层使用的信道主要有以下两种类型:

- **点对点信道**:这种信道使用一对一的点对点通信方式

- **广播信道**:这种信道使用一对多的广播通信方式

!>注意区分`链路`和`数据链路`

`链路(link)或物理链路`就是从一个结点到相邻结点的一段物理线路(有线或无线),而中间没有任何其他的交换结点

在进行数据通信时,两台计算机之间的通信路径往往要经过许多段这样的链路,链路只是一条路径的组成部分
    
`数据链路(data link)或逻辑链路`则是另一个概念,这是因为当需要在一条线路上传送数据时,除了必须有一条物理线路外,还必须有一些必要的通信协议来控制这些数据的传输

若把实现这些协议的硬件和软件加到链路上,就构成了数据链路,最常用的方法是使用网络适配器(既有硬件,也包括软件)来实现这些协议,一般的适配器都包括了数据链路层和物理层这两层的功能

`帧`:链路层的协议数据单元

链路层把网络层传递的数据报封装成帧发送到链路上,以及从接收到的帧提取出数据包传递给网络层

---

?>点对点信道的链路层简化,每个结点只有下三层--网络层,数据链路层和物理层

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/step_of_link.jpg)

点对点信道的数据链路层在进行通信时的主要步骤如下:

- 结点A的数据链路层把网络层传递的数据报添加首部和尾部封装成链路层帧

- 结点A把封装好的帧发送给结点B的数据链路层

- 若结点B的数据链路层收到的帧无差错,则从收到的帧中提取出数据报传递给网络层,否则丢弃这个帧

---

?>链路层协议有许多种,但有三个基本问题:**封装成帧**,**透明传输**和**差错检测**

### 封装成帧

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/framing.jpg)

>**封装成帧**就是在一段数据的前后分别添加**首部**和**尾部**,接收端在收到物理层传输的比特流后,根据首部和尾部的标记,从收到的比特流中识别帧的开始和结束
>
>网络层的**数据报**传送到链路层就成为帧的**数据部分**,在帧的数据部分的前面和后面分别添加上首部和尾部,构成了一个完整的帧,这就是链路层的数据传送单元
>
>**一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度**,首部和尾部的一个重要作用就是进行帧定界(即确定帧的界限),此外,首部和尾部还包括许多必要的控制信息
>
>在发送帧时,是从帧首部开始发送的,为了提高帧的传输效率,应当使帧的数据部分长度尽可能地大于首部和尾部的长度
>
>但是,每一种链路层协议都规定了所能传送的帧的数据部分长度上限--`最大传送单元MTU(Maximum Transfer Unit)`

#### 帧定界符

当数据是由**可打印**的`ASCII`码组成的文本文件时,可以使用帧定界符

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SOH&EOT.jpg)

>帧定界可以使用特殊的帧定界符,控制字符`SOH(Start Of Header)`放在一帧的最前面,表示帧的首部开始,另一个控制字符`EOT(End Of Transmission)`表示帧的结束

!>SOH和EOT都是控制字符的名称,它们的十六进制编码分别是01(二进制是00000001)和04(二进制是00000100),SOH(或EOT)并不是S,O,H(或E,O,T)三个字符

>假定发送端在尚未发送完一个帧时突然出故障,中断了发送,但随后很快又恢复正常,于是重新从头开始发送刚才未发送完的帧
>
>由于使用了帧定界符,接收端就知道前面收到的数据是个不完整的帧(只有首部开始符SOH而没有传输结束符EOT),必须丢弃,而后面收到的数据有明确的帧定界符(SOH和EOT),因此这是一个完整的帧,应当收下

### 透明传输

?>允许传输系统或通道在其输入处接受未经修改的用户信息,并在其输出处传递形式或信息内容不变的相应用户信息,用户信息可以在传输系统内部进行更改,但是在输出之前,无需用户的参与即可恢复为原始形式

>讲人话:就是无论网络层数据报中的内容是什么都能放到链路层帧中进行传输

文本文件可以直接添加`帧定界符`

而非文本文件的数据中可能存在`SOH`或者`EOT`的二进制,所以要对非文本文件中的控制字符(`SOH`或`EOT`)进行转义

发送端的数据链路层在数据中出现控制字符`SOH`或`EOT`的前面插入一个转义字符`ESC`(其十六进制编码是`1B`),接收端的数据链路层在将数据送往网络层之前删除插入的转义字符,如果转义字符也出现数据当中,那么应在转义字符前面插入一个转义字符,当接收端收到连续的两个转义字符时,就删除其中前面的一个

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/byte_stuffing.jpg)

### 差错检测

比特差错:比特在传输过程中可能会产生差错(1可能会变成0,而0也可能变成1)

在一段时间内,传输错误的比特占所传输比特总数的比率称为`误码率BER(Bit Error Rate)`

#### 奇偶校验

1. 单比特奇偶校验

奇偶校验位有两种类型:偶校验位与奇校验位

以偶校验位来说,如果一组给定数据位中1的个数是奇数,补一个bit为1,使得总的1的个数是偶数,例:`0000001`,补一个bit为1,`00000011`

以奇校验位来说,如果一组数给定据位中1的个数是奇数,补一个bit为0,使得总的1的个数是奇数,例:`0000001`,补一个bit为0,`00000010`

!>注意奇校验无法产生全0代码,偶校验相对来说比较常用

2. 二维奇偶校验

|无差错|0|0|1|0|1|
|:---:|:---:|:---:|:---:|:---:|:---:|
|**1**|1|0|1|0|1|
|**0**|1|1|1|1|0|
|**1**|0|1|1|1|0|

|可纠正的单比特差错|0|`0`|1|0|1|
|:---:|:---:|:---:|:---:|:---:|:---:|
|**1**|1|0|1|0|1|
|**`0`**|1|`0`|1|1|0|
|**1**|0|1|1|1|0|

!>当二维奇偶校验遇到矩形错误时将无法检测和纠正

|无差错|0|0|1|0|
|:---:|:---:|:---:|:---:|:---:|
|**1**|1|1|0|1|
|**1**|1|0|1|1|
|**1**|1|1|1|0|
|**0**|1|0|1|0|

|不可纠正|0|0|1|0|
|:---:|:---:|:---:|:---:|:---:|
|**1**|1|1|0|1|
|**1**|1|`1`|`0`|1|
|**1**|1|`0`|`0`|0|
|**0**|1|0|1|0|

#### 循环冗余检测CRC

在发送端,先把数据划分为组,假定每组d个比特,设待传送的数据`D=101110(d=6)`

CRC运算就是在数据M的后面添加供差错检测用的n位冗余码,然后构成一个帧发送出去,一共发送(d+n)位

长度为`n+1`位的除数,长度为`n`位的余数

设除数`G=1001`,余数长度为`3`,则一共发送`9`位

>严格意义上来说并不是除,而是进行异或运算

|除数\商||||1|0|1|0|1|1||
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1001|`1`|`0`|`1`|`1`|`1`|`0`|0|0|0|`在D后面加n个0`|
||1|0|0|1|
|||0|1|0|1|
|||0|0|0|0|
||||1|0|1|0|
||||1|0|0|1|
|||||0|1|1|0|
|||||0|0|0|0|
||||||1|1|0|0|
||||||1|0|0|1|
|||||||1|0|1|0|
|||||||1|0|0|1|
|余数|||||||0|1|1|

得到的发送数据为`101110011`

在接收端,利用接收数据进行CRC校验,判断数据的正确性,当余数为0时,以**非常接近于1**的概率认为这些数据在传输过程中没有产生差错

|除数\商||||1|0|1|0|1|1|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1001|`1`|`0`|`1`|`1`|`1`|`0`|`0`|`1`|`1`|
||1|0|0|1|
|||0|1|0|1|
|||0|0|0|0|
||||1|0|1|0|
||||1|0|0|1|
|||||0|1|1|0|
|||||0|0|0|0|
||||||1|1|0|1|
||||||1|0|0|1|
|||||||1|0|0|1|
|||||||1|0|0|1|
|余数|||||||||0|

为了进行检错而添加的冗余码常称为`帧检验序列FCS(Frame Check Sequence)`

### 多路访问

传统意义上,广播是单向的(即一个固定的节点向许多接收节点传输),而计算机网络广播信道上的节点既能够接收也能够发送,因此存在**多路访问问题**

需要使用**多路访问协议**对多路访问行为进行规范

因为所有节点都能够传输帧,因此存在多个节点同时传输帧的情况,由此会产生**碰撞**

?>三类多接入协议:**信道划分协议**,**随机接入协议**,**轮流协议**

#### 信道划分协议

1. 时分多路复用TDM

一个支持`N`个节点的信道且信道的传输速率为`R`,TDM将时间划分为**时间帧**,并将时间帧划分为`N`个**时隙**

TDM消除了碰撞,使得每个节点在每个时间帧内得到的传输速率为`R/N`

但是,节点的速率被限制,即使其余时隙空闲,同时,节点必须等待其在传输序列中的轮次(即需要等待)

2. 频分多路复用FDM

FDM将速率为`R`的信道划分为不同的频段(每个频段具有`R/N`带宽),并把每个频率分配给`N`个节点

FDM具有和TDM一样的缺陷

3. 码分多址CDMA

CDMA对每个节点分配一种不同的编码,每个节点用其唯一编码来对其发送的数据进行编码

CDMA可以使不同的节点可以进行同时传输,且具有抗干扰特性

#### 随机接入协议

在随机接入协议中,一个传输节点总是以信道的全部速率`R`进行发送,当有碰撞时,涉及碰撞的每个节点反复重发它的帧,直到该帧无碰撞通过

但当一个节点经历一次碰撞时,不必立刻重发,而是**在重发之前等待一个随机时延**

1. 时隙ALOHA

基本假设:

- 所有的帧大小一致

- 时间轴划分为等长的时隙(slots),通常是传输一帧的时间

- 节点均只在时隙开始的时候传输

- 节点的行为是同步的

- 如果超过两个节点在一个时隙同时传输,则所有节点能侦测到碰撞

令`p`是一个概率,在每个节点中,时隙ALOHA的操作:

- 当节点有一个新帧要发送时,等到下一个时隙开始并在该时隙的传输整个帧

- 如果没有碰撞,该节点成功地传输帧,则无需考虑如何重传

- 如果有碰撞,该节点在时隙结束之前检测到该次碰撞,该节点以概率`p`在后续的每个时隙重传该帧,直到该帧被无碰撞地传输出去

>C=碰撞时隙,E=空闲时隙,S=成功时隙

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Slotted_ALOHA.png)

时隙多路访问协议的**效率**定义为:

?>当有大量的活跃节点且每个节点总有大量的帧要发送时,长期运行中成功时隙的份额

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Slotted_ALOHA_efficiency.png)

2. 载波侦听多路访问CSMA

发送数据前先监听广播信道,如果信道空闲,则发送整个帧;如果信道正忙,则延迟发送

**载波侦听**:一个节点在传输前先听信道,如果来自另一个节点的帧正向信道上发送,节点则等待直到检测到一小段时间没有传输,然后开始传输

**碰撞检测**:如果一个传输节点在传输时检测到另一个节点正在传输干扰帧,就停止传输,重复"侦听-当空闲时传输"这一循环

#### 轮流协议

1. 轮询协议

主节点以循环的方式轮询每个节点

存在的问题:

- 轮询的开销

- 延迟

- 主节点故障

2. 令牌传递协议

在这种协议中没有主节点,一个称为**令牌**的特殊帧在节点之间以某种固定的次序进行交换

存在的问题:

- 传递令牌的开销

- 延迟

- 单点故障(令牌本身)

### 链路层寻址

#### MAC地址

MAC地址(Media Access Control Address),称为媒体访问控制地址或物理地址

MAC地址长度为`6字节`共`48位`,共有`2^48`个MAC地址

前24位称为`组织唯一标志符(Organizationally Unique Identifier,即OUI)`,是由IEEE的注册管理机构给不同厂家分配的代码,用于区分不同的厂家

后24位是由厂家自己分配的,称为`扩展标识符`,同一个厂家生产的网卡中MAC地址后24位是不同的

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/MAC_address.png)

!>显然以上是理想情况,例如在华强北制作的网卡,显然不存在OUI,那么必然是伪造MAC地址甚至多个网卡同时使用一个MAC地址

>当某适配器要向目的适配器发送一个帧时,发送适配器将**目的适配器的MAC地址**插入到该帧中,并将该帧发送到局域网中
>
>有时,交换机会将一个入帧广播到其所有接口上,因此适配器会接收到并非向其发出的帧(泛洪)
>
>当适配器收到一个帧时会先检查该帧中的目的MAC地址是否与自身MAC地址匹配,如果匹配,则提取出封装的数据报将其传递给网络层,如果不匹配,则丢弃该帧
>
>有时,某发送适配器要让局域网上所有其他适配器来接收并处理其发送的帧,此时帧的目标适配器MAC地址应为`FF-FF-FF-FF-FF-FF`(广播地址)

MAC地址共分为3种,分别为**单播MAC地址**,**组播MAC地址**,**广播MAC地址**

- 单播MAC地址是指第一个字节的最低位是0的MAC地址

- 组播MAC地址是指第一个字节的最低位是1的MAC地址

- 广播MAC地址是指每个比特都是1的MAC地址(FF-FF-FF-FF-FF-FF),广播MAC地址是组播MAC地址的一个特例

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/mac_broadcast.png)

!>以**混杂方式**(promiscuous mode)工作的以太网适配器能够接收所有经过它的数据流,而不论其目的地址是否是它

#### 地址解析协议ARP

地址解析协议(Address Resolution Protocol)是一个通过**解析IP地址**来**寻找MAC地址**的网络传输协议

!>ARP是解决**同一个局域网**上的主机或路由器的IP地址和硬件地址的映射问题

每台主机或路由器中都包含一个ARP表,这张表包含IP地址到MAC地址的映射关系,同时包含该映射的有效期(TTL)

>假设A需要发送数据报给B
>
>若A的ARP表中已经有B的IP地址,则可以直接通过ARP表得知B的MAC地址并封装进链路层帧中
>
>若A的ARP表中没有B的IP地址,则需要通过ARP协议来解析这个地址
>
>首先,A构造一个`ARP分组(ARP packet)`,其中包含了发送方和接收方的IP地址以及MAC地址,ARP查询分组和相应分组具有相同的格式
>
>A使用MAC广播地址(FF-FF-FF-FF-FF-FF)发送ARP查询分组
>
>其余主机在接收到该ARP查询分组后,将检查自身的IP地址是否与ARP查询分组中的IP地址匹配,若不匹配,则不响应该ARP查询
>
>B接收到该分组后,更新自身的ARP表,向A作出回应并发送,此回应以单播的形式发出,A接收后更新ARP表

!>跨子网发送数据报

>先通过ARP获取当前子网的路由器MAC地址,并在要发送的帧中包含其他子网的主机的IP地址
>
>当该帧到达路由器后,读取该帧中包含的IP地址,通过查询路由器的转发表得到该IP地址对应的MAC地址,用该MAC地址重新封装帧并发送

### 以太网

#### 以太网的物理拓扑

- 总线拓扑(直至90年代中期)
    
    所有节点处于同一碰撞域(可能互相发生碰撞)

- 星形拓扑(现今)

    采用交换机

    每个"辐条"运行各自的以太网协议,各自组成碰撞域

在逻辑上采用总线型,在物理上采用星型

#### 以太网帧结构

|前导码|帧开始符|MAC目标地址|MAC源地址|802.1Q 标签(可选)|以太类型|数据|CRC|帧间距|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|`10101010`7个字节|`10101011`1个字节|6个字节|6个字节|(4个字节)|2个字节|46–1500个字节|4个字节|12个字节|

- 前同步码(前导码+帧开始符)

    前导码的7个字节均为`10101010`,帧开始符为`10101011`,前导码用于同步接收器的时钟,帧开始符标志着作为以太网数据包第一个字段的前同步码的结尾,并指示以太网帧的开始

- MAC目标地址&MAC源地址

    各自为6个字节的MAC地址

    如果适配器收到一个帧,其目的地址匹配自己的MAC地址,或是收到广播地址,则传输该帧的数据报至网络层,否则丢弃该帧

- 以太类型

    收到该帧之后,应传送给网络层的何种协议,多数情况下是IP协议,也有可能有其他的IP层协议

- 数据字段

    这个字段承载了数据报,以太网的最大传输单元(MTU)是1500字节,如果数据报超过1500字节,需要将该数据报分片

    最小长度为46字节,如果数据报小于46字节,则需要进行填充,当采用填充时,传递给网络层的数据包括数据报和填充部分,网络层使用数据报首部的长度来对填充部分进行去除

- CRC

    检测帧在传输过程中是否出现差错,如果有错,则丢弃该帧

- 帧间距

    当一个帧发送出去之后,发送方在下次发送帧之前,需要**再发送**至少12个字节的空闲线路状态码

!>无效的帧(对于检查出的无效MAC帧就简单地丢弃,以太网不负责重传丢弃的帧)

1. 帧长度不是整数字节

2. CRC校验失败

3. 数据字段的长度不在46~1500字节之间

4. **MAC帧**(数据字段+两个MAC地址+以太类型+CRC)长度不在64~1518字节之间

### 交换机

交换机具有**过滤**和**转发**的功能

过滤是决定一个帧应该转发到某个接口还是应当将其丢弃

转发是决定一个帧应该被导向哪个接口,并将该帧移动到该接口

交换机的过滤和转发借助于**交换机表**

交换机表中包含一个MAC地址,一个通向该MAC的的接口,以及该表项出现在表中的时间

>假定目的地址为DD-DD-DD-DD-DD-DD的帧从交换机的接口X到达,交换机用DD-DD-DD-DD-DD-DD索引自身的交换表
>
>若表中没有该MAC地址,则交换机向除了接口x外的所有接口转发该帧(泛洪)
>
>若表中该MAC地址与x接口相关联,则无需进行转发,交换机将该帧过滤并丢弃
>
>若表中该MAC地址与其他非x接口相关联,则向该接口转发该帧

交换机是**自学习**的

1. 交换机表初始为空

2. 对于在每个接口接收到的每个**入帧**,该交换机在表中存储:源MAC地址,该帧到达的接口,到达时间

3. 如果在一段时间后,没有接收到以某个地址作为**源地址**的帧,则从表中删除该地址

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(2).PNG)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(3).PNG)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(4).PNG)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(5).PNG)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(6).PNG)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(7).PNG)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(8).PNG)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/self_learn%20(1).PNG)

### 虚拟局域网(VLAN/Virtual LAN)

虚拟局域网(VLAN)技术具有以下主要优点:

- 改善了性能
- 简化了管理
- 降低了成本
- 改善了安全性

划分虚拟局域网的方法

- 基于交换机端口
- 基于计算机网卡的MAC地址
- 基于协议类型
- 基于IP子网地址
- 基于高层应用或服务

>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符(802.1Q 标签),称为VLAN标记(tag),用来指明该帧属于哪一个虚拟局域网
>
>插入VLAN标记得出的帧称为802.1Q帧或带标记的以太网帧