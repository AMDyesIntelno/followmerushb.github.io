## 数据平面

### 虚电路与数据报的对比

?>网络层应该向传输层提供怎样的服务?("面向连接"or"无连接")

关键在于:在计算机通信中,可靠交付应当由谁来负责?是网络还是端系统?

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VCorData.jpg)

|对比的方面|虚电路服务|数据报服务|
|:---:|:---:|:---:|   
|思路|可靠通信应当由网络来保证|可靠通信应当由用户主机来保证|
|连接的建立|必须有|不需要|
|终点地址|仅在连接建立阶段使用,每个分组使用短的虚电路号|每个分组都有终点的完整地址|
|分组的转发|属于同一条虚电路的分组均按照同一路由进行转发|每个分组独立选择路由进行转发|
|当结点出故障时|所有通过出故障的结点的虚电路均不能工作|出故障的结点可能会丢失分组,一些路由可能会发生变化|
|分组的顺序|总是按发送顺序到达终点|到达终点的时间不一定按发送顺序|
|端到端的差错处理和流量控制|可以由网络负责,也可以由用户主机负责|由用户主机负责|

!>网络层向上只提供简单灵活的,无连接的,尽最大努力交付的数据报服务

### 网络层的功能

网络层的作用在于将分组从一台发送主机传输到一台接受主机,因此网络层需要有**转发**和**路由选择**功能

- 转发

当一个分组到达某个路由器的一条输入链路时,该路由器要将该分组移动到恰当的输出链路(转发是在数据平面中实现的唯一功能)

- 路由选择

当分组从发送方流向接收方是,网络层决定这些分组所采用的路径,计算这些路径的算法称为**路由选择算法**(路由选择在控制平面实现)

### 路由器

#### 路由器架构

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/router.png)

- 输入端口

    1. 在路由器中执行终结入物理链路的物理层功能

    2. 与位于入链路的数据链路层交互,执行数据链路层功能

    3. 执行查询功能,通过查询转发表决定路由器的输出端口,到达的分组通过路由器的交换结构转发到输出端口

    ![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/input_port.png)

    ***输入端口队列***

    ![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/input_port_queue.png)

    左图:输出端口拥塞,只能发送一个红色的分组,所以下面的那个红色分组被阻塞了
    右图:过了一个分组时间后,绿色的分组就遇到了HOL阻塞

- 交换结构

    交换结构将路由器的输入端口连接到输出端口

    ![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/switch_fabric.png)

- 输出端口

    输出端口存储从交换结构接收的分组,并通过执行链路层和物理层的功能在输出链路上传输分组

- 路由选择处理器

    路由选择处理器执行控制平面功能

#### 分组调度策略

1. 先进先出(FIFO)

先进先出调度规则按照分组到达输出链路队列的相同次序(即,进入顺序为123,离开顺序也为123)来选择分组在链路上的传输

2. 优先权排队(priority queuing)

在优先权排队规则下,到达输出链路的分组被分类放入输出队列中的优先权类,基于优先级的调度,高优先级的排队分组最先发送

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/priority_queuing.png)

>如图所示,分组1,3,4的优先级较高,当1到达时,链路空闲,直接传输,当2,3到达时,虽然2先到达,但3的优先级较高,所以3先传输

3. 循环排队规则(round robin queuing discipline)

在循环排队规则下,分组向使用优先权排队那样被分类,但在类之间并不存在严格的服务优先权,循环调度器在这些类之间轮流提供服务

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/round_robin.png)

>如图所示,分组1,2,4属于第一类,分组3,5属于第二类,当1到达时,链路空闲,直接传输,当2,3到达时,虽然2先到达,但2属于第一类,链路调度器对第二类的分组进行查找,3属于第二类,对3进行传输,链路调度器对第一类的分组进行查找,2属于第一类,对2进行传输

### 网际协议(IP)

#### IPv4数据报格式

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ipv4_packet.png)

- 版本号(version)

    这4个比特规定了数据报的IP协议版本,通过版本号,路由器能够确定如何解释IP数据报的剩余部分

- 首部长度(IHL)

    一个IPv4数据报可包含可变数量的选项(Options),选项包括在IPv4数据报首部中,故需要用这4比特来确定IP数据报中有效载荷(Data)实际开始的地方,首部长度说明首部有多少32位字(4字节),这个字段的最小值是5(二进制0101),相当于5\*4=20字节,最大十进制值是15,相当于15*4=60字节,大多数IP数据报不包含此项,因此一般的首部长度为**20字节**

- 服务类型(TOS)

    服务类型包含在IPv4首部中,用于区分不同类型的IP数据报(例如,对实时数据报和非实时流量进行区分)

- 数据报长度(Total length)

    IP数据报的总长度,该字段长度为16比特,IP数据报的理论最大长度为65535字节,但IP数据报的长度受到以太网帧承载能力的限制(不超过1500字节)

- 标识(Identification),标志(Flags),片位移(Frgment offset)

    与IP分片有关

    **标识**:一个计数器,用来产生IP数据报的标识

    **标志**:占3位,目前只有前两位有意义,标志字段的最低位是MF(More Fragment),`MF=1`表示后面还有分片,`MF=0`表示最后一个分片,标志字段中间的一位是DF(Don't Fragment),只有当`DF=0`时才允许分片

    **片偏移**:占13位,标识较长的分组在分片后某片在原分组中的相对位置,片偏移以**8个字节**为偏移单位

    ![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP_data_divide1.png)

    ![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP_data_divide2.png)

    ![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP_data_divide3.png)

- 存活时间(TTL)

    TTL字段用来确保数据报不会永远在网络中循环,每当一台路由器处理数据报时,该字段的值减少1,若TTL为0,则丢弃该数据报

- 协议(Protocol)

    该字段值指示了IP数据报的数据部分应交给哪个特定的传输层协议(6为交给TCP,17为交给UDP)

- 首部校验和(Header checksum)

    用于帮助路由器检测收到的IP数据报中的比特错误,只对首部查错,不包括数据部分

    假设某个IPv4数据包报头为:`E3 4F 23 96 44 27 99 F3 [00 00]`,用中括号括起来的就是checksum

    checksum的初始值自动被设置为0

    然后,以16bit为单位,两两相加,对于该例子,即为:`E34F + 2396 + 4427 + 99F3 = 1E4FF`
    
    若计算结果大于`0xFFFF`,则将高16位加到低16位上,对于该例子,即为`0xE4FF + 0x0001 = E500`
    
    然后,将该值取反,即为`~(E500)=1AFF`

    此时,发送包已经计算完毕,下面,我们再来计算接收方的信息

    若数据包正常,那么,它的报头应该是这样:`E3 4F 23 96 44 27 99 F3 1A FF`

    此时,前18bytes的内容不变,等于E500,然后,将`E500`与刚刚计算的校验和`1AFF`相加

    若计算结果为`FFFF`,那么,该数据包正常,没有错误

- 源IP(Source address)和目的IP(Destination address)

    字面意思

- 选项(Options)

    选项字段允许IP首部被拓展

- 数据(Data)(即有效载荷)

    IP数据报的数据字段包含要交付给目的地的原属曾报文段,该数据字段也可以承载其他类型的数据

#### IPv4编址

IPv4地址就是给互联网上的每一台主机(或路由器)的每一个**接口**分配一个在全世界范围内是唯一的32位的标识符

每个IPv4地址的长度为**32比特**,因此共有**2^32**个IPv4地址

IPv4地址的书写常采用**点分十进制记法**

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/dotted_decimal_notation.jpg)

IP地址的编址方法共经过了三个历史阶段

- 分类IP地址

- 划分子网

- 构成超网

##### 分类IP地址

>将IP地址划分为若干个固定类,每一类地址都由两个固定长度的字段组成,其中第一个字段是网络号(net-id),它标志主机(或路由器)所连接到的网络,一个网络号在整个互联网范围内必须是唯一的
>
>第二个字段是主机号(host-id),它标志该主机(或路由器),一台主机号在它前面的网络号所指明的网络范围内必须是唯一的,因此,一个IP地址在整个互联网范围内是唯一的

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/net&host_ip.jpg)

>A类地址的网络号字段占1个字节,只有7位可供使用(该字段的第一位已固定为0),可指派的网络号是126个,减2的原因是:第一,IP地址中的全0代表当前设备的IP,可以代表本机的所有IP地址;第二,网络号为127(即01111111)保留作为本地软件环回测试,用于本机中各个应用之间的网络交互
>
>A类地址的主机号占3个字节,因此每一个A类网络中的最大主机数是2^24–2,即16777214,减2的原因是:全0的主机号字段表示该IP地址是本机所连接到的单个网络地址(一主机的IP地址为5.6.7.8,则该主机所在的网络地址就是5.0.0.0),而全1的主机号字段表示该网络上的所有主机(A类地址1.1.255.255表示在网络1.1.0.0上的所有主机,而地址0.0.0.35则表示在这个网络上主机号为35的主机),整个A类地址空间共有2^31个地址
>
>B类地址的网络号字段占2个字节,但前面两位(10)已经固定了,只剩下14位可以进行分配,但B类地址128.0.0.0不进行指派,可以指派的B类最小网络地址是128.1.0.0,因此B类地址可指派的网络数为2^14−1,即16383,B类地址的每一个网络上的最大主机数是2^16–2,即65534
>
>C类地址有3个字节的网络号字段,最前面的3位是(110),还有21位可以进行分配,但C类网络地址192.0.0.0不进行指派,可以指派的C类最小网络地址是192.0.1.0,因此C类地址可指派的网络总数是2^21−1,即2097151,每一个C类地址的最大主机数是2^8–2,即254

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/range_ip.jpg)

!>一般不使用的特殊的IP地址

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/special_ip.png)

!>IP地址与MAC地址

1. IP地址与MAC地址是不同的地址

2. MAC地址是数据链路层和物理层使用的地址

3. IP地址是网络层和以上各层使用的地址,是一种逻辑地址(IP地址通过软件实现)

##### 划分子网

在IP地址中增加了一个**子网号字段**,使两级的IP地址变成为三级的IP地址,从主机号借用若干个位作为子网号,而主机号也相应减少了若干个位

1. 根据IP数据报的目的网络号,先找到连接在该网络上的路由器

2. 此路由器在收到IP数据报后,再按目的网络号和子网号找到目的子网

3. 最后将IP数据报交付目的主机

##### 子网掩码

从一个IP数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分,使用子网掩码可以找出IP地址中的子网部分

子网掩码长度为32位,左边部分为**一连串1**,对应于网络号和子网号,右边部分的**一连串0**,对应于主机号

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/subnetmask.jpg)

把IP地址的子网掩码和收到的数据报的目的IP地址进行逐位与(and),得到子网的网络地址

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ABC_subnetmask.jpg)

!>B类地址的子网划分选择(使用固定长度子网)

|子网号的位数|子网掩码|子网数(2^位数-2,因为要剔除全0和全1)|每个子网的主机数(2^剩余位数-2,因为要剔除网络地址和广播地址)|
|:---:|:---:|:---:|:---:|
|2|255.255.192.0|2|16382|
|3|255.255.224.0|6|8190|
|4|255.255.240.0|14|4094|
|5|255.255.248.0|30|2046|
|6|255.255.252.0|62|1022|
|7|255.255.254.0|126|510|
|8|255.255.255.0|254|254|
|9|255.255.255.128|510|126|
|10|255.255.255.192|1022|62|
|11|255.255.255.224|2046|30|
|12|255.255.255.240|4094|14|
|13|255.255.255.248|8190|6|
|14|255.255.255.252|16382|2|

!>子网号的位数中没有0,1,15和16这四种情况

>当子网号的位数为0,则说明不进行子网划分
>
>当子网号的位数为1,当子网号为0时,会产生子网的网络地址与父网络的网络地址相同的情况(例如,IP地址为`172.16.1.1`,子网掩码为`255.255.128.0`,子网地址为`172.16.0.0`,网络地址为`172.16.0.0`,因此造成冲突)
>
>当子网号的位数为1,当子网号为1时,会产生子网的广播地址与父网络的广播地址相同的情况(例如,IP地址为`172.16.128.1`,子网掩码为`255.255.128.0`,子网的广播地址为`172.16.255.255`,父网络的广播地址也为`172.16.255.255`,因此造成冲突)
>
>当子网号的位数为15,相当于主机号剩余一位,当取值为0时,实际为该子网的网络地址,取值为1时实际为该子网的广播地址
>
>当子网号的位数为16,则说明没有主机号

##### VLSM(可变长子网掩码)

VLSM是可变长子网掩码,通过向主机位借位的方式,实现地址的精确编址以及提高网络的灵活性与可用性,随着掩码的变长,一大块IP被不断分割成越来越小的地址块

>假设某公司财务部需要100台主机,市场部需要60台主机,项目部需求10台主机,有一个`192.168.1.0/24`的网段,对其进行划分
>
>对于财务部,100<=2^x-2,x_min=7,因此将网段划分为`192.168.1.0/25`和`192.168.1.128/25`,财务部使用`192.168.1.0/25`
>
>对于市场部,60<=2^x-2,x_min=6,因此将`192.168.1.128/25`划分为`192.168.1.128/26`和`192.168.1.192/26`,市场部使用`192.168.1.128/26`
>
>对于项目部,10<=2^x-2,x_min=4,因此将`192.168.1.192/26`划分为`192.168.1.192/28`,`192.168.1.208/28`,`192.168.1.224/28`和`192.168.1.240/28`,项目部使用`192.168.1.192/28`

##### CIDR(无类别域间路由)

CIDR是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法

CIDR消除了传统的A类,B类和C类地址以及划分子网的概念,使用各种长度的网络前缀来代替分类地址中的网络号和子网号,IP地址从三级编址又回到了两级编址

CIDR使用斜线记法,在IP地址后面加上斜线`/`,然后写上网络前缀所占的位数

CIDR把网络前缀都相同的连续的IP地址组成一个**CIDR地址块**,只要知道CIDR地址块中的任何一个地址,就可以知道这个地址块的起始地址和最大地址,以及地址块中的地址数

>已知IP地址`128.14.35.7/20`是某CIDR地址块中的一个地址
>
>`128.14.35.7/20`=**10000000 00001110 0010**0011 00000111
>
>最小地址:`128.14.32.0`即`10000000 00001110 0010 0000 00000000`
>
>最大地址:`128.14.47.255`即`10000000 00001110 0010 1111 11111111`

!>前缀路由聚合

四个网段:`192.168.0.0/24`,`192.168.1.0/24`,`192.168.3.0/24`,`192.168.4.0/24`

>11000000.10101000.00000000.0 - 192.168.0.0
>
>11000000.10101000.00000001.0 - 192.168.1.0
>
>11000000.10101000.00000010.0 - 192.168.2.0
>
>11000000.10101000.00000011.0 - 192.168.3.0

四个网段的前22位二进制相同,进行前缀聚合后,这四个网段对外显示为`192.168.0.0/22`

!>最长前缀匹配

假设在路由器上有两个网段`192.168.1.0/24`和`192.168.0.0/22`,若收到一个数据报,目的IP为`192.168.1.128`,在查找路由表时得到两个匹配结果,此时应当从匹配结果中选择具有最长网络前缀的路由

`192.168.1.128`与`11111111 11111111 11111111 00000000`逐位与,得到`192.168.1.0/24`

`192.168.1.128`与`11111111 11111111 11111100 00000000`逐位与,得到`192.168.0.0/22`

根据最长前缀匹配的原理,应当选择`192.168.1.0/24`,把收到的数据报转发到此网络中

##### 专用IP

- 10.0.0.0/8 : 10.0.0.0 - 10.255.255.255

- 172.16.0.0/12 : 172.16.0.0 - 172.31.255.255

- 192.168.0.0/16 : 192.168.0.0 - 192.168.255.255

#### NAT(网络地址转换)

用于在本地网络中使用私有地址,在连接互联网时转而使用全局IP地址的技术

##### 基本网络地址转换(Basic NAT)

!>仅支持地址转换,不支持端口映射

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/nat.jpg)

NAT路由器收到从专用网内部的主机A发往互联网上主机B的IP数据报:源IP地址是`192.168.0.3`,而目的IP地址是`213.18.2.4`

NAT路由器把IP数据报的源IP地址`192.168.0.3`,转换为新的源IP地址(即NAT路由器的全球IP地址)`172.38.1.5`,然后转发出去

因此,主机B收到这个IP数据报时,以为A的IP地址是172.38.1.5

当B给A发送应答时,IP数据报的目的IP地址是NAT路由器的IP地址`172.38.1.5`

B并不知道A的专用地址`192.168.0.3`,实际上,即使知道了,也不能使用,因为互联网上的路由器都不转发目的地址是专用网本地IP地址的IP数据报

当NAT路由器收到互联网上的主机B发来的IP数据报时,还要进行一次IP地址的转换

通过NAT地址转换表,就可把IP数据报上的旧的目的IP地址`172.38.1.5`,转换为新的目的IP地址`192.168.0.3`(主机A真正的本地IP地址)

!>由于改变了IP源地址,在重新封装数据包时候必须重新计算校验和,网络层以上的只要涉及到IP地址的头部校验和都要重新计算

无端口号NAT地址转换表

|方向|字段|旧的IP地址|新的IP地址|
|:---:|:---:|:---:|:---:|
|出|源IP地址|192.168.0.3|172.38.1.5|
|入|目的IP地址|172.38.1.5|192.168.0.3|
|出|源IP地址|192.168.0.7|172.38.1.6|
|入|目的IP地址|172.38.1.6|192.168.0.7|

##### 网络地址端口转换(NAPT)

!>支持端口的映射,并允许多台主机共享一个公网IP地址

NAPT维护一个带有IP以及端口号的NAT表

|内网IP|外网IP|
|:---:|:---:|
|192.168.1.55:5566|219.152.168.222:9200|
|192.168.1.59:80|219.152.168.222:9201|
|192.168.1.59:4465|219.152.168.222:9202|

#### IPv6数据报格式

IPv6所引进的主要变化如下:

- 更大的地址空间:IPv6把地址从IPv4的32位增大到4倍,即增大到128位
  
- 扩展的地址层次结构:IPv6由于地址空间很大,因此可以划分为更多的层次

- 灵活的首部格式:IPv6数据报的首部和IPv4的并不兼容,IPv6定义了许多可选的扩展首部,不仅可提供比IPv4更多的功能,而且还可提高路由器的处理效率

- 改进的选项:IPv6允许数据报包含有选项的控制信息,因而可以包含一些新的选项,但IPv6的首部长度是固定的,其选项放在有效载荷中

- 允许协议继续扩充

- 支持即插即用(即自动配置),因此IPv6不需要使用DHCP

- 支持资源的预分配:IPv6支持实时视像等要求保证一定的带宽和时延的应用

- IPv6首部改为8字节对齐(即首部长度必须是8字节的整数倍),原来的IPv4首部是4字节对齐

IPv6数据报由两大部分组成,即基本首部(base header)和后面的有效载荷(payload)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ipv6.jpg)

- 版本(version):占4位,它指明了协议的版本,对IPv6该字段是6

- 通信量类(traffic class):占8位,这是为了区分不同的IPv6数据报的类别或优先级,目前正在进行不同的通信量类性能的实验,

- 流标号(flow label):占20位,用于QoS服务质量控制

- 有效载荷长度(payload length):占16位,指明IPv6数据报除基本首部以外的字节数(所有扩展首部都算在有效载荷之内),这个字段的最大值是64KB(65535字节)

- 下一个首部(next header):占8位,相当于IPv4的协议字段或可选字段
	- 当没有扩展首部时,下一个首部字段的作用和IPv4的协议字段一样,它的值指出了基本首部后面的数据应交付IP层上面的哪一个高层协议(例如:6或17分别表示应交付传输层TCP或UDP)
	- 当出现扩展首部时,下一个首部字段的值就标识后面第一个扩展首部的类型

- 跳数限制(hop limit):占8位,用来防止数据报在网络中无限期地存在,源点在每个数据报发出时即设定某个跳数限制(最大为255跳),每个路由器在转发数据报时,要先把跳数限制字段中的值减1,当跳数限制的值为零时,就要把这个数据报丢弃(相当于IPv4中的TTL)

#### IPv6编址

IPv6二进位制下为`128`位长度,以`16`位为一组,每组以冒号`:`隔开,可以分为8组,每组以4位十六进制方式表示,例如`2001:0db8:86a3:08d3:1319:8a2e:0370:7344`是一个合法的IPv6地址

类似于IPv4的点分十进制,同样也存在点分十六进制的写法,将8组4位十六进制地址的冒号去除后,每位以点号`.`分组,例如`2001:0db8:85a3:08d3:1319:8a2e:0370:7344`则记为`2.0.0.1.0.d.b.8.8.5.a.3.0.8.d.3.1.3.1.9.8.a.2.e.0.3.7.0.7.3.4.4`

同时IPv6在某些条件下可以省略:

- 每项数字前导的0可以省略,省略后前导数字仍是0则继续,例如下组IPv6是等价的

`2001:0DB8:02de:0000:0000:0000:0000:0e13`

`2001:DB8:2de:0000:0000:0000:0000:e13`

`2001:DB8:2de:000:000:000:000:e13`

`2001:DB8:2de:00:00:00:00:e13`

`2001:DB8:2de:0:0:0:0:e13`

- 可以用双冒号`::`表示一组0或多组连续的0,但只能出现一次:
    - 如果四组数字都是零,可以被省略,遵照以上省略规则,下面这两组IPv6都是相等的

    1. `2001:DB8:2de:0:0:0:0:e13`

        `2001:DB8:2de::e13`

    2. `2001:0DB8:0000:0000:0000:0000:1428:57ab`

        `2001:0DB8:0000:0000:0000::1428:57ab`

        `2001:0DB8:0:0:0:0:1428:57ab`

        `2001:0DB8:0::0:1428:57ab`

        `2001:0DB8::1428:57ab`

`2001::25de::cade`是非法的,因为双冒号出现了两次,它有可能是下种情形之一,造成无法推断

`2001:0000:0000:0000:0000:25de:0000:cade`

`2001:0000:0000:0000:25de:0000:0000:cade`

`2001:0000:0000:25de:0000:0000:0000:cade`

`2001:0000:25de:0000:0000:0000:0000:cade`

如果这个地址实际上是IPv4的地址,后32位可以用10进制数表示,因此`::ffff:192.168.89.9`等于`::ffff:c0a8:5909`

另外,`::ffff:1.2.3.4`格式叫做IPv4映射地址

IPv4位址可以很容易的转化为IPv6格式,如果IPv4的一个地址为`135.75.43.52`(十六进制为`0x874B2B34`),它可以被转化为`0000:0000:0000:0000:0000:FFFF:874B:2B34`或者`::FFFF:874B:2B34`

同时,还可以使用混合符号(IPv4-compatible address),则地址可以为`::ffff:135.75.43.52`

##### IPv6地址的分类

IPv6地址可分为三种:

- 单播(unicast)地址

    单播地址标示一个网络接口,协议会把送往地址的数据包送往给其接口,IPv6的单播地址可以有一个代表特殊地址名字的范畴,如链路本地地址(link local address)和唯一区域地址(ULA,unique local address),单播地址包括可聚类的全球单播地址,链路本地地址等

- 任播(anycast)地址

    Anycast会有一组接收节点的地址列表,但指定为Anycast的数据包,只会发送给距离最近或发送成本最低(根据路由表来判断)的其中一个接收地址,当该接收地址收到数据包并进行回应,且加入后续的传输,该接收列表的其他节点,会知道某个节点地址已经回应了,它们就不再加入后续的传输作业

- 多播(multicast)地址

    多播地址也称组播地址,多播地址也被指定到一群不同的接口,送到多播地址的数据包会被发送到所有的地址,多播地址由皆为一的字节起始,即它们的前置为`FF00::/8`,其第二个字节的最后四个比特用以标明"范畴"

## 控制平面

### 路由选择算法

通过`图`来描述路由选择问题,`G=(N,E)`,表示一个具有`N`个节点(顶点数量)和`E`条边(弧数量)的集合,其中每一条边取自N的一对节点

一条边具有一个用于表示其开销的值(权重),对于`E`中的任一条边,使用`c(x,y)`表示节点`x`和节点`y`间边的开销,如果节点对`(x,y)`不属于`E`,则`c(x,y)=∞`

显然,当图为无向图时,边`(x,y)`与边`(y,x)`相同且`c(x,y)=c(y,x)`,当图为有向图时,边在不同的方向可能具有不同的开销

路由选择算法的目标是找出从源到目的地间的最低开销路径

#### 链路状态路由选择算法

?>Dijkstar算法

记号定义:

- `D(v)`:到本次迭代时,从源节点到目的节点`v`的最短路径开销

- `p(v)`:从源节点到v节点沿着当前最短路径的前一节点

- `N'`:节点子集,记录已经确定最短路径的节点

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/route_graph.png)

使用上图中的网络,从`u`开始计算到各个目的节点的最短路径开销

|步骤|`N'`|`D(v)`,`p(v)`|`D(w)`,`p(w)`|`D(x)`,`p(x)`|`D(y)`,`p(y)`|`D(z)`,`p(z)`|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|u|2,u|5,u|1,u|∞|∞|
|1|ux|2,u|4,x||2,x|∞|
|2|uxy|2,u|3,y|||4,y|
|3|uxyv||3,y|||4,y|
|4|uxyvw|||||4,y|
|5|uxyvwz||||||

#### 距离向量路由选择算法

每个路由器只知道和自己相邻的路由器的存在,以及和相邻路由器间的链路的成本信息

Bellman-Ford等式(动态规划的思想)

用`d_𝑥 (𝑦)`表示"从x到y的最佳路径的成本",则有`d_𝑥 (𝑦)=min┬𝑣⁡{𝑐(𝑥,𝑣)+d_𝑣 (𝑦)}`("x到v的成本"+"从v到y的最佳路径的成本")

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Bellman_Ford_Sample.png)

`d_v(z)=5`,`d_x(z)=3`,`d_w(z)=3`

`c(u,v)=2`,`c(u,x)=1`,`c(u,w)=5`

根据BF方程得到`d_u(z)={2+5,3+1,3+5}=4`,与Dijkstra算法得出的结果相同

使用DV算法时,每个节点`x`维护下列路由选择信息

- 对于每个邻居`v`,从`x`到直接相连邻居`v`的开销为`c(x,v)`

- 节点`x`的路由向量,包含`x`到所有目的地的开销估计值

- 每个邻居的距离向量

每个节点不时地向每个邻居发送其距离向量副本,当节点`x`从它的任意一个邻居`w`接收到一个新的距离向量时,将该向量保存,并利用BF方程对距离向量进行更新

如果距离向量发生了变化,则节点`x`向它的每个邻居发送新的距离向量,继而让邻居更新它们自己的距离向量

只要所有节点继续交换距离向量,每个开销估计`Dx(y)`收敛到`dx(y)`(`x`到`y`的实际最低开销路径的开销)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Bellman_Ford_Table.png)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/good_news_travels_fast.png)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/bad_news_travels_slow.png)

利用`毒性逆转`来避免路由环路:如果`z→y→x`,则z向y通告`𝐷_𝑧 (𝑥)=∞`(即使z知道𝐷_𝑧 (𝑥)是某个数值),这样可以防止y重新经过z到达x,但是有一些路由环路的产生是无法通过毒性逆转来避免的

### 路由选择协议

#### 内部网关协议

##### 路由信息协议

`RIP (Routing Information Protocol)`

RIP是一种分布式的**基于距离向量**的路由选择协议

RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录(这是一组距离,即"距离向量",这里的"距离"实际上指的是"最短距离")

RIP协议将"距离"定义如下:

从一路由器到**直接连接**的网络的距离定义为`1`

从一路由器到**非直接连接**的网络的距离定义为所经过的路由器数加`1`

RIP协议中的"距离"也称为"跳数",因为每经过一个路由器,跳数加`1`

RIP认为好的路由就是它通过的路由器的数目少,RIP允许**一条路径**最多只能包含`15`个路由器,因此距离等于16时即相当于不可达,因此RIP只适用于小型互联网

RIP协议的特点是:

- 仅和相邻路由器交换信息,如果两个路由器之间的通信不需要经过另一个路由器,那么这两个路由器就是相邻的,RIP协议规定,不相邻的路由器不交换信息
- 路由器交换的信息是当前本路由器所知道的全部信息,即自己现在的路由表
- 按固定的时间间隔交换路由信息

RIP协议使用的距离向量算法

对每一个相邻路由器发送过来的RIP报文,进行以下步骤:

- 对地址为`X`的相邻路由器发来的RIP报文,先修改此报文中的所有项目:把"下一跳"字段中的地址都改为`X`,并把所有的"距离"字段的值加`1`(这样做是为了便于进行本路由表的更新,假设从位于地址X的相邻路由器发来的RIP报文的某一个项目是:`Net2,3,Y`,意思是"我经过路由器Y到网络Net2的距离是3",那么本路由器就可推断出:"我经过X到网络Net2的距离应为`3+1=4`"于是,本路由器就把收到的RIP报文的这一个项目修改为`Net2,4,X`,作为下一步和路由表中原有项目进行比较时使用(只有比较后才能知道是否需要更新)收到的项目中的Y对本路由器是没有用的,因为Y不是本路由器的下一跳路由器地址),每一个项目都有三个关键数据,即:到目的网络`N`,距离`d`,下一跳路由器`X`

- 对修改后的RIP报文中的每一个项目,进行以下步骤:

    if原来的路由表中没有目的网络`N`,则把该项目添加到路由表中(表明这是新的目的网络,应当加入到路由表中,假设本路由表中没有到目的网络`Net2`的路由,那么在路由表中就要加入新的项目`Net2,4,X`)
    
    else(即在路由表中有目的网络`N`,这时就再查看下一跳路由器地址)
        
    if下一跳路由器地址是`X`,则把收到的项目替换原路由表中的项目(以最新的消息为准,到目的网络的距离有可能增大或减小,但也可能没有改变,不管原来路由表中的项目是`Net2,3,X`还是`Net2,5,X`,都要更新为现在的`Net2,4,X`)
    
    else(即这个项目是:到目的网络`N`,但下一跳路由器不是`X`)
            
    if收到的项目中的距离`d`小于路由表中的距离,则进行更新(若路由表中已有项目`Net2,5,P`,就要更新为`Net2,4,X`缩短距离)
    
    else什么也不做

- 若一定的时间间隔后还没有收到相邻路由器的更新路由表,则把此相邻路由器记为不可达的路由器,即把距离置为`16`

- 返回

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RIP1.png)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RIP2.png)

RIP2报文由首部和路由部分组成

RIP2报文中的路由部分由若干个路由信息组成,每个路由信息需要用`20`个字节,地址族标识符(又称为地址类别)字段用来标志所使用的地址协议

一个RIP报文最多可包括`25`个路由,因而RIP报文的最大长度是`4+20x25=504`字节,如超过则必须再用一个RIP报文来传送

RIP协议的优缺点

- 优点:

    实现简单,开销较小

- 缺点:

    RIP限制了网络的规模,它能使用的最大距离为15(16表示不可达)

    路由器之间交换的路由信息是路由器中的完整路由表,因而随着网络规模的扩大,开销也就增加

    "坏消息传播得慢",使更新过程的收敛时间过长

##### 开放最短路径优先

`OSPF (Open Shortest Path First)`

采用分布式的链路状态协议

OSPF协议的特点是:

- 向本自治系统中所有路由器发送信息,这里使用的方法是洪泛法(路由器通过所有输出端口向所有相邻的路由器发送信息,而每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器))
- 发送的信息就是与本路由器相邻的所有路由器的链路状态,但这只是路由器所知道的部分信息,"链路状态"说明本路由器都和哪些路由器相邻,以及该链路的"度量"("度量"可用来表示费用,距离,时延,带宽等)
- 只有当链路状态发生变化时,路由器才用洪泛法向所有路由器发送此信息 

由于各路由器之间频繁地交换链路状态信息,因此所有的路由器最终都能建立一个**链路状态数据库**(link-state database),这个数据库实际上就是全网的拓扑结构图,这个拓扑结构图在全网范围内是一致的

为了使OSPF能够用于规模很大的网络,OSPF将一个自治系统再划分为若干个更小的范围,叫做**区域**

每一个区域都有一个`32`位的区域标识符

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF_Sample.png)

OSPF使用层次结构的区域划分,在上层的区域叫做主干区域,主干区域的标识符规定为`0.0.0.0`,主干区域的作用是用来连通其他在下层的区域

OSPF**不用UDP**而是直接用**IP数据报**传送

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF_Head.png)

OSPF分组使用`24`字节的**固定长度首部**

- 类型1,问候(Hello)分组
- 类型2,数据库描述(Database Description)分组
- 类型3,链路状态请求(Link State Request)分组
- 类型4,链路状态更新(Link State Update)分组,用洪泛法对全网更新链路状态
- 类型5,链路状态确认(Link State Acknowledgment)分组

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RIPvsOSPF.png)

#### 外部网关协议

边界网关协议`BGP`是不同自治系统的路由器之间交换路由信息的协议

BGP只能是力求寻找一条能够到达目的网络且比较好的路由(不能兜圈子),而并非要寻找一条最佳路由,BGP采用了路径向量路由选择协议

在配置BGP时,每一个自治系统的管理员要选择至少一个路由器作为该自治系统的"BGP发言人"

一个BGP发言人与其他AS的BGP发言人要交换路由信息,就要先建立TCP连接(端口号为179),然后在此连接上交换BGP报文以建立BGP会话(session),利用BGP会话交换路由信息,如增加了新的路由,或撤销过时的路由,以及报告出差错的情况等等,使用TCP连接交换路由信息的两个BGP发言人,彼此成为对方的邻站(neighbor)或对等站(peer)

一个BGP发言人除了必须运行BGP协议外,还必须运行该自治系统所使用的内部网关协议

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BGP_speaker.png)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BGPswap1.png)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/BGPswap2.png)

### ICMP协议

网际控制报文协议ICMP(Internet Control Message Protocol)

ICMP不是高层协议(ICMP报文是装在IP数据报中,作为其中的数据部分),而是IP层的协议,ICMP报文作为IP层数据报的数据,加上数据报的首部,组成IP数据报发送出去

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMPform.png)

ICMP报文的种类有两种,即ICMP**差错报告**报文和ICMP**询问**报文

|ICMP报文种类|类型的值|ICMP报文的类型|
|:---:|:---:|:---:|
|差错报告报文|3|终点不可达|
||11|时间超过|
||12|参数问题|
||5|改变路由|
|询问报文|8或0|回送请求或回答|
||13或14|时间戳请求或回答|

- 终点不可达:当路由器或主机不能交付数据报时就向源点发送终点不可达报文
- 时间超过:当路由器收到生存时间为零的数据报时,除丢弃该数据报外,还要向源点发送时间超过报文,当终点在预先规定的时间内不能收到一个数据报的全部数据报片时,就把已收到的数据报片都丢弃,并向源点发送时间超过报文
- 参数问题:当路由器或目的主机收到的数据报的首部中有的字段的值不正确时,就丢弃该数据报,并向源点发送参数问题报文
- 改变路由(重定向):路由器把改变路由报文发送给主机,让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)

![](https://cdn.jsdelivr.net/gh/followmerushb/followmerushb.github.io@master/static/subject/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMPerror.png)

- 对ICMP差错报告报文不再发送ICMP差错报告报文
- 对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文
- 对具有多播地址的数据报都不发送ICMP差错报告报文
- 对具有特殊地址(如`127.0.0.0`或`0.0.0.0`)的数据报不发送ICMP差错报告报文