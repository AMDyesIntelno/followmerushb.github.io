# 《汇编语言》王爽

## 第一章 基础知识

微型机存储器的存储单元可以存储一个Byte

微机存储器的容量是以字节为最小单位来计算的

8个`bit`组成一个`byte`

```
1KB=1024B
1MB=1024KB
1GB=1024MB
1TB=1024GB
```

存储单元从`零`开始顺序编号

**总线**:在计算机中专门链接CPU和其他芯片的导线

|总线分类|信息类型|内容|
|:---:|:---:|:---:|
|地址总线|地址信息|存储单元的地址|
|控制总线|控制信息|器件的选择,读或写的命令|
|数据总线|数据信息|读或写的数据|

### 地址总线

CPU通过地址总线来指定存储单元,**地址总线的宽度决定了CPU的寻址能力**

一个CPU有N根地址线,则CPU最多可以寻找2^N个内存单元

>一个具有16根地址线的CPU,可以寻址2^16=65536Byte=64KB内存

### 数据总线

CPU与其他器件之间的数据传送通过数据总线进行,**数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量**

8根数据总线一次可以传送一个8位2进制数据(8bits=1Byte),即一个字节

>8086的数据总线宽度位16根(一次传输2Byte数据),从内存中读取1024字节的数据,至少要读512次

### 控制总线

CPU对外部器件的控制通过控制总线进行,**控制总线的宽度决定了CPU对系统中其他器件的控制能力**

## 第二章 寄存器

### 通用寄存器

寄存器就是CPU中用来存储数据的地方

寄存器有多大取决于CPU: 

32位CPU: 8,16,32

64位CPU: 8,16,32,64

- 8个32位通用寄存器

```
EAX: 返回值存放
EBX: 寻址存放基地址
ECX: 计数器
EDX: 余数存放
ESP,EBP: 栈顶指针,EBP指向系统栈最上面一个栈帧的底部
ESI,EDI: 源索引寄存器,指向源串/目标串
特殊寄存器
EIP: CPU即将执行指令地址,无法作为他用
```

- 16位通用寄存器

```
就是32位寄存器的拆分
AX
BX
CX
DX
SP
BP
SI
DI
```

- 8位通用寄存器

就是16位寄存器的拆分,与16位又不相同,因为他有高八位和低八位

AH可以理解为(A Hight)高八位,也就是16位寄存器的前两位

AL可以理解为(A Low)低八位,后两位

以此类推

SP,BP,SI,DI没有八位寄存器

### 数据尺寸

- 字节: 记为`byte`,保存在8位寄存器中

- 字: 记为`word`,保存在16位寄存器中

- 双字: 记为`dword`,保存在32位寄存器中

### 大小端

数值`0x1A2B3C4D`想要在计算机中正确使用,就必须要考虑在内存中将其对应的四个字节合理存储

假设内存的地址都是从低到高分配的,那么对于一个数值多个字节顺序存储就有两种存储方式:

1. 数值的高位字节存放在内存的低地址端,低位字节存放在内存的高地址端:

```
内存低地址 --------------------> 内存高地址

0x1A   |  0x2B   |  0x3C   |   0x4D

高位字节 <-------------------- 低位字节
```

大端模式:即高位字节放在内存的低地址端,低位字节放在内存的高地址端

![](https://img.misaka.gq/Notes/subject/汇编语言/大端模式.png)

2. 数值的低位字节存放在内存的低地址端,高位字节存放在内存的高地址端:

```
内存低地址 --------------------> 内存高地址

0x4D   |  0x3C   |  0x2B   |   0x1A

低位字节 --------------------> 高位字节
```

小端模式:即低位字节放在内存的低地址端,高位字节放在内存的高地址端

![](https://img.misaka.gq/Notes/subject/汇编语言/小端模式.png)

### 物理地址

8086有20位地址总线,可以寻址1MB内存,但8086是16位CPU,一次传输的地址为16位

8086采用将两个16位地址合成一个20位的物理地址

当8086CPU要读写内存时:

1. CPU中提供两个16位地址,一个是**段地址**,另一个是**偏移地址**

2. 段地址和偏移地址通过内部总线送入**地址加法器**

3. 地址加法器将两个16位地址合成为一个20位的物理地址

4. 地址加法器通过内部总线将20位物理地址送入输入输出控制电路

5. 输入输出控制电路将20位物理地址送到地址总线

6. 20位物理地址被地址总线传送到存储器

地址加法器采用**物理地址=段地址x16(段地址左移4位)+偏移地址**的方法将段地址和偏移地址合成物理地址

CPU可以用不同的段地址和偏移地址形成同一个物理地址,显然一个物理地址可以对应多个逻辑地址

```
21F60=2000*16+1F60
      2100*16+0F60
      21F0*16+0060
```

偏移地址位16位,16位地址的寻址能力位64KB,所以一个段的长度最大为64KB

>如果给定一个段地址,仅通过变化偏移地址来进行寻址,最多可定位`2^16`个内存单元