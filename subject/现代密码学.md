?> 现代密码学

## 第一部分

### 基本概念

!>数据的安全基于密钥而不是算法的保密

- 明文(plaintext): 没有加密的信息
- 密文(ciphertext): 加密后的信息
- 加密变换(encryption): 从明文到密文的变换
- 解密变换(decryption): 从密文到明文的变换
- 密钥(key): 加密和解密是在密钥控制下进行的

>密码分类体制

- 对称密码(单钥密码, 私钥密码): 加密密钥与解密密钥相同,如:分组密码,流密码
- 非对称密码(双钥密码,公钥密码): 加密密钥与解密密钥不同

>密码体制至少应满足的两个条件

- 在已知明文`m`和加密密钥$k_1$时,计算$c=E_{k_1}(m)$容易,在已知密文`c`和解密密钥$k_2$时,计算$m=D_{k_2}(c)$容易
- 在不知解密密钥`k2`时,不可能由密文`c`恢复出明文`m`

>密码体制的攻击方法

- 穷举攻击: 通过试遍所有的密钥来进行破译
  
  对抗: 可增大密钥的数量

- 统计分析攻击: 通过分析密文和明文的统计规律来破译

  对抗: 设法使明文和密文的统计规律不一样

- 解密变换攻击: 针对加密变换的数学基础,通过数学求解设法找到解密变换

  对抗: 选用具有坚实的数学基础和足够复杂的加密算法

>常见攻击情况

- 唯密文攻击: 密码分析者仅知道一些密文
- 已知明文攻击: 密码分析者知道一些明文和相应的密文
- 选择明文攻击: 密码分析者可以选择一些明文,并得到相应的密文
- 选择密文攻击: 密码分析者可以选择一些密文,并得到相应的明文

>安全原则

- 无条件安全的(不可破译的):一次一密方案(一次一密乱码本)
- 计算上安全的:流密码、分组密码,公钥密码

密码算法只要满足以下两条准则之一就行:

- 破译密文的代价超过被加密信息的价值
- 破译密文所花的时间超过信息的有用期

满足以上两个准则的密码算法在实际中是可用的

### 古典密码体制

#### 置换密码

?>栅栏密码

```python
def encrypt(plaintext, n):
    plaintext = plaintext.replace(" ", "")
    ciphertext = ""
    for i in range(n):
        s = ""
        for j in range(len(plaintext)):
            if j % n == i:
                s += plaintext[j]
        ciphertext += s
        # print(s)
    return ciphertext


def decrypt(ciphertext, n):
    per_str_len = len(ciphertext) // n + 1
    per_str = []
    for i in range(n):
        per_str.append(ciphertext[i * per_str_len:(i + 1) * per_str_len])
    # print(per_str)
    plaintext = ""
    for i in range(len(per_str[0])):
        for j in range(n):
            if i < len(per_str[j]):
                plaintext += per_str[j][i]
    return plaintext


text = input()
n = int(input())
print(encrypt(text, n))
print(decrypt(encrypt(text, n), n))
```

```
The quick brown fox jumps over the lazy dog
2
Teucbonojmsvrhlzdghqikrwfxupoeteayo
Thequickbrownfoxjumpsoverthelazydog
```

>把要加密的明文分成N个一组,然后把每组的第1个字符组合,每组第2个字符组合...每组的第N(最后一个分组可能不足N个)个字符组合,最后把他们全部连接起来就是密文

明文:`The quick brown fox jumps over the lazy dog`

去空格:`Thequickbrownfoxjumpsoverthelazydog`

分组:`Th eq ui ck br ow nf ox ju mp so ve rt he la zy do g`

第一组:`Teucbonojmsvrhlzdg`

第二组:`hqikrwfxupoeteayo`

密文:`Teucbonojmsvrhlzdghqikrwfxupoeteayo`

?>埃特巴什码

```python
dic = {"a": "z", "b": "y", "c": "x", "d": "w", "e": "v", "f": "u", "g": "t", "h": "s", "i": "r", "j": "q", "k": "p",
       "l": "o", "m": "n", "n": "m", "o": "l", "p": "k", "q": "j", "r": "i", "s": "h", "t": "g", "u": "f", "v": "e",
       "w": "d", "x": "c", "y": "b", "z": "a", "A": "Z", "B": "Y", "C": "X", "D": "W", "E": "V", "F": "U", "G": "T",
       "H": "S", "I": "R", "J": "Q", "K": "P", "L": "O", "M": "N", "N": "M", "O": "L", "P": "K", "Q": "J", "R": "I",
       "S": "H", "T": "G", "U": "F", "V": "E", "W": "D", "X": "C", "Y": "B", "Z": "A"}


def encrypt(plaintext):
    global dic
    ciphertext = ""
    for i in plaintext:
        if i in dic.keys():
            ciphertext += dic[i]
        else:
            ciphertext += i
    return ciphertext


def decrypt(ciphertext):
    global dic
    plaintext = ""
    for i in ciphertext:
        if i in dic.keys():
            plaintext += dic[i]
        else:
            plaintext += i
    return plaintext


text = input()
print(encrypt(text))
print(decrypt(encrypt(text)))
```

```
the quick brown fox jumps over the lazy dog
gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt
the quick brown fox jumps over the lazy dog
```

>埃特巴什码(Atbash Cipher)是一种以字母倒序排列作为特殊密钥的替换加密

#### 单表代换密码

1. 加法密码

$f(a_i)=b_i=a_j$

$j=i+k(mod n),(a_i∈A,0<k<n)$

?>凯撒密码

```python
def encrypt(plaintext, n):
    ciphertext = ""
    for i in plaintext:
        if 97 <= ord(i) <= 122:
            ciphertext += chr((ord(i) - 97 + n) % 26 + 97)
        elif 65 <= ord(i) <= 90:
            ciphertext += chr((ord(i) - 65 + n) % 26 + 65)
        else:
            ciphertext += i
    return ciphertext


def decrypt(ciphertext):
    plaintext = []
    for i in range(26):
        temp_text = ""
        for j in ciphertext:
            if 97 <= ord(j) <= 122:
                temp_text += chr((ord(j) - 97 + 26 - i) % 26 + 97)
            elif 65 <= ord(j) <= 90:
                temp_text += chr((ord(j) - 65 + +26 - i) % 26 + 65)
            else:
                temp_text += j
        plaintext.append(temp_text)
    return plaintext


text = input()
print(encrypt(text, 1))
plaintext = decrypt(encrypt(text, 1))
for i in range(26):
    print("ROT%d"%i,plaintext[i])
```

```
The quick brown fox jumps over the lazy dog
Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph
ROT0 Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph
ROT1 The quick brown fox jumps over the lazy dog
ROT2 Sgd pthbj aqnvm enw itlor nudq sgd kzyx cnf
ROT3 Rfc osgai zpmul dmv hsknq mtcp rfc jyxw bme
ROT4 Qeb nrfzh yoltk clu grjmp lsbo qeb ixwv ald
ROT5 Pda mqeyg xnksj bkt fqilo kran pda hwvu zkc
ROT6 Ocz lpdxf wmjri ajs ephkn jqzm ocz gvut yjb
ROT7 Nby kocwe vliqh zir dogjm ipyl nby futs xia
ROT8 Max jnbvd ukhpg yhq cnfil hoxk max etsr whz
ROT9 Lzw imauc tjgof xgp bmehk gnwj lzw dsrq vgy
ROT10 Kyv hlztb sifne wfo aldgj fmvi kyv crqp ufx
ROT11 Jxu gkysa rhemd ven zkcfi eluh jxu bqpo tew
ROT12 Iwt fjxrz qgdlc udm yjbeh dktg iwt apon sdv
ROT13 Hvs eiwqy pfckb tcl xiadg cjsf hvs zonm rcu
ROT14 Gur dhvpx oebja sbk whzcf bire gur ynml qbt
ROT15 Ftq cguow ndaiz raj vgybe ahqd ftq xmlk pas
ROT16 Esp bftnv mczhy qzi ufxad zgpc esp wlkj ozr
ROT17 Dro aesmu lbygx pyh tewzc yfob dro vkji nyq
ROT18 Cqn zdrlt kaxfw oxg sdvyb xena cqn ujih mxp
ROT19 Bpm ycqks jzwev nwf rcuxa wdmz bpm tihg lwo
ROT20 Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn
ROT21 Znk waoiq hxuct lud pasvy ubkx znk rgfe jum
ROT22 Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl
ROT23 Xli uymgo fvsar jsb nyqtw sziv xli pedc hsk
ROT24 Wkh txlfn eurzq ira mxpsv ryhu wkh odcb grj
ROT25 Vjg swkem dtqyp hqz lworu qxgt vjg ncba fqi
```

>凯撒密码是一种替换加密,明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文

2. 乘法密码

$f(a_i)=b_i=a_j$

$j=i*k(mod n),(a_i∈A,0<k<n,gcd(k,n)=1)$

3. 仿射密码

>乘法密码和加法密码的结合

$f(a_i)=b_i=a_j$

$j=k_0+i*k_1(mod n),(a_i∈A,0<k_0<n,gcd(k_1,n)=1)$

