?> 现代密码学

## 换位加密

### 栅栏密码

```python
def encrypt(plaintext, n):
    plaintext = plaintext.replace(" ", "")
    ciphertext = ""
    for i in range(n):
        s = ""
        for j in range(len(plaintext)):
            if j % n == i:
                s += plaintext[j]
        ciphertext += s
        # print(s)
    return ciphertext


def decrypt(ciphertext, n):
    per_str_len = len(ciphertext) // n + 1
    per_str = []
    for i in range(n):
        per_str.append(ciphertext[i * per_str_len:(i + 1) * per_str_len])
    # print(per_str)
    plaintext = ""
    for i in range(len(per_str[0])):
        for j in range(n):
            if i < len(per_str[j]):
                plaintext += per_str[j][i]
    return plaintext


text = input()
n = int(input())
print(encrypt(text, n))
print(decrypt(encrypt(text, n), n))
```

```
The quick brown fox jumps over the lazy dog
2
Teucbonojmsvrhlzdghqikrwfxupoeteayo
Thequickbrownfoxjumpsoverthelazydog
```

>把要加密的明文分成N个一组,然后把每组的第1个字符组合,每组第2个字符组合...每组的第N(最后一个分组可能不足N个)个字符组合,最后把他们全部连接起来就是密文

明文:`The quick brown fox jumps over the lazy dog`

去空格:`Thequickbrownfoxjumpsoverthelazydog`

分组:`Th eq ui ck br ow nf ox ju mp so ve rt he la zy do g`

第一组:`Teucbonojmsvrhlzdg`

第二组:`hqikrwfxupoeteayo`

密文:`Teucbonojmsvrhlzdghqikrwfxupoeteayo`

## 替换加密

### 埃特巴什码

```python
dic = {"a": "z", "b": "y", "c": "x", "d": "w", "e": "v", "f": "u", "g": "t", "h": "s", "i": "r", "j": "q", "k": "p",
       "l": "o", "m": "n", "n": "m", "o": "l", "p": "k", "q": "j", "r": "i", "s": "h", "t": "g", "u": "f", "v": "e",
       "w": "d", "x": "c", "y": "b", "z": "a", "A": "Z", "B": "Y", "C": "X", "D": "W", "E": "V", "F": "U", "G": "T",
       "H": "S", "I": "R", "J": "Q", "K": "P", "L": "O", "M": "N", "N": "M", "O": "L", "P": "K", "Q": "J", "R": "I",
       "S": "H", "T": "G", "U": "F", "V": "E", "W": "D", "X": "C", "Y": "B", "Z": "A"}


def encrypt(plaintext):
    global dic
    ciphertext = ""
    for i in plaintext:
        if i in dic.keys():
            ciphertext += dic[i]
        else:
            ciphertext += i
    return ciphertext


def decrypt(ciphertext):
    global dic
    plaintext = ""
    for i in ciphertext:
        if i in dic.keys():
            plaintext += dic[i]
        else:
            plaintext += i
    return plaintext


text = input()
print(encrypt(text))
print(decrypt(encrypt(text)))
```

```
the quick brown fox jumps over the lazy dog
gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt
the quick brown fox jumps over the lazy dog
```

>埃特巴什码(Atbash Cipher)是一种以字母倒序排列作为特殊密钥的替换加密

### 凯撒密码

```python
def encrypt(plaintext, n):
    ciphertext = ""
    for i in plaintext:
        if 97 <= ord(i) <= 122:
            ciphertext += chr((ord(i) - 97 + n) % 26 + 97)
        elif 65 <= ord(i) <= 90:
            ciphertext += chr((ord(i) - 65 + n) % 26 + 65)
        else:
            ciphertext += i
    return ciphertext


def decrypt(ciphertext):
    plaintext = []
    for i in range(26):
        temp_text = ""
        for j in ciphertext:
            if 97 <= ord(j) <= 122:
                temp_text += chr((ord(j) - 97 + 26 - i) % 26 + 97)
            elif 65 <= ord(j) <= 90:
                temp_text += chr((ord(j) - 65 + +26 - i) % 26 + 65)
            else:
                temp_text += j
        plaintext.append(temp_text)
    return plaintext


text = input()
print(encrypt(text, 1))
plaintext = decrypt(encrypt(text, 1))
for i in range(26):
    print("ROT%d"%i,plaintext[i])
```

```
The quick brown fox jumps over the lazy dog
Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph
ROT0 Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph
ROT1 The quick brown fox jumps over the lazy dog
ROT2 Sgd pthbj aqnvm enw itlor nudq sgd kzyx cnf
ROT3 Rfc osgai zpmul dmv hsknq mtcp rfc jyxw bme
ROT4 Qeb nrfzh yoltk clu grjmp lsbo qeb ixwv ald
ROT5 Pda mqeyg xnksj bkt fqilo kran pda hwvu zkc
ROT6 Ocz lpdxf wmjri ajs ephkn jqzm ocz gvut yjb
ROT7 Nby kocwe vliqh zir dogjm ipyl nby futs xia
ROT8 Max jnbvd ukhpg yhq cnfil hoxk max etsr whz
ROT9 Lzw imauc tjgof xgp bmehk gnwj lzw dsrq vgy
ROT10 Kyv hlztb sifne wfo aldgj fmvi kyv crqp ufx
ROT11 Jxu gkysa rhemd ven zkcfi eluh jxu bqpo tew
ROT12 Iwt fjxrz qgdlc udm yjbeh dktg iwt apon sdv
ROT13 Hvs eiwqy pfckb tcl xiadg cjsf hvs zonm rcu
ROT14 Gur dhvpx oebja sbk whzcf bire gur ynml qbt
ROT15 Ftq cguow ndaiz raj vgybe ahqd ftq xmlk pas
ROT16 Esp bftnv mczhy qzi ufxad zgpc esp wlkj ozr
ROT17 Dro aesmu lbygx pyh tewzc yfob dro vkji nyq
ROT18 Cqn zdrlt kaxfw oxg sdvyb xena cqn ujih mxp
ROT19 Bpm ycqks jzwev nwf rcuxa wdmz bpm tihg lwo
ROT20 Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn
ROT21 Znk waoiq hxuct lud pasvy ubkx znk rgfe jum
ROT22 Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl
ROT23 Xli uymgo fvsar jsb nyqtw sziv xli pedc hsk
ROT24 Wkh txlfn eurzq ira mxpsv ryhu wkh odcb grj
ROT25 Vjg swkem dtqyp hqz lworu qxgt vjg ncba fqi
```

>凯撒密码是一种替换加密,明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文

### 简单替换密码

```python
def encrypt(plaintext, key):
    ciphertext = ""
    for i in plaintext:
        if 97 <= ord(i) <= 122:
            ciphertext += key[ord(i) - 97]
        elif 65 <= ord(i) <= 90:
            ciphertext += key[ord(i) - 65 + 26]
        else:
            ciphertext += i
    return ciphertext


def decrypt(ciphertext, key):
    plaintext = ""
    for i in ciphertext:
        if i in key:
            if 0 <= key.index(i) <= 25:
                plaintext += chr(97 + key.index(i))
            else:
                plaintext += chr(65 - 26 + key.index(i))
        else:
            plaintext += i
    return plaintext


key = list("phqgiumeaylnofdxjkrcvstzwbPHQGIUMEAYLNOFDXJKRCVSTZWB")
text = input()
print(encrypt(text, key))
print(decrypt(encrypt(text,key),key))
```

```
abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
phqgiumeaylnofdxjkrcvstzwb PHQGIUMEAYLNOFDXJKRCVSTZWB
abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
```

>简单换位密码(Simple Substitution Cipher)加密方式是以每个明文字母被与之唯一对应且不同的字母替换的方式实现的,它不同于恺撒密码,因为密码字母表的字母不是简单的移位,而是完全是混乱的

当没有密钥时,可以通过[词频分析](https://quipqiup.com/)进行破解







## BASE64

```cpp
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

const char *base64_table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

char *base64_encode(const char *in) {
    char temp[3];
    int count = 0, posi = 0;
    char *out = (char *) malloc(((strlen(in) + 2) / 3 * 4 + 1) * sizeof(char));
    for (int i = 0; i < strlen(in); ++i) {
        temp[count++] = in[i];
        if (count == 3) {
            out[posi++] = base64_table[temp[0] >> 2];//取第一个字符的前六位
            out[posi++] = base64_table[((temp[0] & 0x3) << 4) | (temp[1] >> 4)];//取第一个字符的后两位,取第二个字符的前四位
            out[posi++] = base64_table[((temp[1] & 0xF) << 2) | (temp[2] >> 6)];//取第二个字符的后四位,取第三个字符的前两位
            out[posi++] = base64_table[temp[2] & 0x3F];//取第三个字符的后六位
            count = 0;
        }
    }
    if (count) {
        out[posi++] = base64_table[temp[0] >> 2];//取第一个字符的前六位
        if (count == 1) {
            out[posi++] = base64_table[(temp[0] & 0x3) << 4];//取第一个字符的后两位
            out[posi++] = '=';
        } else {
            out[posi++] = base64_table[((temp[0] & 0x3) << 4) | (temp[1] >> 4)];//取第一个字符的后两位,取第二个字符的前四位
            out[posi++] = base64_table[(temp[1] & 0xF) << 2];//取第二个字符的后四位,取第三个字符的前两位
        }
        out[posi++] = '=';
    }
    out[posi] = '\0';
    return out;
}

char *base64_decode(const char *in) {
    int out_len = strlen(in) / 4 * 3;
    if (in[strlen(in) - 1] == '=') {
        out_len--;
    }
    if (in[strlen(in) - 2] == '=') {
        out_len--;
    }
    char temp[4];
    int count = 0, posi = 0;
    char *out = (char *) malloc((out_len + 1) * sizeof(char));
    for (int i = 0; i < strlen(in); i++) {
        if (in[i] >= 'A' && in[i] <= 'Z') {
            temp[count++] = in[i] - 'A';
        } else if (in[i] >= 'a' && in[i] <= 'z') {
            temp[count++] = in[i] - 'a' + 26;
        } else if (in[i] >= '0' && in[i] <= '9') {
            temp[count++] = in[i] - '0' + 52;
        } else if (in[i] == '+') {
            temp[count++] = 62;
        } else if (in[i] == '/') {
            temp[count++] = 63;
        } else {
            temp[count++] = 0;
        }
        if (count == 4) {
            out[posi++] = (temp[0] << 2) | (temp[1] >> 4);
            out[posi++] = (temp[1] << 4) | (temp[2] & 0x3C) >> 2;
            out[posi++] = (temp[2] << 6) | temp[3];
            count = 0;
        }
    }
    out[posi] = '\0';
    return out;
}

int main() {
    const char *a = "the quick brown fox jumps over the lazy dog";
    printf("%s\n", base64_encode(a));
    const char *b = "dGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZw==";
    printf("%s", base64_decode(b));
    return 0;
}
```

>Base64是一种基于64个可打印字符来表示二进制数据的表示方法,转换的时候,将`3`字节的数据,先后放入一个`24`位的缓冲区中,先来的字节占高位,数据不足3字节的话,于缓冲器中剩下的比特用`0`补足,每次取出`6`比特(3\*8=4\*6),按照其值选择`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`中的字符作为编码后的输出,直到全部输入数据转换完成

## 分组密码

### Tea

```cpp
#include <stdint.h>
#include <stdio.h>

void encrypt(uint32_t *v, const uint32_t *k) {
    uint32_t v0 = v[0], v1 = v[1], sum = 0, i;
    uint32_t delta = 0x9e3779b9;
    uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];
    for (i = 0; i < 32; i++) {
        sum += delta;
        v0 += ((v1 << 4u) + k0) ^ (v1 + sum) ^ ((v1 >> 5u) + k1);
        v1 += ((v0 << 4u) + k2) ^ (v0 + sum) ^ ((v0 >> 5u) + k3);
    }
    v[0] = v0;
    v[1] = v1;
}

void decrypt(uint32_t *v, const uint32_t *k) {
    uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i;
    uint32_t delta = 0x9e3779b9;
    uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];
    for (i = 0; i < 32; i++) {
        v1 -= ((v0 << 4u) + k2) ^ (v0 + sum) ^ ((v0 >> 5u) + k3);
        v0 -= ((v1 << 4u) + k0) ^ (v1 + sum) ^ ((v1 >> 5u) + k1);
        sum -= delta;
    }
    v[0] = v0;
    v[1] = v1;
}

int main() {
    char plaintext[] = "asdfghjkqwertyui";
    uint32_t ciphertext[4] = {0};
    uint32_t key[4] = {0x30343842, 0x31353943, 0x32364044, 0x33374145};
    for (int i = 0; i <= 15; i += 4) {//4*8=32
        ciphertext[i / 4] += plaintext[i];
        ciphertext[i / 4] <<= 8u;
        ciphertext[i / 4] += plaintext[i + 1];
        ciphertext[i / 4] <<= 8u;
        ciphertext[i / 4] += plaintext[i + 2];
        ciphertext[i / 4] <<= 8u;
        ciphertext[i / 4] += plaintext[i + 3];
    }
    printf("%X %X %X %X\n", ciphertext[0], ciphertext[1], ciphertext[2], ciphertext[3]);
    encrypt(ciphertext, key);
    encrypt(ciphertext + 2, key);
    printf("%X %X %X %X\n", ciphertext[0], ciphertext[1], ciphertext[2], ciphertext[3]);
    decrypt(ciphertext, key);
    decrypt(ciphertext + 2, key);
    printf("%X %X %X %X\n", ciphertext[0], ciphertext[1], ciphertext[2], ciphertext[3]);
    return 0;
}
```

