?> 密码学导论

## 第一部分

### 基本概念

!>数据的安全基于密钥而不是算法的保密

- 明文(plaintext): 没有加密的信息
- 密文(ciphertext): 加密后的信息
- 加密变换(encryption): 从明文到密文的变换
- 解密变换(decryption): 从密文到明文的变换
- 密钥(key): 加密和解密是在密钥控制下进行的

>密码分类体制

- 对称密码(单钥密码, 私钥密码): 加密密钥与解密密钥相同,如:分组密码,流密码
- 非对称密码(双钥密码,公钥密码): 加密密钥与解密密钥不同

>密码体制至少应满足的两个条件

- 在已知明文`m`和加密密钥$k_1$时,计算$c=E_{k_1}(m)$容易,在已知密文`c`和解密密钥$k_2$时,计算$m=D_{k_2}(c)$容易
- 在不知解密密钥`k2`时,不可能由密文`c`恢复出明文`m`

>密码体制的攻击方法

- 穷举攻击: 通过试遍所有的密钥来进行破译
  
  对抗: 可增大密钥的数量

- 统计分析攻击: 通过分析密文和明文的统计规律来破译

  对抗: 设法使明文和密文的统计规律不一样

- 解密变换攻击: 针对加密变换的数学基础,通过数学求解设法找到解密变换

  对抗: 选用具有坚实的数学基础和足够复杂的加密算法

>常见攻击情况

- 唯密文攻击: 密码分析者仅知道一些密文
- 已知明文攻击: 密码分析者知道一些明文和相应的密文
- 选择明文攻击: 密码分析者可以选择一些明文,并得到相应的密文
- 选择密文攻击: 密码分析者可以选择一些密文,并得到相应的明文

>安全原则

- 无条件安全的(不可破译的):一次一密方案(一次一密乱码本)
- 计算上安全的:流密码、分组密码,公钥密码

密码算法只要满足以下两条准则之一就行:

- 破译密文的代价超过被加密信息的价值
- 破译密文所花的时间超过信息的有用期

满足以上两个准则的密码算法在实际中是可用的

### 古典密码体制

#### 置换密码

?>栅栏密码

```python
def encrypt(plaintext, n):
    plaintext = plaintext.replace(" ", "")
    ciphertext = ""
    for i in range(n):
        s = ""
        for j in range(len(plaintext)):
            if j % n == i:
                s += plaintext[j]
        ciphertext += s
        # print(s)
    return ciphertext


def decrypt(ciphertext, n):
    per_str_len = len(ciphertext) // n + 1
    per_str = []
    for i in range(n):
        per_str.append(ciphertext[i * per_str_len:(i + 1) * per_str_len])
    # print(per_str)
    plaintext = ""
    for i in range(len(per_str[0])):
        for j in range(n):
            if i < len(per_str[j]):
                plaintext += per_str[j][i]
    return plaintext


text = input()
n = int(input())
print(encrypt(text, n))
print(decrypt(encrypt(text, n), n))
```

```
The quick brown fox jumps over the lazy dog
2
Teucbonojmsvrhlzdghqikrwfxupoeteayo
Thequickbrownfoxjumpsoverthelazydog
```

>把要加密的明文分成N个一组,然后把每组的第1个字符组合,每组第2个字符组合...每组的第N(最后一个分组可能不足N个)个字符组合,最后把他们全部连接起来就是密文

明文:`The quick brown fox jumps over the lazy dog`

去空格:`Thequickbrownfoxjumpsoverthelazydog`

分组:`Th eq ui ck br ow nf ox ju mp so ve rt he la zy do g`

第一组:`Teucbonojmsvrhlzdg`

第二组:`hqikrwfxupoeteayo`

密文:`Teucbonojmsvrhlzdghqikrwfxupoeteayo`

?>埃特巴什码

```python
dic = {"a": "z", "b": "y", "c": "x", "d": "w", "e": "v", "f": "u", "g": "t", "h": "s", "i": "r", "j": "q", "k": "p",
       "l": "o", "m": "n", "n": "m", "o": "l", "p": "k", "q": "j", "r": "i", "s": "h", "t": "g", "u": "f", "v": "e",
       "w": "d", "x": "c", "y": "b", "z": "a", "A": "Z", "B": "Y", "C": "X", "D": "W", "E": "V", "F": "U", "G": "T",
       "H": "S", "I": "R", "J": "Q", "K": "P", "L": "O", "M": "N", "N": "M", "O": "L", "P": "K", "Q": "J", "R": "I",
       "S": "H", "T": "G", "U": "F", "V": "E", "W": "D", "X": "C", "Y": "B", "Z": "A"}


def encrypt(plaintext):
    global dic
    ciphertext = ""
    for i in plaintext:
        if i in dic.keys():
            ciphertext += dic[i]
        else:
            ciphertext += i
    return ciphertext


def decrypt(ciphertext):
    global dic
    plaintext = ""
    for i in ciphertext:
        if i in dic.keys():
            plaintext += dic[i]
        else:
            plaintext += i
    return plaintext


text = input()
print(encrypt(text))
print(decrypt(encrypt(text)))
```

```
the quick brown fox jumps over the lazy dog
gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt
the quick brown fox jumps over the lazy dog
```

>埃特巴什码(Atbash Cipher)是一种以字母倒序排列作为特殊密钥的替换加密

#### 单表代换密码

1. 加法密码

$f(a_i)=b_i=a_j$

$j=i+k(mod n),(a_i∈A,0<k<n)$

?>凯撒密码

```python
def encrypt(plaintext, n):
    ciphertext = ""
    for i in plaintext:
        if 97 <= ord(i) <= 122:
            ciphertext += chr((ord(i) - 97 + n) % 26 + 97)
        elif 65 <= ord(i) <= 90:
            ciphertext += chr((ord(i) - 65 + n) % 26 + 65)
        else:
            ciphertext += i
    return ciphertext


def decrypt(ciphertext):
    plaintext = []
    for i in range(26):
        temp_text = ""
        for j in ciphertext:
            if 97 <= ord(j) <= 122:
                temp_text += chr((ord(j) - 97 + 26 - i) % 26 + 97)
            elif 65 <= ord(j) <= 90:
                temp_text += chr((ord(j) - 65 + +26 - i) % 26 + 65)
            else:
                temp_text += j
        plaintext.append(temp_text)
    return plaintext


text = input()
print(encrypt(text, 1))
plaintext = decrypt(encrypt(text, 1))
for i in range(26):
    print("ROT%d"%i,plaintext[i])
```

```
The quick brown fox jumps over the lazy dog
Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph
ROT0 Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph
ROT1 The quick brown fox jumps over the lazy dog
ROT2 Sgd pthbj aqnvm enw itlor nudq sgd kzyx cnf
ROT3 Rfc osgai zpmul dmv hsknq mtcp rfc jyxw bme
ROT4 Qeb nrfzh yoltk clu grjmp lsbo qeb ixwv ald
ROT5 Pda mqeyg xnksj bkt fqilo kran pda hwvu zkc
ROT6 Ocz lpdxf wmjri ajs ephkn jqzm ocz gvut yjb
ROT7 Nby kocwe vliqh zir dogjm ipyl nby futs xia
ROT8 Max jnbvd ukhpg yhq cnfil hoxk max etsr whz
ROT9 Lzw imauc tjgof xgp bmehk gnwj lzw dsrq vgy
ROT10 Kyv hlztb sifne wfo aldgj fmvi kyv crqp ufx
ROT11 Jxu gkysa rhemd ven zkcfi eluh jxu bqpo tew
ROT12 Iwt fjxrz qgdlc udm yjbeh dktg iwt apon sdv
ROT13 Hvs eiwqy pfckb tcl xiadg cjsf hvs zonm rcu
ROT14 Gur dhvpx oebja sbk whzcf bire gur ynml qbt
ROT15 Ftq cguow ndaiz raj vgybe ahqd ftq xmlk pas
ROT16 Esp bftnv mczhy qzi ufxad zgpc esp wlkj ozr
ROT17 Dro aesmu lbygx pyh tewzc yfob dro vkji nyq
ROT18 Cqn zdrlt kaxfw oxg sdvyb xena cqn ujih mxp
ROT19 Bpm ycqks jzwev nwf rcuxa wdmz bpm tihg lwo
ROT20 Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn
ROT21 Znk waoiq hxuct lud pasvy ubkx znk rgfe jum
ROT22 Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl
ROT23 Xli uymgo fvsar jsb nyqtw sziv xli pedc hsk
ROT24 Wkh txlfn eurzq ira mxpsv ryhu wkh odcb grj
ROT25 Vjg swkem dtqyp hqz lworu qxgt vjg ncba fqi
```

>凯撒密码是一种替换加密,明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文

2. 乘法密码

$f(a_i)=b_i=a_j$

$j=i*k(mod n),(a_i∈A,0<k<n,gcd(k,n)=1)$

3. 仿射密码

>乘法密码和加法密码的结合

$f(a_i)=b_i=a_j$

$j=k_0+i*k_1(mod n),(a_i∈A,0<k_0<n,gcd(k_1,n)=1)$

加密函数:$e(x)=a*x+b(mod m)$

解密函数:$d(x)=a^{-1}(x-b)(mod m)$,其中,$a^{-1}$为$a$的逆元

```python
list_a = [1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25]  # gcd(a,26)==1
list_b = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]


def gcd(a, b):
    while b:
        temp = a % b
        a = b
        b = temp
    return a


def encrypt(plaintext, a, b):
    ciphertext = ""
    for i in range(len(plaintext)):
        if 'a' <= plaintext[i] <= 'z':
            ciphertext += chr(((ord(plaintext[i]) - ord('a')) * a + b) % 26 + 65)  # 加密后的结果为大写
        elif 'A' <= plaintext[i] <= 'Z':
            ciphertext += chr(((ord(plaintext[i]) - ord('A')) * a + b) % 26 + 65)  # 加密后的结果为大写
        else:
            ciphertext += plaintext[i]
    return ciphertext


def decrypt(ciphertext, a, b):
    a = get_inverse_element(a)
    plaintext = ""
    for i in range(len(ciphertext)):
        temp = ord(ciphertext[i]) - 65 - b
        if temp < 0:
            temp += 26
        plaintext += chr((a * temp) % 26 + ord('a'))
    return plaintext


def get_inverse_element(a):  # 求逆元
    return (a ** (b - 2)) % 26


if __name__ == "__main__":
    msg = "Thequickbrownfoxjumpsoverthelazydog"
    a, b = 3, 4
    msg = encrypt(msg, a, b)
    print(msg)
    print("a=%d b=%d" % (a, b), decrypt(msg, a, b))
    #爆破
    for i in list_a:
        for j in list_b:
            print("a=%d b=%d" % (i, j), decrypt(msg, i, j))
```

```
JZQAMCKIHDUSRTUVFMOXGUPQDJZQLEBYNUW
a=3 b=4 thequickbrownfoxjumpsoverthelazydog
...
```

#### 多表代换密码

多表代换密码首先将明文$M$分为由$n$个字母构成的分组$M_1,M_2,...,M_j$,对每个分组$M_i$的加密为

$C_i \equiv AM_i+B(mod N),i=1,2,..,j$

其中$(A,B)$是密钥,$A$是$n*n$的可逆矩阵,满足$gcd(|A|,N)=1$($|A|$是行列式)

$B=(B_1,B_2,...,B_n)^T,C=(C_1,C_2,...,C_n)^T,M_i=(m_1,m_2,...,m_n)^T$

对密文分组$C_i$的解密为:$M_i \equiv A^{-1}(C_i-B)(modN),i=1,2,...,j$

!>例子

设$n=3,N=26$

$A=\begin{pmatrix} 11&2&19\\5&23&25\\20&7&17 \end{pmatrix},B=\begin{pmatrix} 0\\0\\0 \end{pmatrix}$

明文为`YOUR PIN NO IS FOUR ONE TWO SIX`

将明文分为3个字母组成的分组`YOU RPI NNO ISF OUR ONE TWO SIX`,可得

$M_1=\begin{pmatrix} 24\\14\\20 \end{pmatrix},M_2=\begin{pmatrix} 17\\15\\8 \end{pmatrix},M_3=\begin{pmatrix} 13\\13\\14 \end{pmatrix},M_4=\begin{pmatrix} 8\\18\\5 \end{pmatrix}$

$M_5=\begin{pmatrix} 14\\20\\17 \end{pmatrix},M_2=\begin{pmatrix} 14\\13\\4 \end{pmatrix},M_3=\begin{pmatrix} 19\\22\\14 \end{pmatrix},M_4=\begin{pmatrix} 18\\8\\23 \end{pmatrix}$

所以

$C_1(mod 26)=A\begin{pmatrix} 24\\14\\20 \end{pmatrix}=\begin{pmatrix} 22\\6\\8 \end{pmatrix},C_2(mod 26)=A\begin{pmatrix} 17\\15\\8 \end{pmatrix}=\begin{pmatrix} 5\\6\\9 \end{pmatrix},C_3(mod 26)=A\begin{pmatrix} 13\\13\\14 \end{pmatrix}=\begin{pmatrix} 19\\12\\17 \end{pmatrix},C_4(mod 26)=A\begin{pmatrix} 8\\18\\5 \end{pmatrix}=\begin{pmatrix} 11\\7\\7 \end{pmatrix}$

$C_5(mod 26)=A\begin{pmatrix} 14\\20\\17 \end{pmatrix}=\begin{pmatrix} 23\\19\\7 \end{pmatrix},C_6(mod 26)=A\begin{pmatrix} 14\\13\\4 \end{pmatrix}=\begin{pmatrix} 22\\1\\23 \end{pmatrix},C_7(mod 26)=A\begin{pmatrix} 19\\22\\14 \end{pmatrix}=\begin{pmatrix} 25\\15\\18 \end{pmatrix},C_8(mod 26)=A\begin{pmatrix} 18\\8\\23 \end{pmatrix}=\begin{pmatrix} 1\\17\\1 \end{pmatrix}$

所以,密文为`WGI FGJ TMR LHH XTH WBX ZPS BRB`

解密时,先求出

$A^{*}=\begin{pmatrix} 216&99&-387\\415&-193&-180\\-425&-37&243 \end{pmatrix}$

$|A|=11*23*17+2*25*20+5*7*19-20*23*19-5*2*17-7*25*11=-4869$

$-4869*x≡gcd(-4869,26)(mod 26)$

$x=11$

$A^{-1}=x*A^{*}=11*A^{*}$

$A^{-1}=\begin{pmatrix} 2376&1089&-4257\\4565&-2123&-1980\\-4675&-407&2673 \end{pmatrix}$

$A^{-1}(mod 26)=\begin{pmatrix} 10&23&7\\15&9&22\\5&9&21 \end{pmatrix}$

由$A^{-1}$对$C$进行解密

$M_1(mod 26)=A^{-1}\begin{pmatrix} 22\\6\\8 \end{pmatrix}=\begin{pmatrix} 24\\14\\20 \end{pmatrix},M_2(mod 26)=A^{-1}\begin{pmatrix} 5\\6\\9 \end{pmatrix}=\begin{pmatrix} 17\\15\\8 \end{pmatrix},M_3(mod 26)=A^{-1}\begin{pmatrix} 19\\12\\17 \end{pmatrix}=\begin{pmatrix} 13\\13\\14 \end{pmatrix},M_4(mod 26)=A^{-1}\begin{pmatrix} 11\\7\\7 \end{pmatrix}=\begin{pmatrix} 8\\18\\5 \end{pmatrix}$

$M_5(mod 26)=A^{-1}\begin{pmatrix} 23\\19\\7 \end{pmatrix}=\begin{pmatrix} 14\\20\\17 \end{pmatrix},M_6(mod 26)=A^{-1}\begin{pmatrix} 22\\1\\23 \end{pmatrix}=\begin{pmatrix} 14\\13\\4 \end{pmatrix},M_7(mod 26)=A^{-1}\begin{pmatrix} 25\\15\\18 \end{pmatrix}=\begin{pmatrix} 19\\22\\14 \end{pmatrix},M_8(mod 26)=A^{-1}\begin{pmatrix} 1\\17\\1 \end{pmatrix}=\begin{pmatrix} 18\\8\\23 \end{pmatrix}$

得到明文为`YOU RPI NNO ISF OUR ONE TWO SIX`

## 第二部分

### 现代分组密码

#### 概念

?>若明文流被分割成等长串,各串用相同的加密算法和相同的密钥进行加密,就是分组密码

1. 明文和密文时固定长度为$n$的比特串$m=m_1m_2m_3...m_n,c=c_1c_2c_3...c_n$

2. 加密密钥和解密密钥相等,时固定长度为$r$的比特串$k=k_1k_2k_3...k_r$

3. 加密算法为$c=Enc_k(m)$

4. 解密算法为$m=Dec_k(c)=Dec_k(Enc_k(m))$

#### 构造原则

- 要有足够大分组长度(保证足够大的明文空间,避免给攻击者提供太多的明文统计特征信息)
- 密钥空间要尽可能大(防止穷举)
- 保证足够强的密码算法复杂度
    - 先将一个明文分组划分为若干个子组分别进行处理,然和合并并变换
    - 采用乘积密码的思想,通过两种或两种以上简单密码的逐次应用,构造强度比其中任意一个更强的加密结果
- 使用简单运算来实现,易于处理器运算

#### S盒与P盒

在分组密码中,常使用**代换-置换网络**(SP变换)

- S盒:接受特定数量的输入比特`m`,并将其转换为特定数量的输出比特`n`,其中`n`不一定等于`m`(起到**混乱**的效果)

    - **混乱**:是指明文与密钥,以及密文之间的统计关系尽可能复杂,从而加强隐蔽性

- P盒:通过把一个比特串中各比特的位置次序重新排列而得到新的比特串(起到**扩散**的效果)

    - **扩散**:是指让明文中的每一位(包括密钥的每一位)直接或间接影响密文中的许多位,或让密文中的每一位受制于明文和密钥中的若干位,从而隐蔽明文的统计特征,在多轮变换后使密文发生多位改变(明文即使只有一位比特发生变化,也会改变密文的多位比特)

#### 分组密码设计准则

1. S盒的设计

    - 非线性度
    - 分均匀性:抵抗差分密码分析
    - 雪崩效应:明文即使只有一位比特发生变化,也会改变密文的多位比特
    - 可逆性完整
    - 没有陷门

2. P盒的设计

    加强雪崩效应

3. **轮函数$F$的设计**

    轮函数$F$是迭代分组密码中单轮加密算法的非线性函数,设计准则是保证非线性度要高,通过雪崩效应来实现更加混乱

    - 安全性:轮函数$F$必须能抵抗多种密码攻击方法,尤其是差分密码分析和线性密码分析
    - 速度
    - 灵活性:在多平台上可用

    分组密码迭代轮数越多,密码分析越困难

    **设计迭代轮数的准则是:使密码分析的难度大于简单穷举攻击的难度**

4. 密钥拓展算法的设计

    - 结构简单
    - 保证位独立和雪崩效应
    - 不存在简单数学关系
    - 不存在若密钥
    - 保证种子密钥的各比特对每个子密钥比特影响的均衡性
    - 速度

### DES

DES的特点是:加密和解密使用同一算法,同一密钥,同一结构

给定一个`64`位的明文和一个`64`位的密钥,输出一个`64`位的密文,密文可以用相同的密钥解密,而`64`位的密钥,里面只有`56`位在起作用,剩余的位可以直接丢弃,或当作奇偶校验位

DES一次只能加密`8`个字节,但将明文划分位每`8`个字节一组的块即可实现任意长度明文的加密,如果不是8的倍数,则进行填充至8的倍数

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/DES.gif)

DES算法分为两部分:**迭代加密**(16轮迭代加密)和**子密钥生成**

#### 子密钥生成

>从一把`64bits`的主密钥中生成了`16`把`48bits`的子密钥

生成方法:

1. 从`64bits`的主密钥中选取特定的`56`位,将这56位看作是一个长度为56的布尔数组,将其拆分成左右两个半密钥,得到两个28位的布尔数组(选择置换1)(PC1)

<table class="wikitable" cellspacing="0" style="text-align:right">
<caption align="top">选择置换1
</caption>
<tbody><tr>
<td colspan="7" style="text-align:center">左
</td></tr>
<tr>
<td>57</td>
<td>49</td>
<td>41</td>
<td>33</td>
<td>25</td>
<td>17</td>
<td>9
</td></tr>
<tr>
<td>1</td>
<td>58</td>
<td>50</td>
<td>42</td>
<td>34</td>
<td>26</td>
<td>18
</td></tr>
<tr>
<td>10</td>
<td>2</td>
<td>59</td>
<td>51</td>
<td>43</td>
<td>35</td>
<td>27
</td></tr>
<tr>
<td>19</td>
<td>11</td>
<td>3</td>
<td>60</td>
<td>52</td>
<td>44</td>
<td>36
</td></tr>
<tr>
<td colspan="7" style="text-align:center">右
</td></tr>
<tr>
<td>63</td>
<td>55</td>
<td>47</td>
<td>39</td>
<td>31</td>
<td>23</td>
<td>15
</td></tr>
<tr>
<td>7</td>
<td>62</td>
<td>54</td>
<td>46</td>
<td>38</td>
<td>30</td>
<td>22
</td></tr>
<tr>
<td>14</td>
<td>6</td>
<td>61</td>
<td>53</td>
<td>45</td>
<td>37</td>
<td>29
</td></tr>
<tr>
<td>21</td>
<td>13</td>
<td>5</td>
<td>28</td>
<td>20</td>
<td>12</td>
<td>4
</td></tr></tbody></table>

```python
def PC1(main_key):
    pc1_left = [
        57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51,
        43, 35, 27, 19, 11, 3, 60, 52, 44, 36
    ]
    pc1_right = [
        63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53,
        45, 37, 29, 21, 13, 5, 28, 20, 12, 4
    ]

    return [main_key[i - 1] for i in pc1_left], [main_key[i - 1] for i in pc1_right]
```

2. 将两个半密钥都循环左移(即`321`->`213`->`132`),在不同的轮次,位移的位数不同

<table class="wikitable" cellspacing="0" style="text-align:center">
<caption align="top">移位
</caption>
<tbody><tr>
<th>轮次
</th>
<th>左移位数
</th></tr>
<tr>
<td>1</td>
<td>1
</td></tr>
<tr>
<td>2</td>
<td>1
</td></tr>
<tr>
<td>3</td>
<td>2
</td></tr>
<tr>
<td>4</td>
<td>2
</td></tr>
<tr>
<td>5</td>
<td>2
</td></tr>
<tr>
<td>6</td>
<td>2
</td></tr>
<tr>
<td>7</td>
<td>2
</td></tr>
<tr>
<td>8</td>
<td>2
</td></tr>
<tr>
<td>9</td>
<td>1
</td></tr>
<tr>
<td>10</td>
<td>2
</td></tr>
<tr>
<td>11</td>
<td>2
</td></tr>
<tr>
<td>12</td>
<td>2
</td></tr>
<tr>
<td>13</td>
<td>2
</td></tr>
<tr>
<td>14</td>
<td>2
</td></tr>
<tr>
<td>15</td>
<td>2
</td></tr>
<tr>
<td>16</td>
<td>1
</td></tr></tbody></table>

```python
def Rotate(key, offset):
    return key[offset:] + key[:offset]


def Get_Sub_Key(main_key):
    left, right = PC1(main_key)
    offset = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]  #sum(offset)=28
    Sub_Key = []

    for i in range(16):
        left = Rotate(left, offset[i])
        right = Rotate(right, offset[i])
        Sub_Key.append(PC2(left + right))

    return Sub_Key
```

3. 将两个半密钥重新连接,并进行一次置换(从`56`位的布尔数组中选取特定的`48`位),得到这一轮的子密钥(选择置换2)(PC2)

<table class="wikitable" cellspacing="0" style="text-align:right">
<caption align="top">选择置换2
</caption>
<tbody><tr>
<td>14</td>
<td>17</td>
<td>11</td>
<td>24</td>
<td>1</td>
<td>5
</td></tr>
<tr>
<td>3</td>
<td>28</td>
<td>15</td>
<td>6</td>
<td>21</td>
<td>10
</td></tr>
<tr>
<td>23</td>
<td>19</td>
<td>12</td>
<td>4</td>
<td>26</td>
<td>8
</td></tr>
<tr>
<td>16</td>
<td>7</td>
<td>27</td>
<td>20</td>
<td>13</td>
<td>2
</td></tr>
<tr>
<td>41</td>
<td>52</td>
<td>31</td>
<td>37</td>
<td>47</td>
<td>55
</td></tr>
<tr>
<td>30</td>
<td>40</td>
<td>51</td>
<td>45</td>
<td>33</td>
<td>48
</td></tr>
<tr>
<td>44</td>
<td>49</td>
<td>39</td>
<td>56</td>
<td>34</td>
<td>53
</td></tr>
<tr>
<td>46</td>
<td>42</td>
<td>50</td>
<td>36</td>
<td>29</td>
<td>32
</td></tr></tbody></table>

```python
def PC2(key):

    pc2 = [
        14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16,
        7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44,
        49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
    ]
    return [key[i - 1] for i in pc2]
```

4. 重复2,3共16次,得到`16`个`48bits`子密钥

#### 迭代加密

得到16个子密钥后,开始进行加密

1. 对输入的明文(看成是一个长度为`64`的布尔数组)作一次置换(IP置换),得到一个新的布尔数组,其拆分成左右两个数组,得到两个32位的布尔数组

<table class="wikitable" cellspacing="0" style="text-align:right">
<caption align="top">IP
</caption>
<tbody><tr>
<td>58</td>
<td>50</td>
<td>42</td>
<td>34</td>
<td>26</td>
<td>18</td>
<td>10</td>
<td>2
</td></tr>
<tr>
<td>60</td>
<td>52</td>
<td>44</td>
<td>36</td>
<td>28</td>
<td>20</td>
<td>12</td>
<td>4
</td></tr>
<tr>
<td>62</td>
<td>54</td>
<td>46</td>
<td>38</td>
<td>30</td>
<td>22</td>
<td>14</td>
<td>6
</td></tr>
<tr>
<td>64</td>
<td>56</td>
<td>48</td>
<td>40</td>
<td>32</td>
<td>24</td>
<td>16</td>
<td>8
</td></tr>
<tr>
<td>57</td>
<td>49</td>
<td>41</td>
<td>33</td>
<td>25</td>
<td>17</td>
<td>9</td>
<td>1
</td></tr>
<tr>
<td>59</td>
<td>51</td>
<td>43</td>
<td>35</td>
<td>27</td>
<td>19</td>
<td>11</td>
<td>3
</td></tr>
<tr>
<td>61</td>
<td>53</td>
<td>45</td>
<td>37</td>
<td>29</td>
<td>21</td>
<td>13</td>
<td>5
</td></tr>
<tr>
<td>63</td>
<td>55</td>
<td>47</td>
<td>39</td>
<td>31</td>
<td>23</td>
<td>15</td>
<td>7
</td></tr>
</tbody></table>

```python
def IP(data):
    ip = [
        58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54,
        46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33,
        25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21,
        13, 5, 63, 55, 47, 39, 31, 23, 15, 7
    ]
    return [data[i - 1] for i in ip]
```

2. 每一轮迭代,都接收一组$L,R$,返回$L^{'},R^{'}$,作为下一轮迭代的$L,R$

    $L^{'}=R$

    $R^{'}=L \bigotimes F(R,subkey)$

    $F$为轮函数(以一个子密钥,加密`32bits`的信息)

3. 利用得到的16个子密钥,重复步骤3共16次

4. 将最终得到的$R$与$L$拼接,作一次置换(FP置换),得到密文

<table class="wikitable" cellspacing="0" style="text-align:right">
<caption align="top">FP
</caption>
<tbody><tr>
<td>40</td>
<td>8</td>
<td>48</td>
<td>16</td>
<td>56</td>
<td>24</td>
<td>64</td>
<td>32
</td></tr>
<tr>
<td>39</td>
<td>7</td>
<td>47</td>
<td>15</td>
<td>55</td>
<td>23</td>
<td>63</td>
<td>31
</td></tr>
<tr>
<td>38</td>
<td>6</td>
<td>46</td>
<td>14</td>
<td>54</td>
<td>22</td>
<td>62</td>
<td>30
</td></tr>
<tr>
<td>37</td>
<td>5</td>
<td>45</td>
<td>13</td>
<td>53</td>
<td>21</td>
<td>61</td>
<td>29
</td></tr>
<tr>
<td>36</td>
<td>4</td>
<td>44</td>
<td>12</td>
<td>52</td>
<td>20</td>
<td>60</td>
<td>28
</td></tr>
<tr>
<td>35</td>
<td>3</td>
<td>43</td>
<td>11</td>
<td>51</td>
<td>19</td>
<td>59</td>
<td>27
</td></tr>
<tr>
<td>34</td>
<td>2</td>
<td>42</td>
<td>10</td>
<td>50</td>
<td>18</td>
<td>58</td>
<td>26
</td></tr>
<tr>
<td>33</td>
<td>1</td>
<td>41</td>
<td>9</td>
<td>49</td>
<td>17</td>
<td>57</td>
<td>25
</td></tr>
</tbody></table>

```python
def FP(data):
    fp = [
        40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6,
        46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12,
        52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18,
        58, 26, 33, 1, 41, 9, 49, 17, 57, 25
    ]
    return [data[i - 1] for i in fp]
```

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/DES.png)

以上为DES的加密过程,而DES的解密过程与其相似但子密钥的使用顺序相反

#### $F$函数

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/DES-f-function.png)

一个`32bits`的块,经过一次扩张(`Expand`函数),变成`48bits`,然后与子密钥进行异或,将异或得到的`48bits`的结果分成`8`组,每组`6bits`数据,分别进行一次**S盒**变换,输出`4bits`的数据,将这些数据连接,得到`32bits`的数据,然后进行一次**P盒**变换,得到`32bits`的结果

<table class="wikitable" cellspacing="0" style="text-align:right">
<caption align="top">Expand
</caption>
<tbody><tr>
<td>32</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5
</td></tr>
<tr>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9
</td></tr>
<tr>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13
</td></tr>
<tr>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17
</td></tr>
<tr>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21
</td></tr>
<tr>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25
</td></tr>
<tr>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29
</td></tr>
<tr>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
<td>32</td>
<td>1
</td></tr></tbody></table>

```python
def Expand(data):
    e = [
        32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14,
        15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26,
        27, 28, 29, 28, 29, 30, 31, 32, 1
    ]
    return [data[i - 1] for i in e]
```

<table class="wikitable" cellspacing="0" style="text-align:right">
<caption align="top">S盒
</caption>
<tbody><tr>
<th colspan="17" style="text-align:center">S<sub>1</sub>
</th></tr>
<tr>
<th>
</th>
<th>x0000x</th>
<th>x0001x</th>
<th>x0010x</th>
<th>x0011x</th>
<th>x0100x</th>
<th>x0101x</th>
<th>x0110x</th>
<th>x0111x
</th>
<th>x1000x</th>
<th>x1001x</th>
<th>x1010x</th>
<th>x1011x</th>
<th>x1100x</th>
<th>x1101x</th>
<th>x1110x</th>
<th>x1111x
</th></tr>
<tr>
<th>0yyyy0
</th>
<td>14</td>
<td>4</td>
<td>13</td>
<td>1</td>
<td>2</td>
<td>15</td>
<td>11</td>
<td>8</td>
<td>3</td>
<td>10</td>
<td>6</td>
<td>12</td>
<td>5</td>
<td>9</td>
<td>0</td>
<td>7
</td></tr>
<tr>
<th>0yyyy1
</th>
<td>0</td>
<td>15</td>
<td>7</td>
<td>4</td>
<td>14</td>
<td>2</td>
<td>13</td>
<td>1</td>
<td>10</td>
<td>6</td>
<td>12</td>
<td>11</td>
<td>9</td>
<td>5</td>
<td>3</td>
<td>8
</td></tr>
<tr>
<th>1yyyy0
</th>
<td>4</td>
<td>1</td>
<td>14</td>
<td>8</td>
<td>13</td>
<td>6</td>
<td>2</td>
<td>11</td>
<td>15</td>
<td>12</td>
<td>9</td>
<td>7</td>
<td>3</td>
<td>10</td>
<td>5</td>
<td>0
</td></tr>
<tr>
<th>1yyyy1
</th>
<td>15</td>
<td>12</td>
<td>8</td>
<td>2</td>
<td>4</td>
<td>9</td>
<td>1</td>
<td>7</td>
<td>5</td>
<td>11</td>
<td>3</td>
<td>14</td>
<td>10</td>
<td>0</td>
<td>6</td>
<td>13
</td></tr>
<tr>
<th colspan="17" style="text-align:center">S<sub>2</sub>
</th></tr>
<tr>
<th>
</th>
<th>x0000x</th>
<th>x0001x</th>
<th>x0010x</th>
<th>x0011x</th>
<th>x0100x</th>
<th>x0101x</th>
<th>x0110x</th>
<th>x0111x
</th>
<th>x1000x</th>
<th>x1001x</th>
<th>x1010x</th>
<th>x1011x</th>
<th>x1100x</th>
<th>x1101x</th>
<th>x1110x</th>
<th>x1111x
</th></tr>
<tr>
<th>0yyyy0
</th>
<td>15</td>
<td>1</td>
<td>8</td>
<td>14</td>
<td>6</td>
<td>11</td>
<td>3</td>
<td>4</td>
<td>9</td>
<td>7</td>
<td>2</td>
<td>13</td>
<td>12</td>
<td>0</td>
<td>5</td>
<td>10
</td></tr>
<tr>
<th>0yyyy1
</th>
<td>3</td>
<td>13</td>
<td>4</td>
<td>7</td>
<td>15</td>
<td>2</td>
<td>8</td>
<td>14</td>
<td>12</td>
<td>0</td>
<td>1</td>
<td>10</td>
<td>6</td>
<td>9</td>
<td>11</td>
<td>5
</td></tr>
<tr>
<th>1yyyy0
</th>
<td>0</td>
<td>14</td>
<td>7</td>
<td>11</td>
<td>10</td>
<td>4</td>
<td>13</td>
<td>1</td>
<td>5</td>
<td>8</td>
<td>12</td>
<td>6</td>
<td>9</td>
<td>3</td>
<td>2</td>
<td>15
</td></tr>
<tr>
<th>1yyyy1
</th>
<td>13</td>
<td>8</td>
<td>10</td>
<td>1</td>
<td>3</td>
<td>15</td>
<td>4</td>
<td>2</td>
<td>11</td>
<td>6</td>
<td>7</td>
<td>12</td>
<td>0</td>
<td>5</td>
<td>14</td>
<td>9
</td></tr>
<tr>
<th colspan="17" style="text-align:center">S<sub>3</sub>
</th></tr>
<tr>
<th>
</th>
<th>x0000x</th>
<th>x0001x</th>
<th>x0010x</th>
<th>x0011x</th>
<th>x0100x</th>
<th>x0101x</th>
<th>x0110x</th>
<th>x0111x
</th>
<th>x1000x</th>
<th>x1001x</th>
<th>x1010x</th>
<th>x1011x</th>
<th>x1100x</th>
<th>x1101x</th>
<th>x1110x</th>
<th>x1111x
</th></tr>
<tr>
<th>0yyyy0
</th>
<td>10</td>
<td>0</td>
<td>9</td>
<td>14</td>
<td>6</td>
<td>3</td>
<td>15</td>
<td>5</td>
<td>1</td>
<td>13</td>
<td>12</td>
<td>7</td>
<td>11</td>
<td>4</td>
<td>2</td>
<td>8
</td></tr>
<tr>
<th>0yyyy1
</th>
<td>13</td>
<td>7</td>
<td>0</td>
<td>9</td>
<td>3</td>
<td>4</td>
<td>6</td>
<td>10</td>
<td>2</td>
<td>8</td>
<td>5</td>
<td>14</td>
<td>12</td>
<td>11</td>
<td>15</td>
<td>1
</td></tr>
<tr>
<th>1yyyy0
</th>
<td>13</td>
<td>6</td>
<td>4</td>
<td>9</td>
<td>8</td>
<td>15</td>
<td>3</td>
<td>0</td>
<td>11</td>
<td>1</td>
<td>2</td>
<td>12</td>
<td>5</td>
<td>10</td>
<td>14</td>
<td>7
</td></tr>
<tr>
<th>1yyyy1
</th>
<td>1</td>
<td>10</td>
<td>13</td>
<td>0</td>
<td>6</td>
<td>9</td>
<td>8</td>
<td>7</td>
<td>4</td>
<td>15</td>
<td>14</td>
<td>3</td>
<td>11</td>
<td>5</td>
<td>2</td>
<td>12
</td></tr>
<tr>
<th colspan="17" style="text-align:center">S<sub>4</sub>
</th></tr>
<tr>
<th>
</th>
<th>x0000x</th>
<th>x0001x</th>
<th>x0010x</th>
<th>x0011x</th>
<th>x0100x</th>
<th>x0101x</th>
<th>x0110x</th>
<th>x0111x
</th>
<th>x1000x</th>
<th>x1001x</th>
<th>x1010x</th>
<th>x1011x</th>
<th>x1100x</th>
<th>x1101x</th>
<th>x1110x</th>
<th>x1111x
</th></tr>
<tr>
<th>0yyyy0
</th>
<td>7</td>
<td>13</td>
<td>14</td>
<td>3</td>
<td>0</td>
<td>6</td>
<td>9</td>
<td>10</td>
<td>1</td>
<td>2</td>
<td>8</td>
<td>5</td>
<td>11</td>
<td>12</td>
<td>4</td>
<td>15
</td></tr>
<tr>
<th>0yyyy1
</th>
<td>13</td>
<td>8</td>
<td>11</td>
<td>5</td>
<td>6</td>
<td>15</td>
<td>0</td>
<td>3</td>
<td>4</td>
<td>7</td>
<td>2</td>
<td>12</td>
<td>1</td>
<td>10</td>
<td>14</td>
<td>9
</td></tr>
<tr>
<th>1yyyy0
</th>
<td>10</td>
<td>6</td>
<td>9</td>
<td>0</td>
<td>12</td>
<td>11</td>
<td>7</td>
<td>13</td>
<td>15</td>
<td>1</td>
<td>3</td>
<td>14</td>
<td>5</td>
<td>2</td>
<td>8</td>
<td>4
</td></tr>
<tr>
<th>1yyyy1
</th>
<td>3</td>
<td>15</td>
<td>0</td>
<td>6</td>
<td>10</td>
<td>1</td>
<td>13</td>
<td>8</td>
<td>9</td>
<td>4</td>
<td>5</td>
<td>11</td>
<td>12</td>
<td>7</td>
<td>2</td>
<td>14
</td></tr>
<tr>
<th colspan="17" style="text-align:center">S<sub>5</sub>
</th></tr>
<tr>
<th>
</th>
<th>x0000x</th>
<th>x0001x</th>
<th>x0010x</th>
<th>x0011x</th>
<th>x0100x</th>
<th>x0101x</th>
<th>x0110x</th>
<th>x0111x
</th>
<th>x1000x</th>
<th>x1001x</th>
<th>x1010x</th>
<th>x1011x</th>
<th>x1100x</th>
<th>x1101x</th>
<th>x1110x</th>
<th>x1111x
</th></tr>
<tr>
<th>0yyyy0
</th>
<td>2</td>
<td>12</td>
<td>4</td>
<td>1</td>
<td>7</td>
<td>10</td>
<td>11</td>
<td>6</td>
<td>8</td>
<td>5</td>
<td>3</td>
<td>15</td>
<td>13</td>
<td>0</td>
<td>14</td>
<td>9
</td></tr>
<tr>
<th>0yyyy1
</th>
<td>14</td>
<td>11</td>
<td>2</td>
<td>12</td>
<td>4</td>
<td>7</td>
<td>13</td>
<td>1</td>
<td>5</td>
<td>0</td>
<td>15</td>
<td>10</td>
<td>3</td>
<td>9</td>
<td>8</td>
<td>6
</td></tr>
<tr>
<th>1yyyy0
</th>
<td>4</td>
<td>2</td>
<td>1</td>
<td>11</td>
<td>10</td>
<td>13</td>
<td>7</td>
<td>8</td>
<td>15</td>
<td>9</td>
<td>12</td>
<td>5</td>
<td>6</td>
<td>3</td>
<td>0</td>
<td>14
</td></tr>
<tr>
<th>1yyyy1
</th>
<td>11</td>
<td>8</td>
<td>12</td>
<td>7</td>
<td>1</td>
<td>14</td>
<td>2</td>
<td>13</td>
<td>6</td>
<td>15</td>
<td>0</td>
<td>9</td>
<td>10</td>
<td>4</td>
<td>5</td>
<td>3
</td></tr>
<tr>
<th colspan="17" style="text-align:center">S<sub>6</sub>
</th></tr>
<tr>
<th>
</th>
<th>x0000x</th>
<th>x0001x</th>
<th>x0010x</th>
<th>x0011x</th>
<th>x0100x</th>
<th>x0101x</th>
<th>x0110x</th>
<th>x0111x
</th>
<th>x1000x</th>
<th>x1001x</th>
<th>x1010x</th>
<th>x1011x</th>
<th>x1100x</th>
<th>x1101x</th>
<th>x1110x</th>
<th>x1111x
</th></tr>
<tr>
<th>0yyyy0
</th>
<td>12</td>
<td>1</td>
<td>10</td>
<td>15</td>
<td>9</td>
<td>2</td>
<td>6</td>
<td>8</td>
<td>0</td>
<td>13</td>
<td>3</td>
<td>4</td>
<td>14</td>
<td>7</td>
<td>5</td>
<td>11
</td></tr>
<tr>
<th>0yyyy1
</th>
<td>10</td>
<td>15</td>
<td>4</td>
<td>2</td>
<td>7</td>
<td>12</td>
<td>9</td>
<td>5</td>
<td>6</td>
<td>1</td>
<td>13</td>
<td>14</td>
<td>0</td>
<td>11</td>
<td>3</td>
<td>8
</td></tr>
<tr>
<th>1yyyy0
</th>
<td>9</td>
<td>14</td>
<td>15</td>
<td>5</td>
<td>2</td>
<td>8</td>
<td>12</td>
<td>3</td>
<td>7</td>
<td>0</td>
<td>4</td>
<td>10</td>
<td>1</td>
<td>13</td>
<td>11</td>
<td>6
</td></tr>
<tr>
<th>1yyyy1
</th>
<td>4</td>
<td>3</td>
<td>2</td>
<td>12</td>
<td>9</td>
<td>5</td>
<td>15</td>
<td>10</td>
<td>11</td>
<td>14</td>
<td>1</td>
<td>7</td>
<td>6</td>
<td>0</td>
<td>8</td>
<td>13
</td></tr>
<tr>
<th colspan="17" style="text-align:center">S<sub>7</sub>
</th></tr>
<tr>
<th>
</th>
<th>x0000x</th>
<th>x0001x</th>
<th>x0010x</th>
<th>x0011x</th>
<th>x0100x</th>
<th>x0101x</th>
<th>x0110x</th>
<th>x0111x
</th>
<th>x1000x</th>
<th>x1001x</th>
<th>x1010x</th>
<th>x1011x</th>
<th>x1100x</th>
<th>x1101x</th>
<th>x1110x</th>
<th>x1111x
</th></tr>
<tr>
<th>0yyyy0
</th>
<td>4</td>
<td>11</td>
<td>2</td>
<td>14</td>
<td>15</td>
<td>0</td>
<td>8</td>
<td>13</td>
<td>3</td>
<td>12</td>
<td>9</td>
<td>7</td>
<td>5</td>
<td>10</td>
<td>6</td>
<td>1
</td></tr>
<tr>
<th>0yyyy1
</th>
<td>13</td>
<td>0</td>
<td>11</td>
<td>7</td>
<td>4</td>
<td>9</td>
<td>1</td>
<td>10</td>
<td>14</td>
<td>3</td>
<td>5</td>
<td>12</td>
<td>2</td>
<td>15</td>
<td>8</td>
<td>6
</td></tr>
<tr>
<th>1yyyy0
</th>
<td>1</td>
<td>4</td>
<td>11</td>
<td>13</td>
<td>12</td>
<td>3</td>
<td>7</td>
<td>14</td>
<td>10</td>
<td>15</td>
<td>6</td>
<td>8</td>
<td>0</td>
<td>5</td>
<td>9</td>
<td>2
</td></tr>
<tr>
<th>1yyyy1
</th>
<td>6</td>
<td>11</td>
<td>13</td>
<td>8</td>
<td>1</td>
<td>4</td>
<td>10</td>
<td>7</td>
<td>9</td>
<td>5</td>
<td>0</td>
<td>15</td>
<td>14</td>
<td>2</td>
<td>3</td>
<td>12
</td></tr>
<tr>
<th colspan="17" style="text-align:center">S<sub>8</sub>
</th></tr>
<tr>
<th>
</th>
<th>x0000x</th>
<th>x0001x</th>
<th>x0010x</th>
<th>x0011x</th>
<th>x0100x</th>
<th>x0101x</th>
<th>x0110x</th>
<th>x0111x
</th>
<th>x1000x</th>
<th>x1001x</th>
<th>x1010x</th>
<th>x1011x</th>
<th>x1100x</th>
<th>x1101x</th>
<th>x1110x</th>
<th>x1111x
</th></tr>
<tr>
<th>0yyyy0
</th>
<td>13</td>
<td>2</td>
<td>8</td>
<td>4</td>
<td>6</td>
<td>15</td>
<td>11</td>
<td>1</td>
<td>10</td>
<td>9</td>
<td>3</td>
<td>14</td>
<td>5</td>
<td>0</td>
<td>12</td>
<td>7
</td></tr>
<tr>
<th>0yyyy1
</th>
<td>1</td>
<td>15</td>
<td>13</td>
<td>8</td>
<td>10</td>
<td>3</td>
<td>7</td>
<td>4</td>
<td>12</td>
<td>5</td>
<td>6</td>
<td>11</td>
<td>0</td>
<td>14</td>
<td>9</td>
<td>2
</td></tr>
<tr>
<th>1yyyy0
</th>
<td>7</td>
<td>11</td>
<td>4</td>
<td>1</td>
<td>9</td>
<td>12</td>
<td>14</td>
<td>2</td>
<td>0</td>
<td>6</td>
<td>10</td>
<td>13</td>
<td>15</td>
<td>3</td>
<td>5</td>
<td>8
</td></tr>
<tr>
<th>1yyyy1
</th>
<td>2</td>
<td>1</td>
<td>14</td>
<td>7</td>
<td>4</td>
<td>10</td>
<td>8</td>
<td>13</td>
<td>15</td>
<td>12</td>
<td>9</td>
<td>0</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>11
</td></tr></tbody></table>

```python
def S(data):
    split_data = [[] for i in range(8)]
    for i in range(len(data)):
        split_data[i // 6].append(data[i])
    for i in range(8):
        split_data[i] = int(split_data[i][4]) * (2 ** 0) + int(split_data[i][3]) * (2 ** 1) + int(split_data[i][2]) * (
                2 ** 2) + int(split_data[i][1]) * (2 ** 3) + int(split_data[i][5]) * (2 ** 4) + int(
            split_data[i][0]) * (2 ** 5)

    S_box = [
        [
            14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14,
            2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12,
            9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13
        ],
        [
            15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13,
            4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11,
            10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15,
            4, 2, 11, 6, 7, 12, 0, 5, 14, 9
        ],
        [
            10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7,
            0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8,
            15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8,
            7, 4, 15, 14, 3, 11, 5, 2, 12
        ],
        [
            7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8,
            11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0,
            12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1,
            13, 8, 9, 4, 5, 11, 12, 7, 2, 14
        ],
        [
            2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11,
            2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10,
            13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2,
            13, 6, 15, 0, 9, 10, 4, 5, 3
        ],
        [
            12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15,
            4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2,
            8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15,
            10, 11, 14, 1, 7, 6, 0, 8, 13
        ],
        [
            4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0,
            11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13,
            12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4,
            10, 7, 9, 5, 0, 15, 14, 2, 3, 12
        ],
        [
            13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15,
            13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9,
            12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8,
            13, 15, 12, 9, 0, 3, 5, 6, 11
        ]]
    S_Result = []
    for i in range(8):
        S_Result.append(bin(S_box[i][split_data[i]])[2:].zfill(4))
    return S_Result
```

<table class="wikitable" cellspacing="0" style="text-align:right">
<caption align="top">P
</caption>
<tbody><tr>
<td>16</td>
<td>7</td>
<td>20</td>
<td>21
</td></tr>
<tr>
<td>29</td>
<td>12</td>
<td>28</td>
<td>17
</td></tr>
<tr>
<td>1</td>
<td>15</td>
<td>23</td>
<td>26
</td></tr>
<tr>
<td>5</td>
<td>18</td>
<td>31</td>
<td>10
</td></tr>
<tr>
<td>2</td>
<td>8</td>
<td>24</td>
<td>14
</td></tr>
<tr>
<td>32</td>
<td>27</td>
<td>3</td>
<td>9
</td></tr>
<tr>
<td>19</td>
<td>13</td>
<td>30</td>
<td>6
</td></tr>
<tr>
<td>22</td>
<td>11</td>
<td>4</td>
<td>25
</td></tr></tbody></table>

```python
def P(data):
    p_box = [
        16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24,
        14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25
    ]
    return [data[i - 1] for i in p_box]
```

#### 三重DES

- DES-EEE3模式: 使用三个不同密钥$K_1,K_2,K_3$,采用三次加密算法
- DES-EDE3模式: 使用三个不同密钥$K_1,K_2,K_3$,采用加密-解密-加密算法
- DES-EEE2模式: 使用两个不同密钥$K_1=K_3,K_2$,采用三次加密算法
- DES-EDE2模式: 使用两个不同密钥$K_1=K_3,K_2$,采用加密-解密-加密算法

### IDEA

#### 密钥生成

IDEA在加密的每轮中使用6个密钥,然后最后输出轮使用4个密钥,一共有52个

1. 前8个密钥来自与该算法最初的密钥,$K1$取自密钥的高16比特,$K8$取自密钥的低16比特
2. 将密钥循环左移`25`位获取下一轮密钥,然后再次分为8组

#### 加密流程

IDEA加密的数据块的大小为`64bits`,其使用的密钥长度为`128bits`,该算法会对输入的数据块进行8次相同的变换,只是每次使用的密钥不同,最后会进行一次输出变换

每一轮的操作

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/IDEA_Round.png)

输入和输出都是`16bits`一组

每一轮的主要执行的运算有

- 按位异或,`⊕`
- 模加,模数为$2^{16}$,`⊞`
- 模乘,模数为$2^{16} +1$,`⊙`

!>`0x0000`的输入会被修改为$2^{16}$,$2^{16}$的输出结果会被修改为`0x0000`


$K_5,K_6$构成的中间那个方格的加密方式为`MA`,称`MA_L`为该部分加密后的左侧结果,其最后会和最左边的`16bits`操作,`MA_R`为该部分加密后的右半部分的结果,其最后会和第三个`16bits`操作

在最后输出轮的操作如下

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/IDEA_Output_Trans.png)

#### 解密流程

解密流程与加密流程相似,主要在于其密钥的选取

- 第$i(1-9)$轮的解密的密钥的前4个子密钥由加密过程中第$10-i$轮的前4个子密钥得出
    - 其中第1个和第4个解密子密钥为相应的子密钥关于$2^{16} +1$的乘法逆元
    - 第2个和第3个子密钥的取法为
        - 当轮数为2,...,8时,取相应的第3个和第2个的子密钥的$2^{16}$的加密逆元
        - 当轮数为1或9时,取相应的第2个和第3个子密钥对应的$2^{16}$的加密逆元
- 第5和第6个密钥不变

#### 总体流程

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/IDEA_All.png)

#### 安全性讨论

- 穷举攻击: IDEA是安全的
- 差分攻击: 第4轮之后对差分攻击免疫
- 线性攻击: `MA`结构具有抗线性攻击能力
- 存在伪弱密钥

### AES

[https://ctf-wiki.org/crypto/blockcipher/aes/](https://ctf-wiki.org/crypto/blockcipher/aes/)

### 分组密码工作模式

1. 电子密码本(ECB)

最简单的加密模式即为电子密码本(Electronic codebook,ECB)模式,需要加密的消息按照块密码的块大小被分为数个块,并对每个块进行独立加密 

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/Ecb_decryption.png)

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/Ecb_encryption.png)

!>缺点在于同样的明文块会被加密成相同的密文块,因此它不能很好的隐藏数据模式

2. 密码块链接(CBC)

在CBC模式中,每个明文块先与前一个密文块进行异或后,再进行加密,每个密文块都依赖于它前面的所有明文块,同时,为了保证每条消息的唯一性,在第一个块中需要使用初始化向量

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/Cbc_encryption.png)

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/Cbc_decryption.png)

若第一个块的下标为1,则CBC模式的加密过程为(第一个块的下标为1)

$C_i=E_k(P_i \bigotimes C_{i-1})$

$C_0=IV$

而其解密过程则为

$P_i=D_k(C_i) \bigotimes C{i-1}$

$C_0=IV$

!>主要缺点在于加密过程是串行的,无法被并行化,而且消息必须被填充到块大小的整数倍,解决后一个问题的一种方法是利用[密文窃取](https://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87%E7%AA%83%E5%8F%96),在解密,从两个邻接的密文块中即可得到一个明文块,因此,解密过程可以被并行化

!>在加密时,明文中的微小改变会导致其后的全部密文块发生改变,而在解密时,而解密时,密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变,不会影响到其它明文的内容

?>密文窃取是一种使用分组密码操作模式的通用方法,该操作模式允许处理不能均匀分割成块的消息,而不会导致密文的扩展

>窃取密文是一种使用块密码加密明文的技术,不需要将消息填充到块大小的倍数,因此密文与明文的大小相同
>
>它通过更改消息的最后两个块的处理来实现这一点,除了最后两个块之外,所有块的处理都保持不变,但是倒数第二个块的密文的一部分被"窃取"了,用来填充最后一个明文块,然后像往常一样加密
>
>最终密文的最后两个块,包括部分倒数第二块(删掉"窃取"部分)和完整的最后一块,它们的大小与原明文相同
>
>解密时要求首先解密最后一个块,然后将被"窃取"的密文恢复到倒数第二个块,然后可以像往常一样解密

3. 密码反馈模式(CFB)

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/Cfb_encryption.png)

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/Cfb_decryption.png)

$C_i=E_k(C_{i-1}) \bigotimes P_i$

$P_i=E_k(C_{i-1}) \bigotimes C_i$

$C_0=IV$

4. 输出反馈模式(OFB)

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/Ofb_encryption.png)

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/subject/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/Ofb_decryption.png)

$C_i=P_i \bigotimes O_i$

$P_i=C_i \bigotimes O_i$

$O_i=E_k(O_{i-1})$

$O_0=IV$

## 第三部分

### 公钥密码体制的基本原理

公钥密码体制是一种陷门单向函数

?>单向函数:定义域到值域的一个映射,同时满足计算函数值是容易的,而从函数值计算原象是不可行的

?>陷门单向函数:单向函数,存在一个附加信息,当不知道附加信息时,从函数值求原象是困难的,当知道附加信息时,过程变得简单,即未知时为单向函数,已知时不再是单向函数,将附加信息称为陷门信息

公钥密码体制将陷门单向函数作为公开密钥,将陷门信息作为秘密密钥,安全强度取决于陷门函数的计算复杂度

### 数论基础

1. 设$a$,$b$是整数,$a!=b$,如果有一个整数$x$,使得$b=ax$,则$b$叫做$a$的倍数,$a$叫做$b$的因数,或者说$a$能整除$b$,或$b$能被$a$整除,记为$a|b$

- 若$a|b$,那么对任何整数$c$,都有$a|bc$
- 若$a|b$,$b|c$,那么有$a|c$
- 若$a|b$,$a|c$,那么对任何整数$x$和$y$,都有$a|(bx+cy)$
- 若$a|b$,$b|a$,那么$a=+-b$
- 若$a|b$,$a>0$,$b>0$,那么$a<=b$

2. 给定任意整数$a$和$b$,且$a>0$,必存在唯一的整数$q$和$r$,满足$b=qa+r$,其中$0<=r<a$,$q$称为商,$r$称为余

3. 若$a$,$b$,$c$都是整数,且$a|b$,$a|c$,那么称$a$是$b$和$c$的公因数,在所有公因数中最大的一个,称为最大公因数,计为$gcd(b,c)$或$(b,c)$

4. 设$a$,$b$,$c$都是整数,$a$,$b$都不为零,如果$a|c$,$b|c$,则称$c$是$a$和$b$的公倍数,如果$a$和$b$的公倍数$c$除尽$a$和$b$的任一个公倍数,则称$c$是$a$和$b$的最下公倍数,记为$c=lcm(a,b)$或$c=[a,b]$

5. 若一个**大于1**的正整数$p$,只能被1和它本身整除,不能被其他正整数整除,则称这样的正整数$p$为素数或质数

6. 一个正整数可以写成几个素数的乘积,且结果唯一

7. 如果$a$和$b$的最大公因数是1,即$gcd(a,b)=1$,则称$a$和$b$互素

8. 欧几里得除法:给定整数$b$和$c$,且$c>0$,重复使用带余除法,直至余数为0,可得以下方程

$$
b=cq_1 + r_1 , 0<r_1<c
$$
$$
c=r_1q_2 + r_2 , 0<r_2<r1
$$
$$
r_1=r_2q_3 + r_3 , 0<r_3<r2
$$
$$
...
$$
$$
r_{j+1}=r_jq_{j+1}
$$

最后一个不为零的余数$r_j$就是$b$和$c$的最大公因数$gcd(b,c)$

9. 费马小定理:假如$a$是一个整数,$p$是一个质数,那么$a^p−a$是$p$的倍数,可以表示为
$$
a^p≡a (mod p)
$$
如果$a$不是$p$的倍数,这个定理也可以写成
$$
a^{p−1}≡1 (mod p)
$$

10. 欧拉定理:如果$gcd(a,m)=1$,则恒有
$$
a^{φ(m)}≡1 (mod m)
$$
其中$φ(m)$是欧拉函数,$φ(m)$的值等于小于$m$且与$m$互素的正整数的个数

11. 欧拉函数的性质:令$m$和$n$表示任意两个互素的正整数,即$gcd(m,n)=1$,则$φ(nm)=φ(m)φ(n)$

12. 中国剩余定理:设$m_1$,$m_2$,...,$m_k$是两两互素的正整数,令
$$
M=m_1m_2...m_k=m_1M_1=m_2M_2=...=m_kM_k
$$

其中$M_i=M/m_i$,$i=1,2,...,k$,则下面的同余方程组
$$
x≡b_i (mod m_i),i=1,2,...,k
$$

的正整数解$x_0$存在,且在模$M$的意义下是唯一的
$$
x_0=b_1M_1^{'}M_1+b_2M_2^{'}M_2+...b_kM_k^{'}M_k (mod M)
$$

$M^{'}$满足
$$
M_i^{'}M_i≡1 (mod m_i),i=1,2,...,k
$$

的正整数,即$M_i^{'}$是$M_i$以$m_i$为模的乘法逆元

### 群

群$(G,·)$是由集合$G$和二元运算$·$构成的,符合以下四个性质的数学结构

其中,二元运算结合任何两个元素$a$和$b$而形成另一个元素,记为$a·b$,符号$·$是具体的运算,比如整数加法

群公理所述的四个性质为:

1. **封闭性**: 对于所有$G$中$a$,$b$,运算$a·b$的结果也在$G$中

2. **结合律**: 对于所有$G$中的$a$,$b$和$c$,等式$(a·b)·c=a·(b·c)$成立

3. **单位元**: 存在$G$中的一个元素$e$,使得对于所有$G$中的元素$a$,总有等式$e·a=a·e=a$成立

4. **逆元**: 对于每个$G$中的$a$,存在$G$中的一个元素$b$使得总有$a·b=b·a=e$,此处$e$为单位元

例如:全体整数对加法构成群,而对乘法不构成群(零是加法的单位元)

### 平方剩余问题

设$a$和$n$互素,若方程$x^2≡a (mod n)$有解,则称$a$是模$n$的平方剩余,否则称为非平方剩余

若$p$是奇素数,$p$不能整除$a$,则$x^2≡a (mod n)$无解或有两个模$p$不同余的解

若$p$是奇素数,则整数$1,2,...,p-1$中正好有$(p-1)/2$个是模$p$的平方剩余,其余的$(p-1)/2$个是非平方剩余

当$n$是合数时,若$n$的分解未知,则求方程$x^2≡a (mod n)$的解时困难的

**Blum整数**: 如果$p$和$q$是两个素数,且$p≡3 (mod 4)$,$q≡3 (mod 4)$,那么$n=p*q$称为Blum整数,如果$n$是一个Blum整数,那么它的每一个二次剩余恰好有`4`个平方根,其中一个也是平方,这就是主平方根

**本原元**:如果$p$是一个素数,且$g$小于$p$,若对于从$0$到$p-1$的每一个$y$,都存在某个$x$,使得$g^x≡y (mod p)$成立,那么$g$是$Z_p$的乘法群$Z_p^*$的生成元,称$g$是模$p$的本原元

### RSA

[https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_theory-zh/](https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_theory-zh/)

#### 基本原理

- 公钥与私钥的产生

1. 随机选择两个不同大质数$p$和$q$,计算$N = p \times q$
2. 根据欧拉函数,求得$\varphi (N)=\varphi (p)\varphi (q)=(p-1)(q-1)$
3. 选择一个小于$\varphi (N)$的整数$e$,使$e$和$\varphi (N)$互质,并求得$e$关于$\varphi (N)$的模反元素,命名为 $d$,有$ed\equiv 1 \pmod {\varphi (N)}$
4. 将$p$和$q$的记录销毁

此时,$(N,e)$是公钥,$(N,d)$是私钥

- 消息加密

首先需要将消息以一个双方约定好的格式转化为一个小于$N$,且与$N$互质的整数$m$

如果消息太长,可以将消息分为几段,这也就是我们所说的块加密,后对于每一部分利用如下公式加密:

$$
m^{e}\equiv c\pmod N
$$

- 消息解密

利用密钥$d$进行解密

$$
c^{d}\equiv m\pmod N
$$

#### 正确性证明

即我们要证$m^{ed} \equiv m \bmod N$,已知$ed \equiv 1 \bmod \phi(N)$,那么$ed=k\phi(N)+1$,即需要证明

$$
m^{k\phi(N)+1}  \equiv m \bmod N
$$

这里我们分两种情况证明

第一种情况$gcd(m,N)=1$,那么$m^{\phi(N)} \equiv 1 \bmod N$,因此原式成立

第二种情况$gcd(m,N)\neq 1$,那么$m$ 必然是$p$或者$q$的倍数,并且$n=m$小于$N$,我们假设

$$
m=xp
$$

那么$x$必然小于$q$,又由于$q$是素数,那么

$$
m^{\phi(q)} \equiv 1 \bmod q
$$

进而

$$
m^{k\phi(N)}=m^{k(p-1)(q-1)}=(m^{\phi(q)})^{k(p-1)} \equiv 1 \bmod q
$$

那么

$$
m^{k\phi(N)+1}=m+uqm
$$

进而

$$
m^{k\phi(N)+1}=m+uqxp=m+uxN
$$

所以原式成立

#### 例子

- 密钥生成

首先取$p=11$,$q=13$,计算$n=p*q=143$,$\phi(n)=(p-1)*(q-1)=120$

然后选取$e=17$,满足$gcd(e,\varphi(n))=gcd(17,120)=1$

计算私钥$d=e^{-1} (mod 120)=113$

最后公布公钥$(e,n)=(17,143)$,保留私钥$d=113$

- 加密

对明文信息$m=24$进行加密,则密文为$c≡m^e=24^{17} (mod 143)=7$

- 解密

接收到密文$c=7$后,利用私钥$d=113$对密文解密$m≡c^d=7^{113} (mod 143)=24$

#### 安全性

1. $p$和$q$的长度应该相差不大

2. $(p-1)$和$(q-1)$都应该包含大的素因子

3. $gcd(p-1,q-1)$应该尽可能小

### ElGamal

[ElGamal加密算法](https://zh.wikipedia.org/wiki/ElGamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95)

- 密钥生成

密钥生成的步骤如下:

Alice利用生成元$g$产生一个$q$阶循环群$G$的有效描述,该循环群需要满足一定的安全性质

Alice从${ 1 , … , q − 1 }$中随机选择一个$x$

Alice计算$h := g$

Alice公开$h$以及$G$,$q$,$g$的描述作为其公钥,并保留$x$作为其私钥,私钥必须保密

- 加密

使用Alice的公钥$( G , q , g , h )$向她加密一条消息$m$的加密算法工作方式如下:

Bob从${ 1 , … , q − 1 }$随机选择一个$y$,然后计算$c_1 := g^y$

Bob计算共享秘密$s := h^y$

Bob把他要发送的秘密消息$m$映射为$G$上的一个元素$m'$

Bob计算$c_{2}:=m'\cdot s$

Bob将密文$(c_{1},c_{2})=(g^{y},m'\cdot h^{y})=(g^{y},m'\cdot (g^{x})^{y})$发送给Alice

值得注意的是,如果一个人知道了$m'$,那么它很容易就能知道$h^{y}$的值,因此对每一条信息都产生一个新的$y$可以提高安全性,所以$y$也被称作临时密钥

- 解密

利用私钥$x$对密文$(c_{1},c_{2})$进行解密的算法工作方式如下:

Alice计算共享秘密$s:=c_{1}{}^{x}$

然后计算$m':=c_{2}\cdot s^{-1}$,并将其映射回明文$m$,其中$s^{-1}$是$s$在群$G$上的逆元(例如:如果$G$是整数模n乘法群的一个子群,那么逆元就是模逆元)

解密算法是能够正确解密出明文的,因为

$c_{2}\cdot s^{-1}=m'\cdot h^{y}\cdot (g^{xy})^{-1}=m'\cdot g^{xy}\cdot g^{-xy}=m'.$

### Cramer-Shoup

- 公钥与私钥的产生

1. 从一个$q$阶循环群$G$中得到两个生成元$g_1,g_2$
2. 从${0,..,q-1}$中选择5个随机值$(x_1,x_2,y_1,y_2,z)$
3. $c=g_1^{x_1}*g_2^{x_2},d=g_1^{y_1}*g_2^{y_2},h=g_1^{z}$
4. 公开$PK=(c,d,h,G,q,g_1,g_2)$,保留$SK=(x_1,x_2,y_1,y_2,z)$

- 消息加密

从${0,..,q-1}$中选择一个随机值$k$

$u_1=g_1^{k},u_2=g_2^{k}$

$e=h^{k}*m$

$\alpha=H(u_1,u_2,e)$,$H$为hash函数

$v=c^{k}*d^{ka}$

$C=(u_1,u_2,e,v)$

返回$C$

- 消息解密

$\alpha=H(u_1,u_2,e)$,若$u_1^{x_1}*u_2^{x_2}*(u_1^{y_1}*u_2^{y_2})^{\alpha}=v$,则$m=e/(u_1^{z})$

### 安全模型IND-CPA

[https://en.wikipedia.org/wiki/Ciphertext_indistinguishability](https://en.wikipedia.org/wiki/Ciphertext_indistinguishability)

>选择明文攻击

1. 挑战者基于一些安全性参数k(例如,以位为单位的密钥大小)生成密钥对PK,SK,并将PK发布给对手

2. 对手提交两个等长的明文$m_{0},m_{1}$,挑战者选择$b\scriptstyle \in(0, 1)$,计算$C*=Enc(PK,M_{b})$,然后将$C*$交给对手

3. 对手输出猜测,即确定是对$m_{0}$还是对$m_{1}$的加密

假设正确率等于$0.5+\varepsilon$,如果$\varepsilon$的值可以被忽略,则说明该算法是安全的,反之,则是不安全的

RSA无法通过IND-CPA

ElGamal可以通过IND-CPA

Cramer-Shoup可以通过IND-CPA

### 安全模型IND-CCA(2)

[https://en.m.wikipedia.org/wiki/Adaptive_chosen-ciphertext_attack](https://en.m.wikipedia.org/wiki/Adaptive_chosen-ciphertext_attack)

>(自适应)选择密文攻击

1. 挑战者基于一些安全性参数k(例如,以位为单位的密钥大小)生成密钥对PK,SK,并将PK发布给对手

2. 对手可以执行任意数量的解密查询,当对手提交一个密文$C$进行查询时,挑战者将$Dec(SK,C)$的结果返回给对手

3. 对手提交两个等长的明文$m_{0},m_{1}$,挑战者选择$b\scriptstyle \in(0, 1)$,计算$C*=Enc(PK,M_{b})$,然后将$C*$交给对手

4. 在(IND-CCA)中,跳转到5,否则对手可以继续执行任意数量的解密查询,但不能解密$C*$

5. 对手输出猜测,即确定是对$m_{0}$还是对$m_{1}$的加密

如果没有对手在赢得上述比赛中具有不可忽略的优势,则该方案是IND-CCA1/IND-CCA2安全的

RSA(不可以通过IND-CCA?),不能通过IND-CCA2

ElGamal可以通过IND-CCA,不能通过IND-CCA2

Cramer-Shoup可以通过IND-CCA2

## 第四部分

>数字签名就是将公钥密码反过来使用,签名者将讯息用私钥加密(这是一种反用,因为通常公钥密码中私钥用于解密),然后公布公钥,验证者使用公钥将加密讯息解密并比对消息

数字签名具有以下特征:

- 收方能够确认或证实发方的签名,但不能伪造
- 发方发出签名的消息给收方后,就不能再否认他所签发的消息
- 收方对已收到的签名消息不能否认
- 第三者可以确认收发双方之间的消息传送,但不能伪造这一过程 

一个数字签名由如下算法组成:

- **密钥生成算法**$KeyGen(k)$:输入安全参数$k$,输出用户的公/私钥对$(pk,sk)$
- **签名算法**$Sign(sk,m)$:输入私钥$sk$和消息$m$,该算法输出签名$σ$
- **验证算法**$Verify(pk,σ,m)$:输入公钥$pk$和签名$σ$,若$σ$是针对$pk$和$m$的一个有效签名,该算法输出`1`,否则输出`0`

算法的正确性要求:对于任意$m$,均有$Verify(pk,Sign(sk,m))=1$成立

### RSA签名方案

- **密钥生成算法**$KeyGen(k)$:

1. 首先选取两个大素数$p$和$q$,计算$n=p*q$,其欧拉函数值为$\phi(n)=(p-1)*(q-1)$

2. 随机选取整数$e$,满足$gcd(e,\phi(n))=1$,并计算$d=e^{-1}(mod \phi(n))$

3. 公钥为$pk=(e,n)$,私钥为$sk=d$,可以对$p,q$进行销毁

- **签名算法**$Sign(sk=d,m)$:对于信息$m\scriptstyle \in Z_n$,其签名为$σ=H(m)^{d}(mod n)$

- **验证算法**$Verify(pk=e,σ,m)$:当接收者收到签名$σ$时,检验$m=σ^{e}(mod n)$是否成立,若成立则输出`1`,否则输出`0`

### ElGamal签名方案

- **密钥生成算法**$KeyGen(k)$:

设$p$是一个大素数,选取生成元$g\scriptstyle \in Z_p^{*}$,选取一个防碰撞的hash函数$H:{0,1}^*->Z_p^{*}$,随机选取$x\scriptstyle \in Z_p^{*}$,令$y=g^x(mod p)$,公钥为$pk=(G,p,g,y,H)$,私钥为$sk=x$

- **签名算法**$Sign(sk,m)$:选取随机数$0<k<p-1$且$gcd(k,p-1)=1$,计算$r≡g^
k(mod p)$和$s≡(H(m)-x*r)*k^{-1}(mod (p-1))$,输出签名$σ=(r,s)$

- **验证算法**$Verify(pk=e,σ,m)$:检查$g^{H(m)}≡y^{r}*r^{s}(mod p)$是否成立,若成立则输出`1`,否则输出`0`

### Schnorr签名方案

- **密钥生成算法**$KeyGen(k)$:选取一个阶为大素数$p$的群$G$,选取生成元$g\scriptstyle \in G$,选取一个防碰撞的hash函数$H:{0,1}^*->Z_p^{*}$,随机选取$x\scriptstyle \in Z_p^{*}$,将公钥设为$y=g^x$,私钥设为$sk=x$

- **签名算法**$Sign(sk,m)$:选取随机数$r\scriptstyle \in Z_p^{*}$计算$R=g^{r},e=H(m,R),s=(r-x*e)(mod p)$,输出签名$σ=(r,s)$

- **验证算法**$Verify(pk=σ,m)$:计算$R^{'}=g^{s}*y^{e}$,检查$H(m,R^{'})=e$是否成立,若成立则输出`1`,否则输出`0`

### 数字签名标准

- **密钥生成算法**$KeyGen(k)$:选取一个512至1024位的大素数$p$,且$p-1$有一个160比特的素因子$q$,选取一个模$p$的阶为$q$的数$g$,然后随机选取$x$满足$0<x<q$,将公钥设为$y=g^x$,私钥设为$sk=x$

- **签名算法**$Sign(sk,m)$:选取随机数$k$满足$0<k<q$,计算$r=(g^{k}(mod p))(mod q),s=(k^{-1}*(H(m)+x*r))(mod q)$,输出签名$σ=(r,s)$

- **验证算法**$Verify(pk=σ,m)$:计算$w=s^{-1}(mod q),u_1=H(m)*w(mod q),u_2=r*w(mod q)$,检查$(g^{u_1}*y^{u_2}(mod p))(mod q)=r$是否成立,若成立则输出`1`,否则输出`0`

### 安全模型EUF-CMA

1. 挑战者运行$KeyGen$算法生成公/私钥对$(pk,sk)$,将公钥$pk$交给对手

2. 对手进行一系列查询,对手提交一个消息$m_i$,挑战者进行$Sign(sk,m_i)$,将产生的签名$σ_i$交给对手

3. 对手输出$(m^{*},σ^{*})$,若$Verify(pk,σ^{*},m^{*})=1$,且对手对$m^{*}$进行询问,则对手赢得该游戏

假设正确率等于$0.5+\varepsilon$,如果$\varepsilon$的值可以被忽略,则说明该签名方案是安全的,反之,则是不安全的