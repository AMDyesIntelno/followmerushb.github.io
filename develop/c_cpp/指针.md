`int array[10];`

`&array` 和 `&array[0] (即array)` 不同

数组名被解释为其第一个元素的地址,而对数组名应用地址运算符时,得到的是整个数组的地址

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int main(){
    int array[10];
    cout<<array<<endl;//输出array[0]的地址
    cout<<&array<<endl;
    cout<<array+1<<endl;//输出array[1]的地址
    cout<<&array+1<<endl;
    return 0;
}

/*
0x7fffffffdfa0
0x7fffffffdfa0
0x7fffffffdfa4
0x7fffffffdfc8
*/
```

从数字上说,`&array` 和 `&array[0] (即array)` 相同

但从概念上说, `&array[0](即array)` 是一个4字节内存块的地址,而 `&array` 是一个40字节内存块的地址

因此,表达式 `array+1` 将地址值加4,而表达式 `&array+1` 将地址加40

换句话说,`array`是一个int指针`(* int)`,而`&array`是一个这样的指针,即指向包含10个元素的array数组`(int (*) [10])`

### 指针数组

```cpp
const char *ch[3]={"asfd","qwer","zxcv"};
int a=0,b=1,c=2,d=3;
int *p[4];
p[0]=&a;
p[1]=&b;
p[2]=&c;
p[3]=&d;
```

### 数组指针

```cpp
int a[2][2]={1,2,3,4};
int (*c)[2]=a;
```

### 指针函数

```cpp
char *fun(void){
    char temp[80];
    cin.get(temp,80);
    char *s=new char[strlen(temp)+1];
    strcpy(s,temp);
    return s;
}
int main(){
    char *str=fun();
    cout<<str;
    delete []str;
    return 0;
}

int *fun(void){
    int *a=new int[3];
    a[0]=123;
    a[1]=654;
    a[2]=987;
    return a;
}
int main(){
    int *arr=fun();
    cout<<arr[0]<<' '<<arr[1]<<' '<<arr[2]<<endl;
    cout<<arr<<' '<<arr+1<<' '<<arr+2;
    delete []arr;
    return 0;
}
```

### 函数指针

```cpp
/*typeName (*fun_ptr)(type1,type2...)  声明一个指向同样参数、返回值的函数指针类型*/

int get_max(int a,int b){
    return a>b?a:b;
}
int fun(int x,int y,int z,int(*f)(int a,int b)){
    return f(f(x,y),z);
}
```

### 指针的递增递减

```cpp
int arr[5]={10,20,30,40,50};
int *pt=arr;
cout<<*pt<<' '<<++*pt<<' '<<*(++pt)<<' '<<*pt++<<' '<<*pt<<endl;
/*后缀运算符++的优先级更高,这意味着将运算符用于pt,而不是*pt,因此对指针递增
然而后缀运算符意味着将对原来的地址(&arr[1])而不是递增后的新地址解除引用
因此*pt++的值为arr[1],即20,但该语句执行完毕后,pt的值将为arr[2]的地址*/
for(int i=0;i<5;++i){
    cout<<arr[i]<<' ';
}
cout<<endl;
pt=&arr[4];
cout<<*pt<<' '<<--*pt<<' '<<*(--pt)<<' '<<*pt--<<' '<<*pt<<endl;
for(int i=0;i<5;++i){
    cout<<arr[i]<<' ';
}
return 0;

/*
10 11 20 20 30
11 20 30 40 50 
50 49 40 40 30
11 20 30 40 49
*/
```

### 创建二维数组

1.使用一维数组模拟二维数组

```cpp
int x=2,y=3;
int arr[6]={1,2,3,4,5,6};
for(int i=0;i<x;++i){
    for(int j=0;j<y;++j){
				cout<<arr[i*y+j]<<' ';
		}
}
```

2.静态二维数组

```cpp
int arr[2][3]={1,2,3,4,5,6};
```

3.动态二维数组

```cpp
int **a=new int*[2];
for(int i=0;i<2;++i){
		a[i]=new int[3];
}
for(int i=0;i<2;++i){
    for(int j=0;j<3;++j){
        a[i][j]=i+j;
    }
}
for(int i=0;i<2;++i){
    for(int j=0;j<3;++j){
        cout<<a[i][j]<<' ';
    }
}
for(int i=0;i<2;++i){
    delete []a[i];
}
delete []a;
```

### const

```cpp
int a = 3, b = 5;
const int* pt1 = &a;
int* const pt2 = &a;
const int* const pt3 = &a;
//(*pt1)++; 无法执行
cout << *pt1 << endl;
pt1 = &b;
cout << *pt1 << endl;
cout << a << endl;
(*pt2)++;
cout << a << endl;
//pt2 = &b; 无法执行
//(*pt3)++; 无法执行
//pt3 = &b; 无法执行

/*
3
5
3
4
const int* pt1 = &a
const修饰*pt1,说明不能修改*pt1的值,即不能通过*pt1修改a的值,但是可以修改pt1,即pt1 = &b,修改指针的指向
int* const pt2 = &a;
const修饰pt2,说明不能修改pt2的值,即不能修改pt2的指向,但是可以修改*pt2,即(*pt2)++可以成立
const int* const pt3 = &a;
const同时修饰了pt3和*pt3,完全不能修改
const int 与 int const等价
*/
```