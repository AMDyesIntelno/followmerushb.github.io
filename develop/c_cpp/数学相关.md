### 圆周率表示

利用`<cmath>`头文件

```cpp
const double pi=acos(-1.0);
```

### 弧度与角度

`c/c++`中进行`sin/cos`运算时是使用弧度制

弧度转角度

`a=a*pi/180;`

### 关于素数

除2 3外的任何质数,除以6的余数一定是1或5

若余数是0或2或4,则该数可被2整除,不是质数,若余数是3,则该数可被3整除,不是质数

首先6的倍数(包括六)肯定不是质数,因为它能被6整除

其次6x+2肯定也不是质数,因为它还能被2整除

依次类推

6x+3肯定能被3整除

6x+4肯定能被2整除

那么,就只有6x+1和6x+5(等同于6x-1)可能是质数了

所以循环的步长可以设为6,然后每次只判断6两侧的数(5和7)即可

```cpp
bool is_prime(int a){
    if(a==1)return 0;
    if(a==2||a==3)return 1;
    if(a%6!=1&&a%6!=5)return 0;//此处必须为&&,若为||,则a=7时,a%6==1,a%6!=5,return 0,但显然7为素数
    for(int i=5;i<=sqrt(a);i+=6)
        if(a%i==0||a%(i+2)==0)return 0;//5和1可以转化为5和6+1即5和7
    return 1;
}
```

### 素数筛

#### Eratosthenes筛法

```cpp
#include<iostream>

using namespace std;
int a[1000001];

void Eratosthenes(long long n) {
    fill(a, a + 1000001, 1);/*将数组填充为1,假设当前范围内的数均为素数,然后开始筛选*/
    for (long long i = 2; i <= n; ++i) {
        /*先用2去筛,即把2留下,把2的倍数剔除掉；再用下一个素数,也就是3筛,把3留下,把3的倍数剔除掉；接下去用下一个素数5筛,把5留下,把5的倍数剔除掉；不断重复下去......*/
        for (long long j = i * i; j <= n; j += i) {/*此处应从i的平方开始计算,以减少计算量*/
            a[j] = 0;
        }
    }
}

int main() {
    long long n;
    cin >> n;
    Eratosthenes(n);
    for (long long i = 2; i <= n; ++i) {
        if (a[i]) {
            cout << i << ' ';
        }
    }
    return 0;
}
```

#### Euler筛法

```cpp
#include<iostream>

using namespace std;
long long a[1000001];//a用于记录已经判断出是素数的数
bool b[1000001];//b用于判断当前数字是否为素数
void Euler(long long n) {
    fill(b, b + 1000001, 1);/*将数组填充为1,假设当前范围内的数均为素数,然后开始筛选*/
    b[0] = false;
    b[1] = false;/*0,1均不是素数*/
    int cnt = 0;/*确定素数在数组a中的放置位置*/
    for (long long i = 2; i <= n; ++i) {
        if (b[i]) {
            a[cnt++] = i;/*将当前素数储存并记录*/
        }
        for (int j = 0; j < cnt && i * a[j] <= n; ++j) {
            b[i * a[j]] = false;/*已储存素数的倍数均为合数*/
            if (!(i % a[j])) {/*i%a[j]==0表明i是一个素数的倍数,说明i在之前已经被筛过了,无需再筛*/
                break;
            }
        }
    }
}

int main() {
    long long n;
    cin >> n;
    Euler(n);
    for (long long i = 0; i <= n; ++i) {
        if (a[i]) {
            cout << a[i] << ' ';
        }
    }
    return 0;
}
```

### 欧拉函数

[欧拉函数 OI-WIKI](https://oi-wiki.org/math/euler/)

#### 求单个数的欧拉函数

```cpp
#include<iostream>
#include<cmath>

using namespace std;

int euler_phi(int n) {
    int m = int(sqrt(n + 0.5));
    int ans = n;
    for (int i = 2; i <= m; ++i) {
        /*φ(x)=x(1-1/p(1))(1-1/p(2))(1-1/p(3))…..(1-1/p(n))*/
        if (n % i == 0) {/*判断i是否为n的质因数*/
            ans = ans / i * (i - 1);/*先进行除法运算避免溢出*/
            /*ans/i*(i-1)=ans*(1-1/i)*/
            while (n % i == 0) {
                n /= i;/*保证n在遇到下一个质因数之前不会再进行计算*/
                /*假定n=20,n可由质因数累积而成,n=2*2*5
                  显然4为n的因数,但不是质因数,在该while循环中
                  4被除去,因此可以保证下一次运算必定为质因数*/
            }
        }
    }
    if (n > 1) {
        ans = ans / n * (n - 1);/*最后剩下的一个质因数*/
        /*例如n=5,与n互质的数为1,2,3,4
          在上一步的for循环中没有符合条件的质因数
          说明n是质数,所以φ(n)=n-1
          又例如n=6,在上一步的for循环中只有2被筛出
          n=3,此时n为最后一个质因数
          φ(x)=x(1-1/p(1))(1-1/p(2))(1-1/p(3))…..(1-1/p(n))
          φ(x)=ans(1-1/p(n))
          综合两种情况将其写成ans=ans/n*(n-1)
          */
    }
    return ans;
}

int main() {
    int n;
    cin >> n;
    cout << euler_phi(n);
    return 0;
}
```

#### 筛法求欧拉函数

```cpp
#include<iostream>

using namespace std;
int phi[1000001];

void phi_table(int n) {
    phi[1] = 1;
    /*φ(1)=1*/
    for (int i = 2; i <= n; ++i) {
        if (!phi[i]) {/*保证i是质因数*/
            for (int j = i; j <= n; j += i) {
                if (!phi[j]) {
                    phi[j] = j;/*phi数组的元素与欧拉函数值一一对应*/
                }
                phi[j] = phi[j] / i * (i - 1);/*i作为当前for循环中j的因数*/
                /*例如求6的欧拉函数时,以i=2作为j的循环,以i=3作为j的循环
                  在每一个循环中,当j=6时会以i作为质因数求解欧拉函数*/
                /*ans/i*(i-1)=ans*(1-1/i)*/
                /*φ(x)=x(1-1/p(1))(1-1/p(2))(1-1/p(3))…..(1-1/p(n))*/
            }
        }
    }
}

int main() {
    int n;
    cin >> n;
    phi_table(n);
    for (int i = 1; i <= n; ++i) {
        cout << phi[i] << ' ';
    }
    return 0;
}
```

### 贝祖等式

[wikipedia-扩展欧几里得算法](https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)


|序号 ![](https://latex.codecogs.com/gif.latex?i)|	商 ![](https://latex.codecogs.com/gif.latex?q_{i-1})|	余数 ![](https://latex.codecogs.com/gif.latex?q_i)	|![](https://latex.codecogs.com/gif.latex?s_i)|	![](https://latex.codecogs.com/gif.latex?t_i)|
|---|----|----|---|---|
|0|	|	240|	1|	0|
|1|	|	46|	0|	1|
|2	|240 ÷ 46 = 5|	240 − 5 × 46 = 10	|1 − 5 × 0 = 1|	0 − 5 × 1 = −5|
|3|	46 ÷ 10 = 4|	46 − 4 × 10 = 6|	0 − 4 × 1 = −4	|1 − 4 × −5 = 21|
|4	|10 ÷ 6 = 1|	10 − 1 × 6 = 4|	1 − 1 × −4 = 5	|−5 − 1 × 21 = −26|
|5|	6 ÷ 4 = 1	|6 − 1 × 4 = 2	|−4 − 1 × 5 = −9	|21 − 1 × −26 = 47|
|5(答案)|	6 ÷ 4 = 1	|6 − 1 × 4 = 2	|−4 − 1 × 5 = −9	|21 − 1 × −26 = 47|
|6	|4 ÷ 2 = 2|	4 − 2 × 2 = 0|	5 − 2 × −9 = 23	|−26 − 2 × 47 = −120|

当 ![](https://latex.codecogs.com/gif.latex?i>1) 时

![](https://latex.codecogs.com/gif.latex?s_i=s_{i-2}-s_{i-1}*r_i)

![](https://latex.codecogs.com/gif.latex?t_i=t_{i-2}-t_{i-1}*r_i)

```cpp
#include<iostream>

using namespace std;
int s[3] = {1, 0};
int t[3] = {0, 1};

int gcd(int a, int b) {
    if (a % b == 0) {
        return b;
    }
    else {
        s[2] = s[0] - (a / b) * s[1];
        t[2] = t[0] - (a / b) * t[1];
        s[0] = s[1], s[1] = s[2], t[0] = t[1], t[1] = t[2];
        return gcd(b, a % b);
    }
}

int main() {
    int a, b;
    cin >> a >> b;
    cout << "gcd: " << gcd(a, b) << " s:" << s[1] << " t:" << t[1];
    return 0;
}
```

### 快速幂

#### 递归法(fun1)

`a^b` 假设b为奇数,则 `a^b` 可转化为 `a^(b/2)*a^(b/2)*a`

假设b为偶数,则 `a^b` 可转化为 `a^(b/2)*a^(b/2)`

以此类推,可以得到递归

#### 非递归法(fun2)

假设 `ans = 1` (保证在零次幂时可用)

`a^b` 假设 b 转化为二进制是 101 那么 `a^b` 可以转化为 `a^4 * a^1`

当 b 的二进制的末位是 1 时,将当前二进制位为 1 所对应的幂乘到 `ans` 中

无论此时b 的二进制的末位是否为 1 ,都将 a 平方以对应 b 的下一个二进制位,并将 b 的二进制右移 1 位以更新 b 的二进制末位

```cpp
#include<iostream>

using namespace std;

long long fun1(long long a, long long b) {/*递归法*/
    if (b == 0) {
        return 1;
    }
    long long base = fun1(a, b / 2);
    if (b % 2) {
        return base * base * a;
    }
    else {
        return base * base;
    }
}

long long fun2(long long a, long long b) {/*非递归法*/
    long long ans = 1;
    while (b > 0) {
        if (b & 1) {
            ans *= a;
        }
        a *= a;
        b >>= 1;
    }
    return ans;
}

int main() {
    long long a, b;
    cin >> a >> b;
    cout << fun1(a, b) << " " << fun2(a, b);
    return 0;
}
```

#### 快速幂取余

`(a*b)%c=(a%c*b%c)%c`

`(a^b)%c=((a%c)^b)%c`

注意在最后还有一个 `fun(a, b, c) % c` 

```cpp
#include<iostream>

using namespace std;

long long fun(long long a, long long b, long long c) {
    if (b == 0) {
        return 1;
    }
    long long base = fun(a, b / 2, c);
    if (b % 2) {
        return base * base * a % c;
    }
    else {
        return base * base % c;
    }
}

int main() {
    long long a, b, c;
    cin >> a >> b >> c;
    cout << a << "^" << b << " mod " << c << "=" << fun(a, b, c) % c;
    return 0;
}
```

### 高精度运算

```cpp
/*高精度非负整数四则运算*/
#include<iostream>
#include<cstring>

#define MAX_LEN 20000
using namespace std;

void read(int *num) {//读入,将字符转换为数字并调整位置
    char temp[MAX_LEN + 1];
    memset(temp, '0', sizeof(temp));
    cin >> temp;
    int len = strlen(temp);
    for (int i = 0; i < len; ++i) {
        num[MAX_LEN - i - 1] = temp[len - i - 1] - '0';//位置调整
    }
}

void print(int *num) {//找到第一个非零的数,特殊情况为结果为0,所以最后一位直接输出,不进行判断
    int i;
    for (i = 0; i < MAX_LEN - 1; ++i) {
        if (num[i]) {
            break;
        }
    }
    for (; i < MAX_LEN; ++i) {
        cout << num[i];
    }
}

void add(const int *a, const int *b, int *c) {//竖式加法模拟,满十进一
    int sum = 0;
    for (int i = MAX_LEN - 1; i >= 0; --i) {
        sum += a[i] + b[i];
        c[i] = sum % 10;
        sum /= 10;
    }
}

inline bool is_able(const int *a, const int *b) {//判断能否进行相减
    for (int i = 0; i < MAX_LEN; ++i) {
        if ((a[i] || b[i]) && a[i] != b[i]) {//其中一个不为零且两者不相等
            return a[i] - b[i] > 0;
        }
    }
    return true;//两者完全相等
}

void sub(int *a, int *b, int *c) {//竖式减法模拟
    if (!is_able(a, b)) {//无法直接相减时对换a,b
        swap(a, b);
        cout << '-';
    }
    int sum = 0;
    for (int i = MAX_LEN - 1; i >= 0; --i) {
        sum += a[i] - b[i];
        if (sum < 0) {//借位
            c[i] += sum + 10;
            a[i - 1]--;
        }
        else {
            c[i] = sum;
        }
        sum = 0;
    }
}

void mul(const int *a, const int *b, int *c) {//竖式乘法模拟
    for (int i = MAX_LEN - 1; i >= 0; --i) {
        for (int j = MAX_LEN - 1; j >= i; --j) {
            c[i] += a[j] * b[i - j + MAX_LEN - 1];
        }
        if (c[i] >= 10) {
            c[i - 1] += c[i] / 10;
            c[i] %= 10;
        }
    }
}

void div(int *a, int *b, int *c, int *d) {//竖式除法模拟并生成余数
    int la, lb;
    for (la = 0; la < MAX_LEN; ++la) {//确定位数
        if (a[la] != 0) {
            break;
        }
    }
    for (lb = 0; lb < MAX_LEN; ++lb) {//确定位数
        if (b[lb] != 0) {
            break;
        }
    }
    if (lb == MAX_LEN) {//被除数不能为0
        cout << "ERROR";
        exit(0);
    }
    la = MAX_LEN - la;//确定位数
    lb = MAX_LEN - lb;//确定位数
    if (is_able(a, b)) {//除法本质是多次减法
        for (int i = MAX_LEN - lb; i < MAX_LEN; ++i) {//b向前移位并补零
            b[i - la + lb] = b[i];
        }
        for (int i = MAX_LEN - la + lb; i < MAX_LEN; ++i) {
            b[i] = 0;
        }
    }
    for (int i = la - lb; i >= 0; --i) {//最多需处理的位数
        while (is_able(a, b)) {
            int sum = 0;
            for (int j = MAX_LEN - 1; j >= 0; --j) {
                sum += a[j] - b[j];
                if (sum < 0) {
                    d[j] += sum + 10;
                    a[j - 1]--;
                }
                else {
                    d[j] = sum;
                }
                sum = 0;
            }
            for (int j = 0; j < MAX_LEN; ++j) {
                a[j] = d[j];//余数成为除数
            }
            fill(d, d + MAX_LEN, 0);
            c[MAX_LEN - i - 1]++;//商的对应位置+1
        }
        for (int j = MAX_LEN - 1; j >= MAX_LEN - la; --j) {
            b[j] = b[j - 1];
        }
    }
}

int main() {
    int a[MAX_LEN] = {0};
    int b[MAX_LEN] = {0};
    int c[MAX_LEN] = {0};
    int d[MAX_LEN] = {0};
    cout << "Sample: " << endl << "a" << endl << "<op>" << endl << "b" << endl;
    read(a);
    char temp;
    cin >> temp;
    read(b);
    switch (temp) {
        case '+':
            add(a, b, c);
            print(c);
            break;
        case '-':
            sub(a, b, c);
            print(c);
            break;
        case '*':
            mul(a, b, c);
            print(c);
            break;
        case '/':
            div(a, b, c, d);
            cout << "商: ";
            print(c);
            cout << endl;
            cout << "余: ";
            print(a);
            break;
        default:
            cout << ">-<";
            break;
    }
    return 0;
}
```