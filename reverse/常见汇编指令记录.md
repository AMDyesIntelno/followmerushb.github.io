1. `SHL`与`SHR`

`SHL` 左移指令使目的操作数逻辑左移一位,最低位用`0`填充,最高位移入进位标志位,而进位标志位中原来的数值被丢弃

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/CTF/reverse/SHL.gif)

`SHR` 右移指令使目的操作数逻辑右移一位,最高位用`0`填充,最低位移入进位标志位,而进位标志位中原来的数值被丢弃

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/CTF/reverse/SHR.gif)

2. `SAL`与`SAR`

`SAL` 算术左移指令与`SHL`指令相同

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/CTF/reverse/SAL.gif)

`SAR` 算术右移指令将目的操作数进行算术右移

![](https://cdn.jsdelivr.net/gh/AMDyesIntelno/blog_img@master/Notes/CTF/reverse/SAR.gif)

`SAR`会根据最高位是否为1来拓展符号位

假设`AX=1000 0000`,`SAR AX 1`,`AX=1100 0000`

`0xE8`:`CALL`

`0x90`:`NOP`

---

`test eax,eax`

`test`逻辑与运算结果为零,就把ZF(零标志)置1

当`eax=0`时,置z标志位为1,`jz`跳转,`jnz`不跳转

当`eax=1`时,置z标志位为0,`jz`不跳转,`jnz`跳转

`cmp eax,eax`

`cmp`算术减法运算结果为零,就把ZF(零标志)置1

当`eax=0`时,置z标志位为1,`jz`跳转,`jnz`不跳转

当`eax=1`时,置z标志位为1,`jz`跳转,`jnz`不跳转

test相当于两个参数做逻辑与运算,cmp相当与两个参数做减法运算

如果结果为0就置z标志位为1,如果结果不为0就置z标志位为0

当z标志位为1时,`jz`跳转,`jnz`不跳转

当z标志位为0时,`jz`不跳转,`jnz`跳转

`jz`:结果为0时跳转

`jnz`:结果不为0时跳转